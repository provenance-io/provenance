syntax = "proto3";
package provenance.metadata.v1.p8e;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/provenance-io/provenance/x/metadata/types/p8e";

option java_package        = "io.provenance.metadata.v1.p8e";
option java_multiple_files = true;

// This stuff only exists to help facilitate the transition to new stuff.
// It is copied from (or modeled after) old stuff.
// The goal is to remove this entire file (and everything defined in it) in the near future.

// P8eMsg defines the immediately deprecated p8e Metadata Msg service.
service P8eMsg {
  // MemorializeContract records the results of a P8e contract execution as a session and set of records in a scope
  rpc MemorializeP8eContract(P8eMsgMemorializeP8eContractRequest) returns (P8eMsgMemorializeP8eContractResponse);
}

// P8eMsgMemorializeP8eContractRequest is the input for a MemorializeP8eContract call
message P8eMsgMemorializeP8eContractRequest {
  // The scope id of the object being add or modified on blockchain.
  string scope_id = 1;
  // The uuid of the contract execution.
  string group_id = 2;
  // Unique identifier for determining contract/session execution instance
  string execution_id = 3;
  // The new recitals for the scope.  Used in leu of Contract for direct ownership changes.
  Recitals recitals = 4;
  // The executed contract.
  Contract contract = 5;
  // The contract signatures
  SignatureSet signatures = 6;
  // The address of the notary (ie the broadcaster of this message).
  bytes invoker = 7;
}

// P8eMsgMemorializeP8eContractResponse is the out for a MemorializeP8eContract call
message P8eMsgMemorializeP8eContractResponse {}

// The rest of the messages defined in here were copied from the old provenance repo.
// Changes:
// * locations of types were updated, e.g. types.PartyType became just PartyType
// * Lots of comments added to conform with new requirements.

message Contract {
  DefinitionSpec definition = 1;

  // Points to the proto for the contractSpec
  Fact spec = 2;

  // Invoker of this contract
  SigningAndEncryptionPublicKeys invoker = 3;

  // Constructor arguments.
  // These are always the output of a previously recorded consideration.
  repeated Fact inputs = 4;

  repeated Condition     conditions     = 5;
  repeated Consideration considerations = 6;

  repeated Recital recitals = 7;

  int32 times_executed = 8;

  // This is only set once when the contract is initially executed
  google.protobuf.Timestamp start_time = 9;
}

message DefinitionSpec {
  string             name              = 1;
  Location           resource_location = 2;
  Signature          signature         = 3;
  DefinitionSpecType type              = 4;
}

message Fact {
  string   name          = 1;
  Location data_location = 2;
}

message Condition {
  string          condition_name = 1;
  ExecutionResult result         = 2;
}

message Consideration {
  string consideration_name = 1;

  // Data pushed to a consideration that will ultimately match the output_spec of the consideration
  repeated ProposedFact inputs = 2;

  ExecutionResult result = 3;
}

message ProposedFact {
  string              name      = 1;
  string              hash      = 2;
  string              classname = 3;
  ProvenanceReference ancestor  = 4;
}

message ExecutionResult {
  ProposedFact              output        = 1;
  ExecutionResultType       result        = 2;
  google.protobuf.Timestamp recorded_at   = 3;
  string                    error_message = 4;
}

message Recitals {
  repeated Recital parties = 1;
}

message Recital {
  PartyType                      signer_role = 1;
  SigningAndEncryptionPublicKeys signer      = 2;
  bytes                          address     = 3;
}

message Location {
  ProvenanceReference ref       = 1;
  string              classname = 2;
}

message ProvenanceReference {
  // [Req] [Scope.uuid]
  // Scope ID
  UUID scope_uuid = 1;
  // [Opt] [RecordGroup.group_uuid]
  // require record to be within a specific group
  UUID group_uuid = 2;
  // [Opt] [Record.result_hash]
  // specify a specific record inside a scope (and group) by result-hash
  string hash = 3;
  // [Opt] [Record.result_name]
  // specify a result-name of a record within a scope
  string name = 4;
}

message SignatureSet {
  repeated Signature signatures = 1;
}

message Signature {
  // Signature Detail
  string algo      = 1;
  string provider  = 2;
  string signature = 3;

  // Identity of signer
  SigningAndEncryptionPublicKeys signer = 4;
}

message SigningAndEncryptionPublicKeys {
  PublicKey signing_public_key    = 1;
  PublicKey encryption_public_key = 2;
}

message PublicKey {
  bytes          public_key_bytes = 1;
  PublicKeyType  type             = 2;
  PublicKeyCurve curve            = 3;
}

message UUID {
  string value = 1;
}

enum DefinitionSpecType {
  DEFINITION_SPEC_TYPE_UNKNOWN   = 0;
  DEFINITION_SPEC_TYPE_PROPOSED  = 1;
  DEFINITION_SPEC_TYPE_FACT      = 2;
  DEFINITION_SPEC_TYPE_FACT_LIST = 3;
}

enum PublicKeyCurve {
  SECP256K1 = 0;
  P256      = 1;
}

enum PublicKeyType { ELLIPTIC = 0; }

enum ExecutionResultType {
  RESULT_TYPE_UNKNOWN = 0;
  RESULT_TYPE_PASS    = 1;
  // Couldn't process the condition/consideration due to missing facts being generated by other considerations.
  RESULT_TYPE_SKIP = 2;
  RESULT_TYPE_FAIL = 3;
}

enum PartyType {
  PARTY_TYPE_UNKNOWN    = 0;
  PARTY_TYPE_ORIGINATOR = 1;
  PARTY_TYPE_SERVICER   = 2;
  PARTY_TYPE_INVESTOR   = 3;
  PARTY_TYPE_CUSTODIAN  = 4;
  PARTY_TYPE_OWNER      = 5;
  PARTY_TYPE_AFFILIATE  = 6;
  PARTY_TYPE_OMNIBUS    = 7;
  PARTY_TYPE_PROVENANCE = 8;
  PARTY_TYPE_MARKER     = 9;
}
