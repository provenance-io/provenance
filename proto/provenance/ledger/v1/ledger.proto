syntax = "proto3";
package provenance.ledger.v1;

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";

option go_package          = "github.com/provenance-io/provenance/x/ledger";
option java_package        = "io.provenance.ledger.v1";
option java_multiple_files = true;

// LedgerClass contains the configuration for a ledger related to a particular class of asset. The asset class
// is defined by the either a scope spec `x/metadata`, or nft class `x/nft`. Ultimately, the configuration will
// assist in verifying the types that are associated with particular ledger entries.
message LedgerClass {
  // Unique ID for the ledger class (eg. 1, 2, 3, etc.)
  // This is necessary since the nft class does not have an owner.
  string ledger_class_id = 1;

  // Scope Specification ID or NFT Class ID
  string asset_class_id = 2;

  // Denom that this class of asset will be ledgered in
  string denom = 3;

  // Address of the maintainer for the ledger class
  string maintainer_address = 4 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // List of entry types for this ledger class
  repeated LedgerClassEntryType entry_types = 5;

  // List of status types for this ledger class
  repeated LedgerClassStatusType status_types = 6;

  // List of bucket types for this ledger class
  repeated LedgerClassBucketType bucket_types = 7;
}

// LedgerClassEntryType defines the types of possible ledger entries for a given asset class. These type codes allow
// for minimal data storage while providing a human readable description of the entry type.
message LedgerClassEntryType {
  // Unique ID for the entry type (eg. 1, 2, 3, etc.)
  int32 id = 1;

  // Code for the entry type (eg. "DISBURSEMENT", "PAYMENT", "ADJUSTMENT", "INTEREST", "FEE", "OTHER")
  string code = 2;

  // Description of the entry type (eg. "Disbursement", "Payment", "Adjustment", "Interest", "Fee", "Other")
  string description = 3;
}

message LedgerClassStatusType {
  // Unique ID for the status type (eg. 1, 2, 3, etc.)
  int32 id = 1;

  // Code for the status type (eg. "IN_REPAYMENT", "IN_FORECLOSURE", "FORBEARANCE", "DEFERMENT", "BANKRUPTCY""CLOSED",
  // "CANCELLED", "SUSPENDED", "OTHER")
  string code = 2;

  // Description of the status type (eg. "In Repayment", "In Foreclosure", "Forbearance", "Deferment", "Bankruptcy",
  // "Closed", "Cancelled", "Suspended", "Other")
  string description = 3;
}

message LedgerKey {
  // Identifier for the nft that this ledger is linked to.
  // This could be a `x/metadata` scope id or an `x/nft` nft id.
  // In order to create a ledger for an nft, the nft class must be registered in the ledger module as a LedgerClass.
  string nft_id = 1;

  // Scope Specification ID or NFT Class ID
  string asset_class_id = 2;
}

// Ledger
message Ledger {
  LedgerKey key = 1;

  // Ledger class id for the ledger
  string ledger_class_id = 2;

  // Status of the ledger
  int32 status_type_id = 3;

  // Next payment date days since epoch
  int32 next_pmt_date = 4;

  // Next payment amount
  int64 next_pmt_amt = 5;

  // Interest rate
  int32 interest_rate = 6;

  // Maturity date days since epoch
  int32 maturity_date = 7;
}

// LedgerClassBucketType represents a bucket type for a ledger class
message LedgerClassBucketType {
  // Unique ID for the bucket type (eg. 1, 2, 3, etc.)
  int32 id = 1;

  // Code for the bucket type (eg. "PRINCIPAL", "INTEREST", "FEE", "OTHER")
  string code = 2;

  // Description of the bucket type (eg. "Principal", "Interest", "Fee", "Other")
  string description = 3;
}

// LedgerEntry
message LedgerEntry {
  // Correlation ID for tracking ledger entries with external systems (max 50 characters)
  string correlation_id = 1;

  // If this entry reverses another entry, the correlation id of the entry it reverses
  string reverses_correlation_id = 2;

  // If true, this entry is a void and should not be included in the ledger balance calculations
  bool is_void = 3;

  // The NFT address that this ledger entry pertains to
  // Sequence number of the ledger entry (less than 100)
  // This field is used to maintain the correct order of entries when multiple entries
  // share the same effective date. Entries are sorted first by effective date, then by sequence.
  uint32 sequence = 4;

  // The type of ledger entry specified by the LedgerClassEntryType.id
  int32 entry_type_id = 5;

  // Posted date days since epoch
  int32 posted_date = 7;

  // Effective date days since epoch
  int32 effective_date = 8;

  // Total amount of the ledger entry
  string total_amt = 9 [
    (cosmos_proto.scalar)  = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable)   = false
  ];

  // Applied amounts for each bucket
  repeated LedgerBucketAmount applied_amounts = 10;

  // Balances for each bucket
  repeated BucketBalance balance_amounts = 11;
}

message LedgerBucketAmount {
  // The bucket type specified by the LedgerClassBucketType.id
  int32 bucket_type_id = 1;

  // The amount applied to the bucket
  string applied_amt = 2 [
    (cosmos_proto.scalar)  = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable)   = false
  ];
}

// Balances represents the current balances for principal, interest, and other amounts
message Balances {
  repeated BucketBalance bucket_balances = 1;
}

message BucketBalance {
  // The bucket type specified by the LedgerClassBucketType.id
  int32 bucket_type_id = 1;

  // The balance of the bucket
  string balance_amt = 2 [
    (cosmos_proto.scalar)  = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable)   = false
  ];
}

// Used for conversion....
message Ledgers {
  repeated LedgerToEntries ledger_to_entries = 1;
}
message LedgerToEntries {
  string nft_id = 1;
  repeated LedgerEntry entries = 2;
}