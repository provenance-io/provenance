// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/attribute/v1/attribute.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AttributeType defines the type of the data stored in the attribute value
type AttributeType int32

const (
	// ATTRIBUTE_TYPE_UNSPECIFIED defines an unknown/invalid type
	AttributeType_Unspecified AttributeType = 0
	// ATTRIBUTE_TYPE_UUID defines an attribute value that contains a string value representation of a V4 uuid
	AttributeType_UUID AttributeType = 1
	// ATTRIBUTE_TYPE_JSON defines an attribute value that contains a byte string containing json data
	AttributeType_JSON AttributeType = 2
	// ATTRIBUTE_TYPE_STRING defines an attribute value that contains a generic string value
	AttributeType_String AttributeType = 3
	// ATTRIBUTE_TYPE_URI defines an attribute value that contains a URI
	AttributeType_Uri AttributeType = 4
	// ATTRIBUTE_TYPE_INT defines an attribute value that contains an integer (cast as int64)
	AttributeType_Int AttributeType = 5
	// ATTRIBUTE_TYPE_FLOAT defines an attribute value that contains a float
	AttributeType_Float AttributeType = 6
	// ATTRIBUTE_TYPE_PROTO defines an attribute value that contains a serialized proto value in bytes
	AttributeType_Proto AttributeType = 7
	// ATTRIBUTE_TYPE_BYTES defines an attribute value that contains an untyped array of bytes
	AttributeType_Bytes AttributeType = 8
)

var AttributeType_name = map[int32]string{
	0: "ATTRIBUTE_TYPE_UNSPECIFIED",
	1: "ATTRIBUTE_TYPE_UUID",
	2: "ATTRIBUTE_TYPE_JSON",
	3: "ATTRIBUTE_TYPE_STRING",
	4: "ATTRIBUTE_TYPE_URI",
	5: "ATTRIBUTE_TYPE_INT",
	6: "ATTRIBUTE_TYPE_FLOAT",
	7: "ATTRIBUTE_TYPE_PROTO",
	8: "ATTRIBUTE_TYPE_BYTES",
}

var AttributeType_value = map[string]int32{
	"ATTRIBUTE_TYPE_UNSPECIFIED": 0,
	"ATTRIBUTE_TYPE_UUID":        1,
	"ATTRIBUTE_TYPE_JSON":        2,
	"ATTRIBUTE_TYPE_STRING":      3,
	"ATTRIBUTE_TYPE_URI":         4,
	"ATTRIBUTE_TYPE_INT":         5,
	"ATTRIBUTE_TYPE_FLOAT":       6,
	"ATTRIBUTE_TYPE_PROTO":       7,
	"ATTRIBUTE_TYPE_BYTES":       8,
}

func (x AttributeType) String() string {
	return proto.EnumName(AttributeType_name, int32(x))
}

func (AttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_14fe7eb43c711f5e, []int{0}
}

// Params defines the set of params for the attribute module.
type Params struct {
	// maximum length of data to allow in an attribute value
	MaxValueLength uint32 `protobuf:"varint,1,opt,name=max_value_length,json=maxValueLength,proto3" json:"max_value_length,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_14fe7eb43c711f5e, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxValueLength() uint32 {
	if m != nil {
		return m.MaxValueLength
	}
	return 0
}

// Attribute holds a typed key/value structure for data associated with an account
type Attribute struct {
	// The attribute name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The attribute value.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The attribute value type.
	AttributeType AttributeType `protobuf:"varint,3,opt,name=attribute_type,json=attributeType,proto3,enum=provenance.attribute.v1.AttributeType" json:"attribute_type,omitempty"`
	// The address the attribute is bound to
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Attribute) Reset()      { *m = Attribute{} }
func (*Attribute) ProtoMessage() {}
func (*Attribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_14fe7eb43c711f5e, []int{1}
}
func (m *Attribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attribute.Merge(m, src)
}
func (m *Attribute) XXX_Size() int {
	return m.Size()
}
func (m *Attribute) XXX_DiscardUnknown() {
	xxx_messageInfo_Attribute.DiscardUnknown(m)
}

var xxx_messageInfo_Attribute proto.InternalMessageInfo

func (m *Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Attribute) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Attribute) GetAttributeType() AttributeType {
	if m != nil {
		return m.AttributeType
	}
	return AttributeType_Unspecified
}

func (m *Attribute) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("provenance.attribute.v1.AttributeType", AttributeType_name, AttributeType_value)
	proto.RegisterType((*Params)(nil), "provenance.attribute.v1.Params")
	proto.RegisterType((*Attribute)(nil), "provenance.attribute.v1.Attribute")
}

func init() {
	proto.RegisterFile("provenance/attribute/v1/attribute.proto", fileDescriptor_14fe7eb43c711f5e)
}

var fileDescriptor_14fe7eb43c711f5e = []byte{
	// 478 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x4f, 0x8b, 0xd3, 0x40,
	0x18, 0xc6, 0x3b, 0xfd, 0xbb, 0x1d, 0x6d, 0x1d, 0xc6, 0x8a, 0x25, 0x87, 0x6c, 0x5c, 0x51, 0x8b,
	0x60, 0xc3, 0x2a, 0x82, 0x78, 0x6b, 0xdd, 0x54, 0x22, 0x6b, 0x1b, 0x92, 0x89, 0xb0, 0x5e, 0xc2,
	0xb4, 0x1d, 0xb3, 0x81, 0xe6, 0x0f, 0xc9, 0xb4, 0xb4, 0x5f, 0x21, 0x27, 0x8f, 0x5e, 0x02, 0x1e,
	0xfc, 0x30, 0x1e, 0xf7, 0xe8, 0x49, 0xa4, 0xfd, 0x22, 0x92, 0x84, 0xdd, 0xd6, 0xda, 0xbd, 0x3d,
	0xcf, 0xe4, 0xf7, 0xbe, 0xcf, 0x0b, 0x79, 0xe0, 0xb3, 0x20, 0xf4, 0x17, 0xcc, 0xa3, 0xde, 0x84,
	0xc9, 0x94, 0xf3, 0xd0, 0x19, 0xcf, 0x39, 0x93, 0x17, 0xa7, 0x5b, 0xd3, 0x0d, 0x42, 0x9f, 0xfb,
	0xf8, 0xe1, 0x16, 0xec, 0x6e, 0xbf, 0x2d, 0x4e, 0x85, 0x96, 0xed, 0xdb, 0x7e, 0xc6, 0xc8, 0xa9,
	0xca, 0xf1, 0x93, 0x37, 0xb0, 0xaa, 0xd1, 0x90, 0xba, 0x11, 0xee, 0x40, 0xe4, 0xd2, 0xa5, 0xb5,
	0xa0, 0xb3, 0x39, 0xb3, 0x66, 0xcc, 0xb3, 0xf9, 0x65, 0x1b, 0x48, 0xa0, 0xd3, 0xd0, 0x9b, 0x2e,
	0x5d, 0x7e, 0x4a, 0x9f, 0xcf, 0xb3, 0xd7, 0xb7, 0xe5, 0x6f, 0xdf, 0x8f, 0x0b, 0x27, 0x3f, 0x00,
	0xac, 0xf7, 0xae, 0x03, 0x30, 0x86, 0x65, 0x8f, 0xba, 0x2c, 0x9b, 0xa8, 0xeb, 0x99, 0xc6, 0x2d,
	0x58, 0xc9, 0xb6, 0xb5, 0x8b, 0x12, 0xe8, 0xdc, 0xd5, 0x73, 0x83, 0x3f, 0xc2, 0xe6, 0xcd, 0x5d,
	0x16, 0x5f, 0x05, 0xac, 0x5d, 0x92, 0x40, 0xa7, 0xf9, 0xf2, 0x69, 0xf7, 0x96, 0xcb, 0xbb, 0x37,
	0x29, 0x64, 0x15, 0x30, 0xbd, 0x41, 0x77, 0x2d, 0x6e, 0xc3, 0x1a, 0x9d, 0x4e, 0x43, 0x16, 0x45,
	0xed, 0x72, 0x96, 0x7d, 0x6d, 0xf3, 0x33, 0x9f, 0xff, 0x2e, 0xc2, 0xc6, 0x3f, 0x0b, 0xb0, 0x0c,
	0x85, 0x1e, 0x21, 0xba, 0xda, 0x37, 0x89, 0x62, 0x91, 0x0b, 0x4d, 0xb1, 0xcc, 0xa1, 0xa1, 0x29,
	0xef, 0xd4, 0x81, 0xaa, 0x9c, 0xa1, 0x82, 0x70, 0x2f, 0x4e, 0xa4, 0x3b, 0xa6, 0x17, 0x05, 0x6c,
	0xe2, 0x7c, 0x71, 0xd8, 0x14, 0x3f, 0x82, 0xf7, 0xf7, 0x07, 0x4c, 0xf5, 0x0c, 0x01, 0xe1, 0x28,
	0x4e, 0xa4, 0x72, 0xaa, 0x0f, 0x20, 0x1f, 0x8c, 0xd1, 0x10, 0x15, 0x73, 0x24, 0xd5, 0xf8, 0x09,
	0x7c, 0xb0, 0x87, 0x18, 0x44, 0x57, 0x87, 0xef, 0x51, 0x49, 0x80, 0x71, 0x22, 0x55, 0x0d, 0x1e,
	0x3a, 0x9e, 0x8d, 0x8f, 0x21, 0xde, 0x0f, 0xd3, 0x55, 0x54, 0x16, 0x6a, 0x71, 0x22, 0x95, 0xcc,
	0xd0, 0x39, 0x00, 0xa8, 0x43, 0x82, 0x2a, 0x39, 0xa0, 0x7a, 0x1c, 0x3f, 0x86, 0xad, 0x3d, 0x60,
	0x70, 0x3e, 0xea, 0x11, 0x54, 0x15, 0xea, 0x71, 0x22, 0x55, 0x06, 0x33, 0x9f, 0x1e, 0x82, 0x34,
	0x7d, 0x44, 0x46, 0xa8, 0x96, 0x43, 0x5a, 0xd6, 0xa5, 0xff, 0xa1, 0xfe, 0x05, 0x51, 0x0c, 0x74,
	0x94, 0x43, 0xfd, 0x15, 0x67, 0x51, 0xdf, 0xfd, 0xb9, 0x16, 0xc1, 0xd5, 0x5a, 0x04, 0x7f, 0xd6,
	0x22, 0xf8, 0xba, 0x11, 0x0b, 0x57, 0x1b, 0xb1, 0xf0, 0x6b, 0x23, 0x16, 0xa0, 0xe0, 0xf8, 0xb7,
	0xfd, 0x53, 0x0d, 0x7c, 0x7e, 0x6d, 0x3b, 0xfc, 0x72, 0x3e, 0xee, 0x4e, 0x7c, 0x57, 0xde, 0x52,
	0x2f, 0x1c, 0x7f, 0xc7, 0xc9, 0xcb, 0x9d, 0xb2, 0xa7, 0x5d, 0x89, 0xc6, 0xd5, 0xac, 0xb7, 0xaf,
	0xfe, 0x06, 0x00, 0x00, 0xff, 0xff, 0x53, 0xcb, 0xdf, 0xdd, 0x11, 0x03, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValueLength != 0 {
		i = encodeVarintAttribute(dAtA, i, uint64(m.MaxValueLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Attribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if m.AttributeType != 0 {
		i = encodeVarintAttribute(dAtA, i, uint64(m.AttributeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAttribute(dAtA []byte, offset int, v uint64) int {
	offset -= sovAttribute(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxValueLength != 0 {
		n += 1 + sovAttribute(uint64(m.MaxValueLength))
	}
	return n
}

func (m *Attribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.AttributeType != 0 {
		n += 1 + sovAttribute(uint64(m.AttributeType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func sovAttribute(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAttribute(x uint64) (n int) {
	return sovAttribute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValueLength", wireType)
			}
			m.MaxValueLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValueLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttribute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAttribute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeType", wireType)
			}
			m.AttributeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeType |= AttributeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttribute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAttribute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAttribute
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAttribute
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAttribute
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAttribute        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAttribute          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAttribute = fmt.Errorf("proto: unexpected end of group")
)
