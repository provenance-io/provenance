// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/reward/v1/reward.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// State is the state of the reward program
type RewardProgram_State int32

const (
	// undefined program state
	RewardProgram_STATE_UNSPECIFIED RewardProgram_State = 0
	// pending state of reward program
	RewardProgram_STATE_PENDING RewardProgram_State = 1
	// started state of reward program
	RewardProgram_STATE_STARTED RewardProgram_State = 2
	// finished state of reward program
	RewardProgram_STATE_FINISHED RewardProgram_State = 3
	// expired state of reward program
	RewardProgram_STATE_EXPIRED RewardProgram_State = 4
)

var RewardProgram_State_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "STATE_PENDING",
	2: "STATE_STARTED",
	3: "STATE_FINISHED",
	4: "STATE_EXPIRED",
}

var RewardProgram_State_value = map[string]int32{
	"STATE_UNSPECIFIED": 0,
	"STATE_PENDING":     1,
	"STATE_STARTED":     2,
	"STATE_FINISHED":    3,
	"STATE_EXPIRED":     4,
}

func (x RewardProgram_State) String() string {
	return proto.EnumName(RewardProgram_State_name, int32(x))
}

func (RewardProgram_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{0, 0}
}

// ClaimStatus is the state a claim is in
type RewardAccountState_ClaimStatus int32

const (
	// undefined state
	RewardAccountState_CLAIM_STATUS_UNSPECIFIED RewardAccountState_ClaimStatus = 0
	// unclaimable status
	RewardAccountState_CLAIM_STATUS_UNCLAIMABLE RewardAccountState_ClaimStatus = 1
	// unclaimable claimable
	RewardAccountState_CLAIM_STATUS_CLAIMABLE RewardAccountState_ClaimStatus = 2
	// unclaimable claimed
	RewardAccountState_CLAIM_STATUS_CLAIMED RewardAccountState_ClaimStatus = 3
	// unclaimable expired
	RewardAccountState_CLAIM_STATUS_EXPIRED RewardAccountState_ClaimStatus = 4
)

var RewardAccountState_ClaimStatus_name = map[int32]string{
	0: "CLAIM_STATUS_UNSPECIFIED",
	1: "CLAIM_STATUS_UNCLAIMABLE",
	2: "CLAIM_STATUS_CLAIMABLE",
	3: "CLAIM_STATUS_CLAIMED",
	4: "CLAIM_STATUS_EXPIRED",
}

var RewardAccountState_ClaimStatus_value = map[string]int32{
	"CLAIM_STATUS_UNSPECIFIED": 0,
	"CLAIM_STATUS_UNCLAIMABLE": 1,
	"CLAIM_STATUS_CLAIMABLE":   2,
	"CLAIM_STATUS_CLAIMED":     3,
	"CLAIM_STATUS_EXPIRED":     4,
}

func (x RewardAccountState_ClaimStatus) String() string {
	return proto.EnumName(RewardAccountState_ClaimStatus_name, int32(x))
}

func (RewardAccountState_ClaimStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{2, 0}
}

// RewardProgram
type RewardProgram struct {
	// An integer to uniquely identify the reward program.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name to help identify the Reward Program.(MaxTitleLength=140)
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Short summary describing the Reward Program.(MaxDescriptionLength=10000)
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// address that provides funds for the total reward pool.
	DistributeFromAddress string `protobuf:"bytes,4,opt,name=distribute_from_address,json=distributeFromAddress,proto3" json:"distribute_from_address,omitempty"`
	// The total amount of funding given to the RewardProgram.
	TotalRewardPool types.Coin `protobuf:"bytes,5,opt,name=total_reward_pool,json=totalRewardPool,proto3" json:"total_reward_pool"`
	// The remaining funds available to distribute after n claim periods have passed.
	RemainingPoolBalance types.Coin `protobuf:"bytes,6,opt,name=remaining_pool_balance,json=remainingPoolBalance,proto3" json:"remaining_pool_balance"`
	// The total amount of all funds claimed by participants for all past claim periods.
	ClaimedAmount types.Coin `protobuf:"bytes,7,opt,name=claimed_amount,json=claimedAmount,proto3" json:"claimed_amount"`
	// Maximum reward per claim period per address.
	MaxRewardByAddress types.Coin `protobuf:"bytes,8,opt,name=max_reward_by_address,json=maxRewardByAddress,proto3" json:"max_reward_by_address"`
	// Minimum amount of coins for a program to rollover.
	MinimumRolloverAmount types.Coin `protobuf:"bytes,9,opt,name=minimum_rollover_amount,json=minimumRolloverAmount,proto3" json:"minimum_rollover_amount"`
	// Number of seconds that a claim period lasts.
	ClaimPeriodSeconds uint64 `protobuf:"varint,10,opt,name=claim_period_seconds,json=claimPeriodSeconds,proto3" json:"claim_period_seconds,omitempty"`
	// Time that a RewardProgram should start and switch to STARTED state.
	ProgramStartTime time.Time `protobuf:"bytes,11,opt,name=program_start_time,json=programStartTime,proto3,stdtime" json:"program_start_time"`
	// Time that a RewardProgram is expected to end, based on data when it was setup.
	ExpectedProgramEndTime time.Time `protobuf:"bytes,12,opt,name=expected_program_end_time,json=expectedProgramEndTime,proto3,stdtime" json:"expected_program_end_time"`
	// Time that a RewardProgram MUST end.
	ProgramEndTimeMax time.Time `protobuf:"bytes,13,opt,name=program_end_time_max,json=programEndTimeMax,proto3,stdtime" json:"program_end_time_max"`
	// Used internally to calculate and track the current claim period's ending time.
	ClaimPeriodEndTime time.Time `protobuf:"bytes,14,opt,name=claim_period_end_time,json=claimPeriodEndTime,proto3,stdtime" json:"claim_period_end_time"`
	// Time the RewardProgram switched to FINISHED state. Initially set as empty.
	ActualProgramEndTime time.Time `protobuf:"bytes,15,opt,name=actual_program_end_time,json=actualProgramEndTime,proto3,stdtime" json:"actual_program_end_time"`
	// Number of claim periods this program will run for.
	ClaimPeriods uint64 `protobuf:"varint,16,opt,name=claim_periods,json=claimPeriods,proto3" json:"claim_periods,omitempty"`
	// Current claim period of the RewardProgram. Uses 1-based indexing.
	CurrentClaimPeriod uint64 `protobuf:"varint,17,opt,name=current_claim_period,json=currentClaimPeriod,proto3" json:"current_claim_period,omitempty"`
	// maximum number of claim periods a reward program can rollover.
	MaxRolloverClaimPeriods uint64 `protobuf:"varint,18,opt,name=max_rollover_claim_periods,json=maxRolloverClaimPeriods,proto3" json:"max_rollover_claim_periods,omitempty"`
	// Current state of the RewardProgram.
	State RewardProgram_State `protobuf:"varint,19,opt,name=state,proto3,enum=provenance.reward.v1.RewardProgram_State" json:"state,omitempty"`
	// Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED
	// state.
	ExpirationOffset uint64 `protobuf:"varint,20,opt,name=expiration_offset,json=expirationOffset,proto3" json:"expiration_offset,omitempty"`
	// Actions that count towards the reward.
	QualifyingActions []QualifyingAction `protobuf:"bytes,21,rep,name=qualifying_actions,json=qualifyingActions,proto3" json:"qualifying_actions"`
}

func (m *RewardProgram) Reset()         { *m = RewardProgram{} }
func (m *RewardProgram) String() string { return proto.CompactTextString(m) }
func (*RewardProgram) ProtoMessage()    {}
func (*RewardProgram) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{0}
}
func (m *RewardProgram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardProgram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardProgram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardProgram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardProgram.Merge(m, src)
}
func (m *RewardProgram) XXX_Size() int {
	return m.Size()
}
func (m *RewardProgram) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardProgram.DiscardUnknown(m)
}

var xxx_messageInfo_RewardProgram proto.InternalMessageInfo

func (m *RewardProgram) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RewardProgram) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RewardProgram) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RewardProgram) GetDistributeFromAddress() string {
	if m != nil {
		return m.DistributeFromAddress
	}
	return ""
}

func (m *RewardProgram) GetTotalRewardPool() types.Coin {
	if m != nil {
		return m.TotalRewardPool
	}
	return types.Coin{}
}

func (m *RewardProgram) GetRemainingPoolBalance() types.Coin {
	if m != nil {
		return m.RemainingPoolBalance
	}
	return types.Coin{}
}

func (m *RewardProgram) GetClaimedAmount() types.Coin {
	if m != nil {
		return m.ClaimedAmount
	}
	return types.Coin{}
}

func (m *RewardProgram) GetMaxRewardByAddress() types.Coin {
	if m != nil {
		return m.MaxRewardByAddress
	}
	return types.Coin{}
}

func (m *RewardProgram) GetMinimumRolloverAmount() types.Coin {
	if m != nil {
		return m.MinimumRolloverAmount
	}
	return types.Coin{}
}

func (m *RewardProgram) GetClaimPeriodSeconds() uint64 {
	if m != nil {
		return m.ClaimPeriodSeconds
	}
	return 0
}

func (m *RewardProgram) GetProgramStartTime() time.Time {
	if m != nil {
		return m.ProgramStartTime
	}
	return time.Time{}
}

func (m *RewardProgram) GetExpectedProgramEndTime() time.Time {
	if m != nil {
		return m.ExpectedProgramEndTime
	}
	return time.Time{}
}

func (m *RewardProgram) GetProgramEndTimeMax() time.Time {
	if m != nil {
		return m.ProgramEndTimeMax
	}
	return time.Time{}
}

func (m *RewardProgram) GetClaimPeriodEndTime() time.Time {
	if m != nil {
		return m.ClaimPeriodEndTime
	}
	return time.Time{}
}

func (m *RewardProgram) GetActualProgramEndTime() time.Time {
	if m != nil {
		return m.ActualProgramEndTime
	}
	return time.Time{}
}

func (m *RewardProgram) GetClaimPeriods() uint64 {
	if m != nil {
		return m.ClaimPeriods
	}
	return 0
}

func (m *RewardProgram) GetCurrentClaimPeriod() uint64 {
	if m != nil {
		return m.CurrentClaimPeriod
	}
	return 0
}

func (m *RewardProgram) GetMaxRolloverClaimPeriods() uint64 {
	if m != nil {
		return m.MaxRolloverClaimPeriods
	}
	return 0
}

func (m *RewardProgram) GetState() RewardProgram_State {
	if m != nil {
		return m.State
	}
	return RewardProgram_STATE_UNSPECIFIED
}

func (m *RewardProgram) GetExpirationOffset() uint64 {
	if m != nil {
		return m.ExpirationOffset
	}
	return 0
}

func (m *RewardProgram) GetQualifyingActions() []QualifyingAction {
	if m != nil {
		return m.QualifyingActions
	}
	return nil
}

// ClaimPeriodRewardDistribution, this is updated at the end of every claim period.
type ClaimPeriodRewardDistribution struct {
	// The claim period id.
	ClaimPeriodId uint64 `protobuf:"varint,1,opt,name=claim_period_id,json=claimPeriodId,proto3" json:"claim_period_id,omitempty"`
	// The id of the reward program that this reward belongs to.
	RewardProgramId uint64 `protobuf:"varint,2,opt,name=reward_program_id,json=rewardProgramId,proto3" json:"reward_program_id,omitempty"`
	// The sum of all the granted rewards for this claim period.
	TotalRewardsPoolForClaimPeriod types.Coin `protobuf:"bytes,3,opt,name=total_rewards_pool_for_claim_period,json=totalRewardsPoolForClaimPeriod,proto3" json:"total_rewards_pool_for_claim_period"`
	// The final allocated rewards for this claim period.
	RewardsPool types.Coin `protobuf:"bytes,4,opt,name=rewards_pool,json=rewardsPool,proto3" json:"rewards_pool"`
	// The total number of granted shares for this claim period.
	TotalShares int64 `protobuf:"varint,5,opt,name=total_shares,json=totalShares,proto3" json:"total_shares,omitempty"`
	// A flag representing if the claim period for this reward has ended.
	ClaimPeriodEnded bool `protobuf:"varint,6,opt,name=claim_period_ended,json=claimPeriodEnded,proto3" json:"claim_period_ended,omitempty"`
}

func (m *ClaimPeriodRewardDistribution) Reset()         { *m = ClaimPeriodRewardDistribution{} }
func (m *ClaimPeriodRewardDistribution) String() string { return proto.CompactTextString(m) }
func (*ClaimPeriodRewardDistribution) ProtoMessage()    {}
func (*ClaimPeriodRewardDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{1}
}
func (m *ClaimPeriodRewardDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimPeriodRewardDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimPeriodRewardDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimPeriodRewardDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimPeriodRewardDistribution.Merge(m, src)
}
func (m *ClaimPeriodRewardDistribution) XXX_Size() int {
	return m.Size()
}
func (m *ClaimPeriodRewardDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimPeriodRewardDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimPeriodRewardDistribution proto.InternalMessageInfo

func (m *ClaimPeriodRewardDistribution) GetClaimPeriodId() uint64 {
	if m != nil {
		return m.ClaimPeriodId
	}
	return 0
}

func (m *ClaimPeriodRewardDistribution) GetRewardProgramId() uint64 {
	if m != nil {
		return m.RewardProgramId
	}
	return 0
}

func (m *ClaimPeriodRewardDistribution) GetTotalRewardsPoolForClaimPeriod() types.Coin {
	if m != nil {
		return m.TotalRewardsPoolForClaimPeriod
	}
	return types.Coin{}
}

func (m *ClaimPeriodRewardDistribution) GetRewardsPool() types.Coin {
	if m != nil {
		return m.RewardsPool
	}
	return types.Coin{}
}

func (m *ClaimPeriodRewardDistribution) GetTotalShares() int64 {
	if m != nil {
		return m.TotalShares
	}
	return 0
}

func (m *ClaimPeriodRewardDistribution) GetClaimPeriodEnded() bool {
	if m != nil {
		return m.ClaimPeriodEnded
	}
	return false
}

// RewardAccountState contains state at the claim period level for a specific address.
type RewardAccountState struct {
	// The id of the reward program that this share belongs to.
	RewardProgramId uint64 `protobuf:"varint,1,opt,name=reward_program_id,json=rewardProgramId,proto3" json:"reward_program_id,omitempty"`
	// The id of the claim period that the share belongs to.
	ClaimPeriodId uint64 `protobuf:"varint,2,opt,name=claim_period_id,json=claimPeriodId,proto3" json:"claim_period_id,omitempty"`
	// Owner of the reward account state.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// The number of actions performed by this account, mapped by action type.
	ActionCounter []*ActionCounter `protobuf:"bytes,4,rep,name=action_counter,json=actionCounter,proto3" json:"action_counter,omitempty"`
	// The amount of granted shares for the address in the reward program's claim period.
	SharesEarned uint64 `protobuf:"varint,5,opt,name=shares_earned,json=sharesEarned,proto3" json:"shares_earned,omitempty"`
	// The status of the claim.
	ClaimStatus RewardAccountState_ClaimStatus `protobuf:"varint,6,opt,name=claim_status,json=claimStatus,proto3,enum=provenance.reward.v1.RewardAccountState_ClaimStatus" json:"claim_status,omitempty"`
}

func (m *RewardAccountState) Reset()         { *m = RewardAccountState{} }
func (m *RewardAccountState) String() string { return proto.CompactTextString(m) }
func (*RewardAccountState) ProtoMessage()    {}
func (*RewardAccountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{2}
}
func (m *RewardAccountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardAccountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardAccountState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardAccountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardAccountState.Merge(m, src)
}
func (m *RewardAccountState) XXX_Size() int {
	return m.Size()
}
func (m *RewardAccountState) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardAccountState.DiscardUnknown(m)
}

var xxx_messageInfo_RewardAccountState proto.InternalMessageInfo

func (m *RewardAccountState) GetRewardProgramId() uint64 {
	if m != nil {
		return m.RewardProgramId
	}
	return 0
}

func (m *RewardAccountState) GetClaimPeriodId() uint64 {
	if m != nil {
		return m.ClaimPeriodId
	}
	return 0
}

func (m *RewardAccountState) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RewardAccountState) GetActionCounter() []*ActionCounter {
	if m != nil {
		return m.ActionCounter
	}
	return nil
}

func (m *RewardAccountState) GetSharesEarned() uint64 {
	if m != nil {
		return m.SharesEarned
	}
	return 0
}

func (m *RewardAccountState) GetClaimStatus() RewardAccountState_ClaimStatus {
	if m != nil {
		return m.ClaimStatus
	}
	return RewardAccountState_CLAIM_STATUS_UNSPECIFIED
}

// QualifyingAction can be one of many action types.
type QualifyingAction struct {
	// type of action to process
	//
	// Types that are valid to be assigned to Type:
	//
	//	*QualifyingAction_Delegate
	//	*QualifyingAction_Transfer
	//	*QualifyingAction_Vote
	Type isQualifyingAction_Type `protobuf_oneof:"type"`
}

func (m *QualifyingAction) Reset()         { *m = QualifyingAction{} }
func (m *QualifyingAction) String() string { return proto.CompactTextString(m) }
func (*QualifyingAction) ProtoMessage()    {}
func (*QualifyingAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{3}
}
func (m *QualifyingAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QualifyingAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QualifyingAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QualifyingAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QualifyingAction.Merge(m, src)
}
func (m *QualifyingAction) XXX_Size() int {
	return m.Size()
}
func (m *QualifyingAction) XXX_DiscardUnknown() {
	xxx_messageInfo_QualifyingAction.DiscardUnknown(m)
}

var xxx_messageInfo_QualifyingAction proto.InternalMessageInfo

type isQualifyingAction_Type interface {
	isQualifyingAction_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QualifyingAction_Delegate struct {
	Delegate *ActionDelegate `protobuf:"bytes,1,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type QualifyingAction_Transfer struct {
	Transfer *ActionTransfer `protobuf:"bytes,2,opt,name=transfer,proto3,oneof" json:"transfer,omitempty"`
}
type QualifyingAction_Vote struct {
	Vote *ActionVote `protobuf:"bytes,3,opt,name=vote,proto3,oneof" json:"vote,omitempty"`
}

func (*QualifyingAction_Delegate) isQualifyingAction_Type() {}
func (*QualifyingAction_Transfer) isQualifyingAction_Type() {}
func (*QualifyingAction_Vote) isQualifyingAction_Type()     {}

func (m *QualifyingAction) GetType() isQualifyingAction_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *QualifyingAction) GetDelegate() *ActionDelegate {
	if x, ok := m.GetType().(*QualifyingAction_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *QualifyingAction) GetTransfer() *ActionTransfer {
	if x, ok := m.GetType().(*QualifyingAction_Transfer); ok {
		return x.Transfer
	}
	return nil
}

func (m *QualifyingAction) GetVote() *ActionVote {
	if x, ok := m.GetType().(*QualifyingAction_Vote); ok {
		return x.Vote
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QualifyingAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QualifyingAction_Delegate)(nil),
		(*QualifyingAction_Transfer)(nil),
		(*QualifyingAction_Vote)(nil),
	}
}

// QualifyingActions contains a list of QualifyingActions.
type QualifyingActions struct {
	// The actions that count towards the reward.
	QualifyingActions []QualifyingAction `protobuf:"bytes,1,rep,name=qualifying_actions,json=qualifyingActions,proto3" json:"qualifying_actions"`
}

func (m *QualifyingActions) Reset()         { *m = QualifyingActions{} }
func (m *QualifyingActions) String() string { return proto.CompactTextString(m) }
func (*QualifyingActions) ProtoMessage()    {}
func (*QualifyingActions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{4}
}
func (m *QualifyingActions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QualifyingActions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QualifyingActions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QualifyingActions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QualifyingActions.Merge(m, src)
}
func (m *QualifyingActions) XXX_Size() int {
	return m.Size()
}
func (m *QualifyingActions) XXX_DiscardUnknown() {
	xxx_messageInfo_QualifyingActions.DiscardUnknown(m)
}

var xxx_messageInfo_QualifyingActions proto.InternalMessageInfo

func (m *QualifyingActions) GetQualifyingActions() []QualifyingAction {
	if m != nil {
		return m.QualifyingActions
	}
	return nil
}

// ActionDelegate represents the delegate action and its required eligibility criteria.
type ActionDelegate struct {
	// Minimum number of successful delegates.
	MinimumActions uint64 `protobuf:"varint,1,opt,name=minimum_actions,json=minimumActions,proto3" json:"minimum_actions,omitempty"`
	// Maximum number of successful delegates.
	MaximumActions uint64 `protobuf:"varint,2,opt,name=maximum_actions,json=maximumActions,proto3" json:"maximum_actions,omitempty"`
	// Minimum amount that the user must have currently delegated on the validator.
	MinimumDelegationAmount *types.Coin `protobuf:"bytes,3,opt,name=minimum_delegation_amount,json=minimumDelegationAmount,proto3" json:"minimum_delegation_amount,omitempty"`
	// Maximum amount that the user must have currently delegated on the validator.
	MaximumDelegationAmount *types.Coin `protobuf:"bytes,4,opt,name=maximum_delegation_amount,json=maximumDelegationAmount,proto3" json:"maximum_delegation_amount,omitempty"`
	// Minimum percentile that can be below the validator's power ranking.
	MinimumActiveStakePercentile cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=minimum_active_stake_percentile,json=minimumActiveStakePercentile,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"minimum_active_stake_percentile"`
	// Maximum percentile that can be below the validator's power ranking.
	MaximumActiveStakePercentile cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=maximum_active_stake_percentile,json=maximumActiveStakePercentile,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maximum_active_stake_percentile"`
}

func (m *ActionDelegate) Reset()         { *m = ActionDelegate{} }
func (m *ActionDelegate) String() string { return proto.CompactTextString(m) }
func (*ActionDelegate) ProtoMessage()    {}
func (*ActionDelegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{5}
}
func (m *ActionDelegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDelegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDelegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDelegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDelegate.Merge(m, src)
}
func (m *ActionDelegate) XXX_Size() int {
	return m.Size()
}
func (m *ActionDelegate) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDelegate.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDelegate proto.InternalMessageInfo

func (m *ActionDelegate) GetMinimumActions() uint64 {
	if m != nil {
		return m.MinimumActions
	}
	return 0
}

func (m *ActionDelegate) GetMaximumActions() uint64 {
	if m != nil {
		return m.MaximumActions
	}
	return 0
}

func (m *ActionDelegate) GetMinimumDelegationAmount() *types.Coin {
	if m != nil {
		return m.MinimumDelegationAmount
	}
	return nil
}

func (m *ActionDelegate) GetMaximumDelegationAmount() *types.Coin {
	if m != nil {
		return m.MaximumDelegationAmount
	}
	return nil
}

// ActionTransfer represents the transfer action and its required eligibility criteria.
type ActionTransfer struct {
	// Minimum number of successful transfers.
	MinimumActions uint64 `protobuf:"varint,1,opt,name=minimum_actions,json=minimumActions,proto3" json:"minimum_actions,omitempty"`
	// Maximum number of successful transfers.
	MaximumActions uint64 `protobuf:"varint,2,opt,name=maximum_actions,json=maximumActions,proto3" json:"maximum_actions,omitempty"`
	// Minimum delegation amount the account must have across all validators, for the transfer action to be counted.
	MinimumDelegationAmount types.Coin `protobuf:"bytes,3,opt,name=minimum_delegation_amount,json=minimumDelegationAmount,proto3" json:"minimum_delegation_amount"`
}

func (m *ActionTransfer) Reset()         { *m = ActionTransfer{} }
func (m *ActionTransfer) String() string { return proto.CompactTextString(m) }
func (*ActionTransfer) ProtoMessage()    {}
func (*ActionTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{6}
}
func (m *ActionTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionTransfer.Merge(m, src)
}
func (m *ActionTransfer) XXX_Size() int {
	return m.Size()
}
func (m *ActionTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_ActionTransfer proto.InternalMessageInfo

func (m *ActionTransfer) GetMinimumActions() uint64 {
	if m != nil {
		return m.MinimumActions
	}
	return 0
}

func (m *ActionTransfer) GetMaximumActions() uint64 {
	if m != nil {
		return m.MaximumActions
	}
	return 0
}

func (m *ActionTransfer) GetMinimumDelegationAmount() types.Coin {
	if m != nil {
		return m.MinimumDelegationAmount
	}
	return types.Coin{}
}

// ActionVote represents the voting action and its required eligibility criteria.
type ActionVote struct {
	// Minimum number of successful votes.
	MinimumActions uint64 `protobuf:"varint,1,opt,name=minimum_actions,json=minimumActions,proto3" json:"minimum_actions,omitempty"`
	// Maximum number of successful votes.
	MaximumActions uint64 `protobuf:"varint,2,opt,name=maximum_actions,json=maximumActions,proto3" json:"maximum_actions,omitempty"`
	// Minimum delegation amount the account must have across all validators, for the vote action to be counted.
	MinimumDelegationAmount types.Coin `protobuf:"bytes,3,opt,name=minimum_delegation_amount,json=minimumDelegationAmount,proto3" json:"minimum_delegation_amount"`
	// Positive multiplier that is applied to the shares awarded by the vote action when conditions
	// are met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same
	// as one
	ValidatorMultiplier uint64 `protobuf:"varint,4,opt,name=validator_multiplier,json=validatorMultiplier,proto3" json:"validator_multiplier,omitempty"`
}

func (m *ActionVote) Reset()         { *m = ActionVote{} }
func (m *ActionVote) String() string { return proto.CompactTextString(m) }
func (*ActionVote) ProtoMessage()    {}
func (*ActionVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{7}
}
func (m *ActionVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionVote.Merge(m, src)
}
func (m *ActionVote) XXX_Size() int {
	return m.Size()
}
func (m *ActionVote) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionVote.DiscardUnknown(m)
}

var xxx_messageInfo_ActionVote proto.InternalMessageInfo

func (m *ActionVote) GetMinimumActions() uint64 {
	if m != nil {
		return m.MinimumActions
	}
	return 0
}

func (m *ActionVote) GetMaximumActions() uint64 {
	if m != nil {
		return m.MaximumActions
	}
	return 0
}

func (m *ActionVote) GetMinimumDelegationAmount() types.Coin {
	if m != nil {
		return m.MinimumDelegationAmount
	}
	return types.Coin{}
}

func (m *ActionVote) GetValidatorMultiplier() uint64 {
	if m != nil {
		return m.ValidatorMultiplier
	}
	return 0
}

// ActionCounter is a key-value pair that maps action type to the number of times it was performed.
type ActionCounter struct {
	// The type of action performed.
	ActionType string `protobuf:"bytes,1,opt,name=action_type,json=actionType,proto3" json:"action_type,omitempty"`
	// The number of times this action has been performed
	NumberOfActions uint64 `protobuf:"varint,2,opt,name=number_of_actions,json=numberOfActions,proto3" json:"number_of_actions,omitempty"`
}

func (m *ActionCounter) Reset()         { *m = ActionCounter{} }
func (m *ActionCounter) String() string { return proto.CompactTextString(m) }
func (*ActionCounter) ProtoMessage()    {}
func (*ActionCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3894741a216575, []int{8}
}
func (m *ActionCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCounter.Merge(m, src)
}
func (m *ActionCounter) XXX_Size() int {
	return m.Size()
}
func (m *ActionCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCounter.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCounter proto.InternalMessageInfo

func (m *ActionCounter) GetActionType() string {
	if m != nil {
		return m.ActionType
	}
	return ""
}

func (m *ActionCounter) GetNumberOfActions() uint64 {
	if m != nil {
		return m.NumberOfActions
	}
	return 0
}

func init() {
	proto.RegisterEnum("provenance.reward.v1.RewardProgram_State", RewardProgram_State_name, RewardProgram_State_value)
	proto.RegisterEnum("provenance.reward.v1.RewardAccountState_ClaimStatus", RewardAccountState_ClaimStatus_name, RewardAccountState_ClaimStatus_value)
	proto.RegisterType((*RewardProgram)(nil), "provenance.reward.v1.RewardProgram")
	proto.RegisterType((*ClaimPeriodRewardDistribution)(nil), "provenance.reward.v1.ClaimPeriodRewardDistribution")
	proto.RegisterType((*RewardAccountState)(nil), "provenance.reward.v1.RewardAccountState")
	proto.RegisterType((*QualifyingAction)(nil), "provenance.reward.v1.QualifyingAction")
	proto.RegisterType((*QualifyingActions)(nil), "provenance.reward.v1.QualifyingActions")
	proto.RegisterType((*ActionDelegate)(nil), "provenance.reward.v1.ActionDelegate")
	proto.RegisterType((*ActionTransfer)(nil), "provenance.reward.v1.ActionTransfer")
	proto.RegisterType((*ActionVote)(nil), "provenance.reward.v1.ActionVote")
	proto.RegisterType((*ActionCounter)(nil), "provenance.reward.v1.ActionCounter")
}

func init() { proto.RegisterFile("provenance/reward/v1/reward.proto", fileDescriptor_0c3894741a216575) }

var fileDescriptor_0c3894741a216575 = []byte{
	// 1479 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4b, 0x73, 0x1b, 0x45,
	0x10, 0xf6, 0xda, 0xb2, 0x63, 0xb7, 0x2c, 0x59, 0x9a, 0xc8, 0xf1, 0xda, 0x04, 0xc9, 0x71, 0xa8,
	0x60, 0x1e, 0x91, 0xb0, 0xa1, 0x72, 0x80, 0x03, 0x25, 0x59, 0x32, 0x11, 0x24, 0x8e, 0x59, 0xc9,
	0x84, 0x22, 0x87, 0xad, 0xd1, 0xee, 0x48, 0xd9, 0xca, 0xee, 0x8e, 0xb2, 0x3b, 0x12, 0xf2, 0x8d,
	0x5f, 0x40, 0xe5, 0x08, 0xb7, 0xfc, 0x08, 0x7e, 0x44, 0xb8, 0xa5, 0x38, 0x51, 0x1c, 0x02, 0x95,
	0x70, 0xe0, 0x9c, 0x13, 0x47, 0x6a, 0x1e, 0x2b, 0xad, 0x64, 0x25, 0xb1, 0x79, 0x1c, 0xb8, 0x69,
	0xa6, 0xbb, 0xbf, 0x7e, 0xcc, 0xd7, 0xdd, 0x5b, 0x82, 0x4b, 0xdd, 0x80, 0xf6, 0x89, 0x8f, 0x7d,
	0x8b, 0x94, 0x02, 0xf2, 0x35, 0x0e, 0xec, 0x52, 0x7f, 0x47, 0xfd, 0x2a, 0x76, 0x03, 0xca, 0x28,
	0xca, 0x8d, 0x54, 0x8a, 0x4a, 0xd0, 0xdf, 0xd9, 0xc8, 0x75, 0x68, 0x87, 0x0a, 0x85, 0x12, 0xff,
	0x25, 0x75, 0x37, 0x0a, 0x1d, 0x4a, 0x3b, 0x2e, 0x29, 0x89, 0x53, 0xab, 0xd7, 0x2e, 0x31, 0xc7,
	0x23, 0x21, 0xc3, 0x5e, 0x57, 0x29, 0xe4, 0x2d, 0x1a, 0x7a, 0x34, 0x2c, 0xb5, 0x70, 0x48, 0x4a,
	0xfd, 0x9d, 0x16, 0x61, 0x78, 0xa7, 0x64, 0x51, 0xc7, 0x57, 0xf2, 0x75, 0x29, 0x37, 0x25, 0xb2,
	0x3c, 0x48, 0xd1, 0xd6, 0xf3, 0x24, 0xa4, 0x0c, 0xe1, 0xff, 0x30, 0xa0, 0x9d, 0x00, 0x7b, 0x28,
	0x0d, 0xb3, 0x8e, 0xad, 0x6b, 0x9b, 0xda, 0x76, 0xc2, 0x98, 0x75, 0x6c, 0x94, 0x83, 0x79, 0xe6,
	0x30, 0x97, 0xe8, 0xb3, 0x9b, 0xda, 0xf6, 0x92, 0x21, 0x0f, 0x68, 0x13, 0x92, 0x36, 0x09, 0xad,
	0xc0, 0xe9, 0x32, 0x87, 0xfa, 0xfa, 0x9c, 0x90, 0xc5, 0xaf, 0xd0, 0x35, 0x58, 0xb3, 0x9d, 0x90,
	0x05, 0x4e, 0xab, 0xc7, 0x88, 0xd9, 0x0e, 0xa8, 0x67, 0x62, 0xdb, 0x0e, 0x48, 0x18, 0xea, 0x09,
	0xa1, 0xbd, 0x3a, 0x12, 0xef, 0x07, 0xd4, 0x2b, 0x4b, 0x21, 0xfa, 0x0c, 0xb2, 0x8c, 0x32, 0xec,
	0x9a, 0xb2, 0x2c, 0x66, 0x97, 0x52, 0x57, 0x9f, 0xdf, 0xd4, 0xb6, 0x93, 0xbb, 0xeb, 0x45, 0x15,
	0x3b, 0x4f, 0xb4, 0xa8, 0x12, 0x2d, 0xee, 0x51, 0xc7, 0xaf, 0x24, 0x1e, 0x3d, 0x29, 0xcc, 0x18,
	0x2b, 0xc2, 0x52, 0xe5, 0x43, 0xa9, 0x8b, 0x8e, 0xe0, 0x42, 0x40, 0x3c, 0xec, 0xf8, 0x8e, 0xdf,
	0x11, 0x48, 0x66, 0x0b, 0xbb, 0xbc, 0xe8, 0xfa, 0xc2, 0xe9, 0x10, 0x73, 0x43, 0x73, 0x8e, 0x57,
	0x91, 0xc6, 0x68, 0x1f, 0xd2, 0x96, 0x8b, 0x1d, 0x8f, 0xd8, 0x26, 0xf6, 0x68, 0xcf, 0x67, 0xfa,
	0xb9, 0xd3, 0xc1, 0xa5, 0x94, 0x59, 0x59, 0x58, 0x21, 0x03, 0x56, 0x3d, 0x3c, 0x88, 0x32, 0x6d,
	0x1d, 0x0f, 0x2b, 0xb4, 0x78, 0x3a, 0x38, 0xe4, 0xe1, 0x81, 0xcc, 0xb6, 0x72, 0x1c, 0xd5, 0xef,
	0x36, 0xac, 0x79, 0x8e, 0xef, 0x78, 0x3d, 0xcf, 0x0c, 0xa8, 0xeb, 0xd2, 0x3e, 0x09, 0xa2, 0x20,
	0x97, 0x4e, 0x87, 0xba, 0xaa, 0xec, 0x0d, 0x65, 0xae, 0x82, 0x7d, 0x0f, 0x72, 0x22, 0x7a, 0xb3,
	0x4b, 0x02, 0x87, 0xda, 0x66, 0x48, 0x2c, 0xea, 0xdb, 0xa1, 0x0e, 0x82, 0x2a, 0x48, 0xc8, 0x0e,
	0x85, 0xa8, 0x21, 0x25, 0xc8, 0x00, 0xd4, 0x95, 0xac, 0x32, 0x43, 0x86, 0x03, 0x66, 0x72, 0xe2,
	0xea, 0x49, 0x11, 0xc5, 0x46, 0x51, 0xb2, 0xba, 0x18, 0xb1, 0xba, 0xd8, 0x8c, 0x58, 0x5d, 0x59,
	0xe4, 0x61, 0x3c, 0xf8, 0xb5, 0xa0, 0x19, 0x19, 0x65, 0xdf, 0xe0, 0xe6, 0x5c, 0x01, 0x99, 0xb0,
	0x4e, 0x06, 0x5d, 0x62, 0x31, 0x62, 0x9b, 0x11, 0x38, 0xf1, 0x6d, 0x09, 0xbd, 0x7c, 0x06, 0xe8,
	0x0b, 0x11, 0x8c, 0x22, 0x7e, 0xcd, 0xb7, 0x85, 0x83, 0x23, 0xc8, 0x4d, 0xe2, 0x9a, 0x1e, 0x1e,
	0xe8, 0xa9, 0x33, 0x60, 0x67, 0xbb, 0x63, 0x98, 0x37, 0xf1, 0x00, 0xdd, 0x86, 0xd5, 0xb1, 0xea,
	0x0d, 0x63, 0x4e, 0x9f, 0x01, 0x37, 0x5e, 0xe4, 0x28, 0xde, 0x3b, 0xb0, 0x86, 0x2d, 0xd6, 0xc3,
	0xee, 0xc9, 0x72, 0xac, 0x9c, 0x01, 0x3a, 0x27, 0x41, 0x26, 0x8a, 0x71, 0x19, 0x52, 0xf1, 0xa8,
	0x43, 0x3d, 0x23, 0x1e, 0x7b, 0x39, 0x16, 0x47, 0x28, 0x88, 0xd1, 0x0b, 0x02, 0xe2, 0x33, 0x33,
	0xae, 0xac, 0x67, 0x15, 0x31, 0xa4, 0x6c, 0x6f, 0x64, 0x82, 0x3e, 0x82, 0x0d, 0xc1, 0xfb, 0x88,
	0x9f, 0xe3, 0x3e, 0x90, 0xb0, 0x5b, 0xe3, 0xdc, 0x56, 0x0a, 0x7b, 0x71, 0x77, 0x1f, 0xc3, 0x7c,
	0xc8, 0x30, 0x23, 0xfa, 0xf9, 0x4d, 0x6d, 0x3b, 0xbd, 0xfb, 0x56, 0x71, 0xda, 0x28, 0x2d, 0x8e,
	0x0d, 0xb5, 0x62, 0x83, 0x1b, 0x18, 0xd2, 0x0e, 0xbd, 0x03, 0x59, 0x32, 0xe8, 0x3a, 0x01, 0xe6,
	0x73, 0xca, 0xa4, 0xed, 0x76, 0x48, 0x98, 0x9e, 0x13, 0x4e, 0x33, 0x23, 0xc1, 0x2d, 0x71, 0x8f,
	0xee, 0x00, 0xba, 0xdf, 0xc3, 0xae, 0xd3, 0x3e, 0xe6, 0x23, 0x04, 0x5b, 0x5c, 0x14, 0xea, 0xab,
	0x9b, 0x73, 0xdb, 0xc9, 0xdd, 0x2b, 0xd3, 0x5d, 0x7f, 0x3e, 0xd4, 0x2f, 0x0b, 0x75, 0xd5, 0x56,
	0xd9, 0xfb, 0x13, 0xf7, 0xe1, 0xd6, 0x3d, 0x98, 0x17, 0x91, 0xa1, 0x55, 0xc8, 0x36, 0x9a, 0xe5,
	0x66, 0xcd, 0x3c, 0x3a, 0x68, 0x1c, 0xd6, 0xf6, 0xea, 0xfb, 0xf5, 0x5a, 0x35, 0x33, 0x83, 0xb2,
	0x90, 0x92, 0xd7, 0x87, 0xb5, 0x83, 0x6a, 0xfd, 0xe0, 0x93, 0x8c, 0x36, 0xba, 0x6a, 0x34, 0xcb,
	0x46, 0xb3, 0x56, 0xcd, 0xcc, 0x22, 0x04, 0x69, 0x79, 0xb5, 0x5f, 0x3f, 0xa8, 0x37, 0xae, 0xd7,
	0xaa, 0x99, 0xb9, 0x91, 0x5a, 0xed, 0xcb, 0xc3, 0xba, 0x51, 0xab, 0x66, 0x12, 0x1f, 0x2e, 0x7e,
	0xf7, 0xb0, 0xa0, 0xfd, 0xf1, 0xb0, 0xa0, 0x6d, 0x7d, 0x33, 0x07, 0xaf, 0xc7, 0x4a, 0x2a, 0x4b,
	0x55, 0x8d, 0xa6, 0x31, 0x1f, 0xde, 0x57, 0x60, 0x65, 0x8c, 0xad, 0xc3, 0x8d, 0x90, 0x8a, 0xbd,
	0x7c, 0xdd, 0x46, 0x6f, 0x43, 0x36, 0x1a, 0xd3, 0x8a, 0x7c, 0x8e, 0x2d, 0x16, 0x45, 0xc2, 0x58,
	0x09, 0xe2, 0x2f, 0x50, 0xb7, 0x91, 0x0b, 0x97, 0xe3, 0x83, 0x3d, 0x94, 0xf3, 0xb8, 0x4d, 0xc7,
	0x9f, 0x5f, 0xac, 0x92, 0x53, 0x0c, 0xa9, 0x7c, 0x6c, 0xd4, 0x87, 0x7c, 0x36, 0xef, 0xd3, 0x38,
	0x4d, 0x50, 0x05, 0x96, 0xe3, 0x7e, 0xc4, 0xce, 0x39, 0x05, 0x6c, 0x32, 0x18, 0x21, 0xa2, 0x4b,
	0xb0, 0x2c, 0x23, 0x0e, 0xef, 0xe2, 0x80, 0x84, 0x62, 0x0b, 0xcd, 0x19, 0x49, 0x71, 0xd7, 0x10,
	0x57, 0xe8, 0x5d, 0x40, 0x93, 0x6d, 0x4d, 0x6c, 0xb1, 0x5c, 0x16, 0x8d, 0xcc, 0x78, 0xb7, 0x12,
	0x3b, 0xf6, 0x04, 0xcf, 0xe7, 0x00, 0xc9, 0xe0, 0xcb, 0x96, 0xc5, 0xc7, 0xab, 0xe4, 0xc1, 0xd4,
	0x7a, 0x6a, 0xd3, 0xeb, 0x39, 0xe5, 0x8d, 0x66, 0xa7, 0xbd, 0x91, 0x0e, 0xe7, 0xa2, 0xb5, 0x22,
	0xd7, 0x74, 0x74, 0x44, 0x9f, 0x42, 0x5a, 0x12, 0xda, 0x14, 0x21, 0x90, 0x40, 0x4f, 0x08, 0x5e,
	0x5f, 0x9e, 0xce, 0x6b, 0xc9, 0xda, 0x3d, 0xa9, 0x6a, 0xa4, 0x70, 0xfc, 0xc8, 0x27, 0x85, 0xac,
	0x92, 0x49, 0x70, 0xe0, 0x13, 0x5b, 0x14, 0x2b, 0x61, 0x2c, 0xcb, 0xcb, 0x9a, 0xb8, 0x43, 0xb7,
	0x41, 0x4e, 0x0e, 0xbe, 0x0e, 0x58, 0x2f, 0x14, 0x75, 0x4a, 0xef, 0x7e, 0xf0, 0xb2, 0x0e, 0x8e,
	0x97, 0xa7, 0x28, 0x1e, 0xb8, 0x21, 0x6c, 0x8d, 0xa4, 0x35, 0x3a, 0x6c, 0x7d, 0xaf, 0x41, 0x32,
	0x26, 0x44, 0x17, 0x41, 0xdf, 0xbb, 0x51, 0xae, 0xdf, 0xe4, 0x5d, 0xd2, 0x3c, 0x6a, 0x4c, 0xb4,
	0xd5, 0x49, 0xa9, 0x38, 0x96, 0x2b, 0x37, 0x6a, 0x19, 0x0d, 0x6d, 0xc0, 0x85, 0x31, 0xe9, 0x48,
	0x36, 0x8b, 0x74, 0xc8, 0x9d, 0x94, 0x89, 0x86, 0x9b, 0x94, 0x4c, 0xeb, 0xbb, 0xdf, 0x35, 0xc8,
	0x4c, 0x0e, 0x07, 0x54, 0x81, 0x45, 0x9b, 0xb8, 0xa4, 0xc3, 0x27, 0x9a, 0x26, 0x48, 0xfa, 0xc6,
	0xcb, 0xca, 0x5f, 0x55, 0xba, 0xd7, 0x67, 0x8c, 0xa1, 0x1d, 0xc7, 0x60, 0x01, 0xf6, 0xc3, 0x36,
	0x09, 0x04, 0x07, 0x5e, 0x81, 0xd1, 0x54, 0xba, 0x1c, 0x23, 0xb2, 0x43, 0xd7, 0x20, 0xd1, 0xa7,
	0x8c, 0xa8, 0xfe, 0xdb, 0x7c, 0x99, 0xfd, 0x17, 0x54, 0xf8, 0x17, 0xfa, 0xa3, 0xf4, 0x2a, 0x0b,
	0x90, 0x60, 0xc7, 0x5d, 0xb2, 0xd5, 0x85, 0xec, 0x64, 0x96, 0xe1, 0x0b, 0xe6, 0xa8, 0xf6, 0xef,
	0xcc, 0xd1, 0x6f, 0x13, 0x90, 0x1e, 0x2f, 0x0f, 0x7a, 0x13, 0x56, 0xa2, 0xcf, 0xa0, 0x91, 0x33,
	0xce, 0xc8, 0xb4, 0xba, 0x8e, 0x02, 0xe3, 0x8a, 0x78, 0x30, 0xa6, 0x38, 0xab, 0x14, 0xe5, 0x75,
	0xa4, 0x78, 0x04, 0xeb, 0x11, 0xa2, 0x2a, 0x3c, 0xef, 0x1c, 0xf5, 0x69, 0xf5, 0xaa, 0xa9, 0x65,
	0x44, 0x1f, 0x65, 0xd5, 0xa1, 0xa9, 0xfa, 0xac, 0xe2, 0xb0, 0xca, 0xff, 0x49, 0xd8, 0xc4, 0xab,
	0x61, 0xa5, 0xed, 0x09, 0xd8, 0x01, 0x14, 0xe2, 0xf9, 0xf7, 0x09, 0xef, 0xb9, 0x7b, 0x84, 0x0f,
	0x0b, 0x8b, 0xf8, 0xcc, 0x71, 0x89, 0xe8, 0xd0, 0xa5, 0xca, 0x0e, 0x2f, 0xea, 0x2f, 0x4f, 0x0a,
	0xaf, 0x49, 0x1f, 0xa1, 0x7d, 0xaf, 0xe8, 0xd0, 0x92, 0x87, 0xd9, 0xdd, 0xe2, 0x0d, 0xd2, 0xc1,
	0xd6, 0x71, 0x95, 0x58, 0x3f, 0xfd, 0x70, 0x15, 0x54, 0x08, 0x55, 0x62, 0x19, 0x17, 0x63, 0x25,
	0xec, 0x93, 0x06, 0xc7, 0x3d, 0x1c, 0xc2, 0x0a, 0xcf, 0xb1, 0x82, 0x4e, 0xf3, 0xbc, 0xf0, 0xf7,
	0x3d, 0x8f, 0xde, 0xe4, 0x84, 0xe7, 0x58, 0xa7, 0xfd, 0xa8, 0x45, 0x84, 0x88, 0xb8, 0xfe, 0x1f,
	0x10, 0xe2, 0xce, 0x3f, 0x21, 0x84, 0x22, 0xf3, 0x8b, 0x68, 0x11, 0xcb, 0xe5, 0x4f, 0x0d, 0x60,
	0xd4, 0x77, 0xff, 0xb3, 0x3c, 0xd0, 0x0e, 0xe4, 0xfa, 0xd8, 0x75, 0x6c, 0xcc, 0x68, 0x60, 0x7a,
	0x3d, 0x97, 0x39, 0x5d, 0xd7, 0x11, 0x9b, 0x86, 0x87, 0x72, 0x7e, 0x28, 0xbb, 0x39, 0x14, 0xc5,
	0x52, 0x6f, 0x43, 0x6a, 0x6c, 0xe9, 0xa0, 0x02, 0x24, 0xd5, 0xc6, 0xe2, 0x93, 0x46, 0x24, 0xbe,
	0x64, 0x80, 0xbc, 0x6a, 0x1e, 0x77, 0xc5, 0x02, 0xf5, 0x7b, 0x5e, 0x8b, 0x04, 0x26, 0x6d, 0x4f,
	0xa4, 0xbd, 0x22, 0x05, 0xb7, 0xda, 0x2a, 0xef, 0xd8, 0xe4, 0xea, 0x3c, 0x7a, 0x9a, 0xd7, 0x1e,
	0x3f, 0xcd, 0x6b, 0xbf, 0x3d, 0xcd, 0x6b, 0x0f, 0x9e, 0xe5, 0x67, 0x1e, 0x3f, 0xcb, 0xcf, 0xfc,
	0xfc, 0x2c, 0x3f, 0x03, 0x6b, 0x0e, 0x9d, 0x3a, 0x9c, 0x0e, 0xb5, 0xaf, 0x76, 0x3b, 0x0e, 0xbb,
	0xdb, 0x6b, 0x15, 0x2d, 0xea, 0x95, 0x46, 0x2a, 0x57, 0x1d, 0x1a, 0x3b, 0x95, 0x06, 0xd1, 0x1f,
	0x00, 0x3c, 0xde, 0xb0, 0xb5, 0x20, 0xbe, 0xc1, 0xdf, 0xff, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x3b,
	0xe0, 0x83, 0x17, 0x22, 0x10, 0x00, 0x00,
}

func (this *RewardProgram) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardProgram)
	if !ok {
		that2, ok := that.(RewardProgram)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.DistributeFromAddress != that1.DistributeFromAddress {
		return false
	}
	if !this.TotalRewardPool.Equal(&that1.TotalRewardPool) {
		return false
	}
	if !this.RemainingPoolBalance.Equal(&that1.RemainingPoolBalance) {
		return false
	}
	if !this.ClaimedAmount.Equal(&that1.ClaimedAmount) {
		return false
	}
	if !this.MaxRewardByAddress.Equal(&that1.MaxRewardByAddress) {
		return false
	}
	if !this.MinimumRolloverAmount.Equal(&that1.MinimumRolloverAmount) {
		return false
	}
	if this.ClaimPeriodSeconds != that1.ClaimPeriodSeconds {
		return false
	}
	if !this.ProgramStartTime.Equal(that1.ProgramStartTime) {
		return false
	}
	if !this.ExpectedProgramEndTime.Equal(that1.ExpectedProgramEndTime) {
		return false
	}
	if !this.ProgramEndTimeMax.Equal(that1.ProgramEndTimeMax) {
		return false
	}
	if !this.ClaimPeriodEndTime.Equal(that1.ClaimPeriodEndTime) {
		return false
	}
	if !this.ActualProgramEndTime.Equal(that1.ActualProgramEndTime) {
		return false
	}
	if this.ClaimPeriods != that1.ClaimPeriods {
		return false
	}
	if this.CurrentClaimPeriod != that1.CurrentClaimPeriod {
		return false
	}
	if this.MaxRolloverClaimPeriods != that1.MaxRolloverClaimPeriods {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.ExpirationOffset != that1.ExpirationOffset {
		return false
	}
	if len(this.QualifyingActions) != len(that1.QualifyingActions) {
		return false
	}
	for i := range this.QualifyingActions {
		if !this.QualifyingActions[i].Equal(&that1.QualifyingActions[i]) {
			return false
		}
	}
	return true
}
func (this *ClaimPeriodRewardDistribution) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClaimPeriodRewardDistribution)
	if !ok {
		that2, ok := that.(ClaimPeriodRewardDistribution)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClaimPeriodId != that1.ClaimPeriodId {
		return false
	}
	if this.RewardProgramId != that1.RewardProgramId {
		return false
	}
	if !this.TotalRewardsPoolForClaimPeriod.Equal(&that1.TotalRewardsPoolForClaimPeriod) {
		return false
	}
	if !this.RewardsPool.Equal(&that1.RewardsPool) {
		return false
	}
	if this.TotalShares != that1.TotalShares {
		return false
	}
	if this.ClaimPeriodEnded != that1.ClaimPeriodEnded {
		return false
	}
	return true
}
func (this *RewardAccountState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardAccountState)
	if !ok {
		that2, ok := that.(RewardAccountState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RewardProgramId != that1.RewardProgramId {
		return false
	}
	if this.ClaimPeriodId != that1.ClaimPeriodId {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if len(this.ActionCounter) != len(that1.ActionCounter) {
		return false
	}
	for i := range this.ActionCounter {
		if !this.ActionCounter[i].Equal(that1.ActionCounter[i]) {
			return false
		}
	}
	if this.SharesEarned != that1.SharesEarned {
		return false
	}
	if this.ClaimStatus != that1.ClaimStatus {
		return false
	}
	return true
}
func (this *QualifyingAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QualifyingAction)
	if !ok {
		that2, ok := that.(QualifyingAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *QualifyingAction_Delegate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QualifyingAction_Delegate)
	if !ok {
		that2, ok := that.(QualifyingAction_Delegate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Delegate.Equal(that1.Delegate) {
		return false
	}
	return true
}
func (this *QualifyingAction_Transfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QualifyingAction_Transfer)
	if !ok {
		that2, ok := that.(QualifyingAction_Transfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Transfer.Equal(that1.Transfer) {
		return false
	}
	return true
}
func (this *QualifyingAction_Vote) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QualifyingAction_Vote)
	if !ok {
		that2, ok := that.(QualifyingAction_Vote)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vote.Equal(that1.Vote) {
		return false
	}
	return true
}
func (this *ActionDelegate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionDelegate)
	if !ok {
		that2, ok := that.(ActionDelegate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumActions != that1.MinimumActions {
		return false
	}
	if this.MaximumActions != that1.MaximumActions {
		return false
	}
	if !this.MinimumDelegationAmount.Equal(that1.MinimumDelegationAmount) {
		return false
	}
	if !this.MaximumDelegationAmount.Equal(that1.MaximumDelegationAmount) {
		return false
	}
	if !this.MinimumActiveStakePercentile.Equal(that1.MinimumActiveStakePercentile) {
		return false
	}
	if !this.MaximumActiveStakePercentile.Equal(that1.MaximumActiveStakePercentile) {
		return false
	}
	return true
}
func (this *ActionTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionTransfer)
	if !ok {
		that2, ok := that.(ActionTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumActions != that1.MinimumActions {
		return false
	}
	if this.MaximumActions != that1.MaximumActions {
		return false
	}
	if !this.MinimumDelegationAmount.Equal(&that1.MinimumDelegationAmount) {
		return false
	}
	return true
}
func (this *ActionVote) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionVote)
	if !ok {
		that2, ok := that.(ActionVote)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumActions != that1.MinimumActions {
		return false
	}
	if this.MaximumActions != that1.MaximumActions {
		return false
	}
	if !this.MinimumDelegationAmount.Equal(&that1.MinimumDelegationAmount) {
		return false
	}
	if this.ValidatorMultiplier != that1.ValidatorMultiplier {
		return false
	}
	return true
}
func (this *ActionCounter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionCounter)
	if !ok {
		that2, ok := that.(ActionCounter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionType != that1.ActionType {
		return false
	}
	if this.NumberOfActions != that1.NumberOfActions {
		return false
	}
	return true
}
func (m *RewardProgram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardProgram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardProgram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QualifyingActions) > 0 {
		for iNdEx := len(m.QualifyingActions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QualifyingActions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReward(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.ExpirationOffset != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ExpirationOffset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.State != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MaxRolloverClaimPeriods != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MaxRolloverClaimPeriods))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CurrentClaimPeriod != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.CurrentClaimPeriod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ClaimPeriods != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ClaimPeriods))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ActualProgramEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ActualProgramEndTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintReward(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x7a
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ClaimPeriodEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ClaimPeriodEndTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintReward(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x72
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ProgramEndTimeMax, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ProgramEndTimeMax):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintReward(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x6a
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedProgramEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedProgramEndTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintReward(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x62
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ProgramStartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ProgramStartTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintReward(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x5a
	if m.ClaimPeriodSeconds != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ClaimPeriodSeconds))
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.MinimumRolloverAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.MaxRewardByAddress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.ClaimedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.RemainingPoolBalance.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.TotalRewardPool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.DistributeFromAddress) > 0 {
		i -= len(m.DistributeFromAddress)
		copy(dAtA[i:], m.DistributeFromAddress)
		i = encodeVarintReward(dAtA, i, uint64(len(m.DistributeFromAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintReward(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintReward(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClaimPeriodRewardDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimPeriodRewardDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimPeriodRewardDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimPeriodEnded {
		i--
		if m.ClaimPeriodEnded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TotalShares != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.TotalShares))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.RewardsPool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.TotalRewardsPoolForClaimPeriod.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RewardProgramId != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.RewardProgramId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClaimPeriodId != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ClaimPeriodId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardAccountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardAccountState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardAccountState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimStatus != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ClaimStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.SharesEarned != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.SharesEarned))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ActionCounter) > 0 {
		for iNdEx := len(m.ActionCounter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActionCounter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReward(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintReward(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClaimPeriodId != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ClaimPeriodId))
		i--
		dAtA[i] = 0x10
	}
	if m.RewardProgramId != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.RewardProgramId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QualifyingAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QualifyingAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QualifyingAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QualifyingAction_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QualifyingAction_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReward(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *QualifyingAction_Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QualifyingAction_Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Transfer != nil {
		{
			size, err := m.Transfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReward(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QualifyingAction_Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QualifyingAction_Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReward(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QualifyingActions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QualifyingActions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QualifyingActions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QualifyingActions) > 0 {
		for iNdEx := len(m.QualifyingActions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QualifyingActions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReward(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionDelegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaximumActiveStakePercentile.Size()
		i -= size
		if _, err := m.MaximumActiveStakePercentile.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MinimumActiveStakePercentile.Size()
		i -= size
		if _, err := m.MinimumActiveStakePercentile.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.MaximumDelegationAmount != nil {
		{
			size, err := m.MaximumDelegationAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReward(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MinimumDelegationAmount != nil {
		{
			size, err := m.MinimumDelegationAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReward(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MaximumActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MaximumActions))
		i--
		dAtA[i] = 0x10
	}
	if m.MinimumActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MinimumActions))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MinimumDelegationAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.MaximumActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MaximumActions))
		i--
		dAtA[i] = 0x10
	}
	if m.MinimumActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MinimumActions))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorMultiplier != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.ValidatorMultiplier))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.MinimumDelegationAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintReward(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.MaximumActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MaximumActions))
		i--
		dAtA[i] = 0x10
	}
	if m.MinimumActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.MinimumActions))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumberOfActions != 0 {
		i = encodeVarintReward(dAtA, i, uint64(m.NumberOfActions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ActionType) > 0 {
		i -= len(m.ActionType)
		copy(dAtA[i:], m.ActionType)
		i = encodeVarintReward(dAtA, i, uint64(len(m.ActionType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintReward(dAtA []byte, offset int, v uint64) int {
	offset -= sovReward(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RewardProgram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovReward(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovReward(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovReward(uint64(l))
	}
	l = len(m.DistributeFromAddress)
	if l > 0 {
		n += 1 + l + sovReward(uint64(l))
	}
	l = m.TotalRewardPool.Size()
	n += 1 + l + sovReward(uint64(l))
	l = m.RemainingPoolBalance.Size()
	n += 1 + l + sovReward(uint64(l))
	l = m.ClaimedAmount.Size()
	n += 1 + l + sovReward(uint64(l))
	l = m.MaxRewardByAddress.Size()
	n += 1 + l + sovReward(uint64(l))
	l = m.MinimumRolloverAmount.Size()
	n += 1 + l + sovReward(uint64(l))
	if m.ClaimPeriodSeconds != 0 {
		n += 1 + sovReward(uint64(m.ClaimPeriodSeconds))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ProgramStartTime)
	n += 1 + l + sovReward(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedProgramEndTime)
	n += 1 + l + sovReward(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ProgramEndTimeMax)
	n += 1 + l + sovReward(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ClaimPeriodEndTime)
	n += 1 + l + sovReward(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ActualProgramEndTime)
	n += 1 + l + sovReward(uint64(l))
	if m.ClaimPeriods != 0 {
		n += 2 + sovReward(uint64(m.ClaimPeriods))
	}
	if m.CurrentClaimPeriod != 0 {
		n += 2 + sovReward(uint64(m.CurrentClaimPeriod))
	}
	if m.MaxRolloverClaimPeriods != 0 {
		n += 2 + sovReward(uint64(m.MaxRolloverClaimPeriods))
	}
	if m.State != 0 {
		n += 2 + sovReward(uint64(m.State))
	}
	if m.ExpirationOffset != 0 {
		n += 2 + sovReward(uint64(m.ExpirationOffset))
	}
	if len(m.QualifyingActions) > 0 {
		for _, e := range m.QualifyingActions {
			l = e.Size()
			n += 2 + l + sovReward(uint64(l))
		}
	}
	return n
}

func (m *ClaimPeriodRewardDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClaimPeriodId != 0 {
		n += 1 + sovReward(uint64(m.ClaimPeriodId))
	}
	if m.RewardProgramId != 0 {
		n += 1 + sovReward(uint64(m.RewardProgramId))
	}
	l = m.TotalRewardsPoolForClaimPeriod.Size()
	n += 1 + l + sovReward(uint64(l))
	l = m.RewardsPool.Size()
	n += 1 + l + sovReward(uint64(l))
	if m.TotalShares != 0 {
		n += 1 + sovReward(uint64(m.TotalShares))
	}
	if m.ClaimPeriodEnded {
		n += 2
	}
	return n
}

func (m *RewardAccountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RewardProgramId != 0 {
		n += 1 + sovReward(uint64(m.RewardProgramId))
	}
	if m.ClaimPeriodId != 0 {
		n += 1 + sovReward(uint64(m.ClaimPeriodId))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovReward(uint64(l))
	}
	if len(m.ActionCounter) > 0 {
		for _, e := range m.ActionCounter {
			l = e.Size()
			n += 1 + l + sovReward(uint64(l))
		}
	}
	if m.SharesEarned != 0 {
		n += 1 + sovReward(uint64(m.SharesEarned))
	}
	if m.ClaimStatus != 0 {
		n += 1 + sovReward(uint64(m.ClaimStatus))
	}
	return n
}

func (m *QualifyingAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *QualifyingAction_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 1 + l + sovReward(uint64(l))
	}
	return n
}
func (m *QualifyingAction_Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transfer != nil {
		l = m.Transfer.Size()
		n += 1 + l + sovReward(uint64(l))
	}
	return n
}
func (m *QualifyingAction_Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovReward(uint64(l))
	}
	return n
}
func (m *QualifyingActions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QualifyingActions) > 0 {
		for _, e := range m.QualifyingActions {
			l = e.Size()
			n += 1 + l + sovReward(uint64(l))
		}
	}
	return n
}

func (m *ActionDelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumActions != 0 {
		n += 1 + sovReward(uint64(m.MinimumActions))
	}
	if m.MaximumActions != 0 {
		n += 1 + sovReward(uint64(m.MaximumActions))
	}
	if m.MinimumDelegationAmount != nil {
		l = m.MinimumDelegationAmount.Size()
		n += 1 + l + sovReward(uint64(l))
	}
	if m.MaximumDelegationAmount != nil {
		l = m.MaximumDelegationAmount.Size()
		n += 1 + l + sovReward(uint64(l))
	}
	l = m.MinimumActiveStakePercentile.Size()
	n += 1 + l + sovReward(uint64(l))
	l = m.MaximumActiveStakePercentile.Size()
	n += 1 + l + sovReward(uint64(l))
	return n
}

func (m *ActionTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumActions != 0 {
		n += 1 + sovReward(uint64(m.MinimumActions))
	}
	if m.MaximumActions != 0 {
		n += 1 + sovReward(uint64(m.MaximumActions))
	}
	l = m.MinimumDelegationAmount.Size()
	n += 1 + l + sovReward(uint64(l))
	return n
}

func (m *ActionVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumActions != 0 {
		n += 1 + sovReward(uint64(m.MinimumActions))
	}
	if m.MaximumActions != 0 {
		n += 1 + sovReward(uint64(m.MaximumActions))
	}
	l = m.MinimumDelegationAmount.Size()
	n += 1 + l + sovReward(uint64(l))
	if m.ValidatorMultiplier != 0 {
		n += 1 + sovReward(uint64(m.ValidatorMultiplier))
	}
	return n
}

func (m *ActionCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionType)
	if l > 0 {
		n += 1 + l + sovReward(uint64(l))
	}
	if m.NumberOfActions != 0 {
		n += 1 + sovReward(uint64(m.NumberOfActions))
	}
	return n
}

func sovReward(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReward(x uint64) (n int) {
	return sovReward(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RewardProgram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardProgram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardProgram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributeFromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistributeFromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewardPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewardPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingPoolBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingPoolBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClaimedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRewardByAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRewardByAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRolloverAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinimumRolloverAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPeriodSeconds", wireType)
			}
			m.ClaimPeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimPeriodSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ProgramStartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedProgramEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedProgramEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramEndTimeMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ProgramEndTimeMax, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPeriodEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ClaimPeriodEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualProgramEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ActualProgramEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPeriods", wireType)
			}
			m.ClaimPeriods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimPeriods |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentClaimPeriod", wireType)
			}
			m.CurrentClaimPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentClaimPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRolloverClaimPeriods", wireType)
			}
			m.MaxRolloverClaimPeriods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRolloverClaimPeriods |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RewardProgram_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationOffset", wireType)
			}
			m.ExpirationOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QualifyingActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QualifyingActions = append(m.QualifyingActions, QualifyingAction{})
			if err := m.QualifyingActions[len(m.QualifyingActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimPeriodRewardDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimPeriodRewardDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimPeriodRewardDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPeriodId", wireType)
			}
			m.ClaimPeriodId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimPeriodId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardProgramId", wireType)
			}
			m.RewardProgramId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardProgramId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewardsPoolForClaimPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewardsPoolForClaimPeriod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardsPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			m.TotalShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalShares |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPeriodEnded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClaimPeriodEnded = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardAccountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardAccountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardAccountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardProgramId", wireType)
			}
			m.RewardProgramId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardProgramId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPeriodId", wireType)
			}
			m.ClaimPeriodId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimPeriodId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCounter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionCounter = append(m.ActionCounter, &ActionCounter{})
			if err := m.ActionCounter[len(m.ActionCounter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesEarned", wireType)
			}
			m.SharesEarned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharesEarned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimStatus", wireType)
			}
			m.ClaimStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimStatus |= RewardAccountState_ClaimStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QualifyingAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QualifyingAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QualifyingAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionDelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &QualifyingAction_Delegate{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionTransfer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &QualifyingAction_Transfer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &QualifyingAction_Vote{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QualifyingActions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QualifyingActions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QualifyingActions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QualifyingActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QualifyingActions = append(m.QualifyingActions, QualifyingAction{})
			if err := m.QualifyingActions[len(m.QualifyingActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDelegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDelegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDelegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumActions", wireType)
			}
			m.MinimumActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumActions", wireType)
			}
			m.MaximumActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumDelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinimumDelegationAmount == nil {
				m.MinimumDelegationAmount = &types.Coin{}
			}
			if err := m.MinimumDelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumDelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaximumDelegationAmount == nil {
				m.MaximumDelegationAmount = &types.Coin{}
			}
			if err := m.MaximumDelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumActiveStakePercentile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinimumActiveStakePercentile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumActiveStakePercentile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaximumActiveStakePercentile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumActions", wireType)
			}
			m.MinimumActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumActions", wireType)
			}
			m.MaximumActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumDelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinimumDelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumActions", wireType)
			}
			m.MinimumActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumActions", wireType)
			}
			m.MaximumActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumDelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinimumDelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorMultiplier", wireType)
			}
			m.ValidatorMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorMultiplier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReward
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReward
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReward
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfActions", wireType)
			}
			m.NumberOfActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReward
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfActions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReward(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReward
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReward(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReward
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReward
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReward
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReward
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReward
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReward
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReward        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReward          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReward = fmt.Errorf("proto: unexpected end of group")
)
