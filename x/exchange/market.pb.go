// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/exchange/v1/market.proto

package exchange

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types1 "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/x/auth/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Permission defines the different types of permission that can be given to an account for a market.
type Permission int32

const (
	// PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.
	Permission_unspecified Permission = 0
	// PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.
	Permission_settle Permission = 1
	// PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.
	Permission_cancel Permission = 2
	// PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.
	Permission_withdraw Permission = 3
	// PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.
	Permission_update Permission = 4
	// PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.
	Permission_permissions Permission = 5
	// PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint.
	Permission_attributes Permission = 6
)

var Permission_name = map[int32]string{
	0: "PERMISSION_UNSPECIFIED",
	1: "PERMISSION_SETTLE",
	2: "PERMISSION_CANCEL",
	3: "PERMISSION_WITHDRAW",
	4: "PERMISSION_UPDATE",
	5: "PERMISSION_PERMISSIONS",
	6: "PERMISSION_ATTRIBUTES",
}

var Permission_value = map[string]int32{
	"PERMISSION_UNSPECIFIED": 0,
	"PERMISSION_SETTLE":      1,
	"PERMISSION_CANCEL":      2,
	"PERMISSION_WITHDRAW":    3,
	"PERMISSION_UPDATE":      4,
	"PERMISSION_PERMISSIONS": 5,
	"PERMISSION_ATTRIBUTES":  6,
}

func (x Permission) String() string {
	return proto.EnumName(Permission_name, int32(x))
}

func (Permission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d5cf198f1dd7e167, []int{0}
}

// MarketAccount is an account type for use with the accounts module to hold some basic information about a market.
type MarketAccount struct {
	// base_account is the base cosmos account information.
	*types.BaseAccount `protobuf:"bytes,1,opt,name=base_account,json=baseAccount,proto3,embedded=base_account" json:"base_account,omitempty" yaml:"base_account"`
	// market_id is the numerical identifier for this market.
	MarketId uint32 `protobuf:"varint,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// market_details is some human-consumable information about this market.
	MarketDetails MarketDetails `protobuf:"bytes,3,opt,name=market_details,json=marketDetails,proto3" json:"market_details"`
}

func (m *MarketAccount) Reset()      { *m = MarketAccount{} }
func (*MarketAccount) ProtoMessage() {}
func (*MarketAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5cf198f1dd7e167, []int{0}
}
func (m *MarketAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketAccount.Merge(m, src)
}
func (m *MarketAccount) XXX_Size() int {
	return m.Size()
}
func (m *MarketAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MarketAccount proto.InternalMessageInfo

// MarketDetails contains information about a market.
type MarketDetails struct {
	// name is a moniker that people can use to refer to this market.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description extra information about this market. The field is meant to be human-readable.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// website_url is a url people can use to get to this market, or at least get more information about this market.
	WebsiteUrl string `protobuf:"bytes,3,opt,name=website_url,json=websiteUrl,proto3" json:"website_url,omitempty"`
	// icon_uri is a uri for an icon to associate with this market.
	IconUri string `protobuf:"bytes,4,opt,name=icon_uri,json=iconUri,proto3" json:"icon_uri,omitempty"`
}

func (m *MarketDetails) Reset()         { *m = MarketDetails{} }
func (m *MarketDetails) String() string { return proto.CompactTextString(m) }
func (*MarketDetails) ProtoMessage()    {}
func (*MarketDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5cf198f1dd7e167, []int{1}
}
func (m *MarketDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketDetails.Merge(m, src)
}
func (m *MarketDetails) XXX_Size() int {
	return m.Size()
}
func (m *MarketDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketDetails.DiscardUnknown(m)
}

var xxx_messageInfo_MarketDetails proto.InternalMessageInfo

func (m *MarketDetails) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MarketDetails) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MarketDetails) GetWebsiteUrl() string {
	if m != nil {
		return m.WebsiteUrl
	}
	return ""
}

func (m *MarketDetails) GetIconUri() string {
	if m != nil {
		return m.IconUri
	}
	return ""
}

// Market contains all information about a market.
type Market struct {
	// market_id is the numerical identifier for this market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// market_details is some information about this market.
	MarketDetails MarketDetails `protobuf:"bytes,2,opt,name=market_details,json=marketDetails,proto3" json:"market_details"`
	// fee_create_ask_flat is the flat fee charged for creating an ask order.
	// Each coin entry is a separate option. When an ask is created, one of these must be paid.
	// If empty, no fee is required to create an ask order.
	FeeCreateAskFlat []types1.Coin `protobuf:"bytes,3,rep,name=fee_create_ask_flat,json=feeCreateAskFlat,proto3" json:"fee_create_ask_flat"`
	// fee_create_bid_flat is the flat fee charged for creating a bid order.
	// Each coin entry is a separate option. When a bid is created, one of these must be paid.
	// If empty, no fee is required to create a bid order.
	FeeCreateBidFlat []types1.Coin `protobuf:"bytes,4,rep,name=fee_create_bid_flat,json=feeCreateBidFlat,proto3" json:"fee_create_bid_flat"`
	// fee_seller_settlement_flat is the flat fee charged to the seller during settlement.
	// Each coin entry is a separate option.
	// When an ask is settled, the seller will pay the amount in the denom that matches the price they received.
	FeeSellerSettlementFlat []types1.Coin `protobuf:"bytes,5,rep,name=fee_seller_settlement_flat,json=feeSellerSettlementFlat,proto3" json:"fee_seller_settlement_flat"`
	// fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.
	// The price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed.
	FeeSellerSettlementRatios []FeeRatio `protobuf:"bytes,6,rep,name=fee_seller_settlement_ratios,json=feeSellerSettlementRatios,proto3" json:"fee_seller_settlement_ratios"`
	// fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.
	// Each coin entry is a separate option.
	// When a bid is created, the settlement fees provided must contain one of these.
	FeeBuyerSettlementFlat []types1.Coin `protobuf:"bytes,7,rep,name=fee_buyer_settlement_flat,json=feeBuyerSettlementFlat,proto3" json:"fee_buyer_settlement_flat"`
	// fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.
	// The price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but
	// each price denom to fee denom pair can only have one entry.
	FeeBuyerSettlementRatios []FeeRatio `protobuf:"bytes,8,rep,name=fee_buyer_settlement_ratios,json=feeBuyerSettlementRatios,proto3" json:"fee_buyer_settlement_ratios"`
	// accepting_orders is whether this market is allowing orders to be created for it.
	AcceptingOrders bool `protobuf:"varint,9,opt,name=accepting_orders,json=acceptingOrders,proto3" json:"accepting_orders,omitempty"`
	// allow_user_settlement is whether this market allows users to initiate their own settlements.
	// For example, the FillBids and FillAsks endpoints are available if and only if this is true.
	// The MarketSettle endpoint is only available to market actors regardless of the value of this field.
	AllowUserSettlement bool `protobuf:"varint,10,opt,name=allow_user_settlement,json=allowUserSettlement,proto3" json:"allow_user_settlement,omitempty"`
	// access_grants is the list of addresses and permissions granted for this market.
	AccessGrants []AccessGrant `protobuf:"bytes,11,rep,name=access_grants,json=accessGrants,proto3" json:"access_grants"`
	// req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.
	// An account must have all of these attributes in order to create an ask order in this market.
	// If the list is empty, any account can create ask orders in this market.
	//
	// An entry that starts with "*." will match any attributes that end with the rest of it.
	// E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "b.x.a", or "c.b.a.x".
	//
	// An entry of exactly "*" will match any attribute, which is equivalent to leaving this list empty.
	ReqAttrCreateAsk []string `protobuf:"bytes,12,rep,name=req_attr_create_ask,json=reqAttrCreateAsk,proto3" json:"req_attr_create_ask,omitempty"`
	// req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.
	// An account must have all of these attributes in order to create a bid order in this market.
	// If the list is empty, any account can create bid orders in this market.
	//
	// An entry that starts with "*." will match any attributes that end with the rest of it.
	// E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "c.b.x.a", or "c.b.a.x".
	//
	// An entry of exactly "*" will match any attribute, which is equivalent to leaving this list empty.
	ReqAttrCreateBid []string `protobuf:"bytes,13,rep,name=req_attr_create_bid,json=reqAttrCreateBid,proto3" json:"req_attr_create_bid,omitempty"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5cf198f1dd7e167, []int{2}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(m, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *Market) GetMarketDetails() MarketDetails {
	if m != nil {
		return m.MarketDetails
	}
	return MarketDetails{}
}

func (m *Market) GetFeeCreateAskFlat() []types1.Coin {
	if m != nil {
		return m.FeeCreateAskFlat
	}
	return nil
}

func (m *Market) GetFeeCreateBidFlat() []types1.Coin {
	if m != nil {
		return m.FeeCreateBidFlat
	}
	return nil
}

func (m *Market) GetFeeSellerSettlementFlat() []types1.Coin {
	if m != nil {
		return m.FeeSellerSettlementFlat
	}
	return nil
}

func (m *Market) GetFeeSellerSettlementRatios() []FeeRatio {
	if m != nil {
		return m.FeeSellerSettlementRatios
	}
	return nil
}

func (m *Market) GetFeeBuyerSettlementFlat() []types1.Coin {
	if m != nil {
		return m.FeeBuyerSettlementFlat
	}
	return nil
}

func (m *Market) GetFeeBuyerSettlementRatios() []FeeRatio {
	if m != nil {
		return m.FeeBuyerSettlementRatios
	}
	return nil
}

func (m *Market) GetAcceptingOrders() bool {
	if m != nil {
		return m.AcceptingOrders
	}
	return false
}

func (m *Market) GetAllowUserSettlement() bool {
	if m != nil {
		return m.AllowUserSettlement
	}
	return false
}

func (m *Market) GetAccessGrants() []AccessGrant {
	if m != nil {
		return m.AccessGrants
	}
	return nil
}

func (m *Market) GetReqAttrCreateAsk() []string {
	if m != nil {
		return m.ReqAttrCreateAsk
	}
	return nil
}

func (m *Market) GetReqAttrCreateBid() []string {
	if m != nil {
		return m.ReqAttrCreateBid
	}
	return nil
}

// FeeRatio defines a ratio of price amount to fee amount.
// For an order to be valid, its price must be evenly divisible by a FeeRatio's price.
type FeeRatio struct {
	// price is the unit the order price is divided by to get how much of the fee should apply.
	Price types1.Coin `protobuf:"bytes,1,opt,name=price,proto3" json:"price"`
	// fee is the amount to charge per price unit.
	Fee types1.Coin `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee"`
}

func (m *FeeRatio) Reset()      { *m = FeeRatio{} }
func (*FeeRatio) ProtoMessage() {}
func (*FeeRatio) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5cf198f1dd7e167, []int{3}
}
func (m *FeeRatio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeRatio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeRatio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeRatio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeRatio.Merge(m, src)
}
func (m *FeeRatio) XXX_Size() int {
	return m.Size()
}
func (m *FeeRatio) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeRatio.DiscardUnknown(m)
}

var xxx_messageInfo_FeeRatio proto.InternalMessageInfo

func (m *FeeRatio) GetPrice() types1.Coin {
	if m != nil {
		return m.Price
	}
	return types1.Coin{}
}

func (m *FeeRatio) GetFee() types1.Coin {
	if m != nil {
		return m.Fee
	}
	return types1.Coin{}
}

// AddrPermissions associates an address with a list of permissions available for that address.
type AccessGrant struct {
	// address is the address that these permissions apply to.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// allowed is the list of permissions available for the address.
	Permissions []Permission `protobuf:"varint,2,rep,packed,name=permissions,proto3,enum=provenance.exchange.v1.Permission" json:"permissions,omitempty"`
}

func (m *AccessGrant) Reset()         { *m = AccessGrant{} }
func (m *AccessGrant) String() string { return proto.CompactTextString(m) }
func (*AccessGrant) ProtoMessage()    {}
func (*AccessGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5cf198f1dd7e167, []int{4}
}
func (m *AccessGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessGrant.Merge(m, src)
}
func (m *AccessGrant) XXX_Size() int {
	return m.Size()
}
func (m *AccessGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessGrant.DiscardUnknown(m)
}

var xxx_messageInfo_AccessGrant proto.InternalMessageInfo

func (m *AccessGrant) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AccessGrant) GetPermissions() []Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.exchange.v1.Permission", Permission_name, Permission_value)
	proto.RegisterType((*MarketAccount)(nil), "provenance.exchange.v1.MarketAccount")
	proto.RegisterType((*MarketDetails)(nil), "provenance.exchange.v1.MarketDetails")
	proto.RegisterType((*Market)(nil), "provenance.exchange.v1.Market")
	proto.RegisterType((*FeeRatio)(nil), "provenance.exchange.v1.FeeRatio")
	proto.RegisterType((*AccessGrant)(nil), "provenance.exchange.v1.AccessGrant")
}

func init() {
	proto.RegisterFile("provenance/exchange/v1/market.proto", fileDescriptor_d5cf198f1dd7e167)
}

var fileDescriptor_d5cf198f1dd7e167 = []byte{
	// 985 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x41, 0x4f, 0x1b, 0xc7,
	0x17, 0xf7, 0x62, 0x03, 0xf6, 0x18, 0x88, 0xff, 0x43, 0xc2, 0x7f, 0x31, 0x95, 0xbd, 0x75, 0x14,
	0xc9, 0x69, 0x85, 0x2d, 0xa8, 0x7a, 0xe1, 0x66, 0x83, 0x69, 0x2d, 0x25, 0x04, 0xad, 0x6d, 0x45,
	0x8a, 0x2a, 0x6d, 0x67, 0x77, 0x9f, 0xcd, 0x88, 0xf5, 0xae, 0x33, 0x33, 0x0b, 0x49, 0xbf, 0x40,
	0x2b, 0x4e, 0x3d, 0xf6, 0x82, 0x44, 0xbf, 0x41, 0x0f, 0xfd, 0x10, 0x39, 0xa2, 0x9e, 0x7a, 0x42,
	0x15, 0x5c, 0x7a, 0xe8, 0xa9, 0x9f, 0xa0, 0xda, 0x99, 0xc5, 0xde, 0xb8, 0x46, 0x24, 0xea, 0x6d,
	0xde, 0xfb, 0xfd, 0xe6, 0xf7, 0x7e, 0xef, 0xcd, 0x78, 0xbc, 0xe8, 0xf1, 0x88, 0x05, 0x27, 0xe0,
	0x13, 0xdf, 0x81, 0x3a, 0xbc, 0x71, 0x8e, 0x88, 0x3f, 0x80, 0xfa, 0xc9, 0x56, 0x7d, 0x48, 0xd8,
	0x31, 0x88, 0xda, 0x88, 0x05, 0x22, 0xc0, 0x6b, 0x13, 0x52, 0xed, 0x96, 0x54, 0x3b, 0xd9, 0x2a,
	0x96, 0x9c, 0x80, 0x0f, 0x03, 0x5e, 0x27, 0xa1, 0x38, 0xaa, 0x9f, 0x6c, 0xd9, 0x20, 0xc8, 0x96,
	0x0c, 0xd4, 0xbe, 0x31, 0x6e, 0x13, 0x0e, 0x63, 0xdc, 0x09, 0xa8, 0x1f, 0xe3, 0xeb, 0x0a, 0xb7,
	0x64, 0x54, 0x57, 0x41, 0x0c, 0x3d, 0x1c, 0x04, 0x83, 0x40, 0xe5, 0xa3, 0x95, 0xca, 0x56, 0xfe,
	0xd2, 0xd0, 0xf2, 0x73, 0xe9, 0xac, 0xe1, 0x38, 0x41, 0xe8, 0x0b, 0xfc, 0x2d, 0x5a, 0x8a, 0xd4,
	0x2d, 0xa2, 0x62, 0x5d, 0x33, 0xb4, 0x6a, 0x7e, 0xdb, 0xa8, 0xc5, 0x62, 0xd2, 0x4c, 0x5c, 0xb9,
	0xd6, 0x24, 0x1c, 0xe2, 0x7d, 0xcd, 0x8d, 0xcb, 0xab, 0xb2, 0xf6, 0xf7, 0x55, 0x79, 0xf5, 0x2d,
	0x19, 0x7a, 0x3b, 0x95, 0xa4, 0x46, 0xc5, 0xcc, 0xdb, 0x13, 0x26, 0xde, 0x40, 0x39, 0x35, 0x0c,
	0x8b, 0xba, 0xfa, 0x9c, 0xa1, 0x55, 0x97, 0xcd, 0xac, 0x4a, 0xb4, 0x5d, 0x6c, 0xa2, 0x95, 0x18,
	0x74, 0x41, 0x10, 0xea, 0x71, 0x3d, 0x2d, 0x0d, 0x3c, 0xa9, 0xcd, 0x1e, 0x59, 0x4d, 0xb9, 0xdf,
	0x53, 0xe4, 0x66, 0xe6, 0xdd, 0x55, 0x39, 0x65, 0x2e, 0x0f, 0x93, 0xc9, 0x9d, 0xec, 0x0f, 0x17,
	0xe5, 0xd4, 0x4f, 0x17, 0xe5, 0x54, 0xe5, 0xfb, 0x71, 0xbb, 0x31, 0x86, 0x31, 0xca, 0xf8, 0x64,
	0x08, 0xb2, 0xcd, 0x9c, 0x29, 0xd7, 0xd8, 0x40, 0x79, 0x17, 0xb8, 0xc3, 0xe8, 0x48, 0xd0, 0xc0,
	0x97, 0x16, 0x73, 0x66, 0x32, 0x85, 0xcb, 0x28, 0x7f, 0x0a, 0x36, 0xa7, 0x02, 0xac, 0x90, 0x79,
	0xd2, 0x62, 0xce, 0x44, 0x71, 0xaa, 0xc7, 0x3c, 0xbc, 0x8e, 0xb2, 0xd4, 0x09, 0x7c, 0x2b, 0x64,
	0x54, 0xcf, 0x48, 0x74, 0x31, 0x8a, 0x7b, 0x8c, 0xee, 0x64, 0xfe, 0xbc, 0x28, 0x6b, 0x95, 0x5f,
	0x16, 0xd1, 0x82, 0x72, 0xf2, 0xfe, 0x3c, 0xb4, 0x7b, 0xe7, 0x31, 0xf7, 0x5f, 0xe7, 0x81, 0x0f,
	0xd0, 0x6a, 0x1f, 0xc0, 0x72, 0x18, 0x10, 0x01, 0x16, 0xe1, 0xc7, 0x56, 0xdf, 0x23, 0x42, 0x4f,
	0x1b, 0xe9, 0x6a, 0x7e, 0x7b, 0xfd, 0xf6, 0xa4, 0xa3, 0x23, 0x1b, 0x9f, 0xf4, 0x6e, 0x40, 0xfd,
	0x58, 0xac, 0xd0, 0x07, 0xd8, 0x95, 0x5b, 0x1b, 0xfc, 0x78, 0xdf, 0x23, 0x62, 0x4a, 0xcf, 0xa6,
	0xae, 0xd2, 0xcb, 0x7c, 0xac, 0x5e, 0x93, 0xba, 0x52, 0xef, 0x1b, 0x54, 0x8c, 0xf4, 0x38, 0x78,
	0x1e, 0x30, 0x8b, 0x83, 0x10, 0x1e, 0x0c, 0xc1, 0x17, 0x4a, 0x76, 0xfe, 0xc3, 0x64, 0xff, 0xdf,
	0x07, 0xe8, 0x48, 0x85, 0xce, 0x58, 0x40, 0xaa, 0x0f, 0xd0, 0x27, 0xb3, 0xd5, 0x19, 0x11, 0x34,
	0xe0, 0xfa, 0x82, 0xd4, 0x37, 0xee, 0x9a, 0xef, 0x3e, 0x80, 0x19, 0x11, 0xe3, 0x32, 0xeb, 0x33,
	0xca, 0x48, 0x9c, 0xe3, 0x57, 0x28, 0x02, 0x2d, 0x3b, 0x7c, 0x3b, 0xa3, 0x8b, 0xc5, 0x0f, 0xeb,
	0x62, 0xad, 0x0f, 0xd0, 0x8c, 0x04, 0xa6, 0x9a, 0x00, 0xb4, 0x31, 0x53, 0x3b, 0xee, 0x21, 0xfb,
	0x51, 0x3d, 0xe8, 0xff, 0x2e, 0x12, 0xb7, 0xf0, 0x14, 0x15, 0x88, 0xe3, 0xc0, 0x48, 0x50, 0x7f,
	0x60, 0x05, 0xcc, 0x05, 0xc6, 0xf5, 0x9c, 0xa1, 0x55, 0xb3, 0xe6, 0x83, 0x71, 0xfe, 0x85, 0x4c,
	0xe3, 0x6d, 0xf4, 0x88, 0x78, 0x5e, 0x70, 0x6a, 0x85, 0xfc, 0x3d, 0x4b, 0x3a, 0x92, 0xfc, 0x55,
	0x09, 0xf6, 0x78, 0xb2, 0x08, 0x3e, 0x40, 0xcb, 0x91, 0x0c, 0xe7, 0xd6, 0x80, 0x11, 0x5f, 0x70,
	0x3d, 0x2f, 0x7d, 0x3f, 0xbe, 0xcb, 0x77, 0x43, 0x92, 0xbf, 0x8a, 0xb8, 0xb1, 0xf5, 0x25, 0x32,
	0x49, 0x71, 0xbc, 0x89, 0x56, 0x19, 0xbc, 0xb6, 0x88, 0x10, 0x2c, 0x71, 0xbb, 0xf5, 0x25, 0x23,
	0x5d, 0xcd, 0x99, 0x05, 0x06, 0xaf, 0x1b, 0x42, 0xb0, 0xf1, 0xdd, 0x9d, 0x45, 0xb7, 0xa9, 0xab,
	0x2f, 0xcf, 0xa0, 0x37, 0xa9, 0x5b, 0xf9, 0x0e, 0x65, 0x6f, 0x07, 0x87, 0xbf, 0x44, 0xf3, 0x23,
	0x46, 0x1d, 0x88, 0x9f, 0xc7, 0x7b, 0xcf, 0x51, 0xb1, 0xf1, 0x16, 0x4a, 0xf7, 0x01, 0xe2, 0x9f,
	0xf0, 0xbd, 0x9b, 0x22, 0xee, 0x4e, 0xe6, 0xf6, 0xe1, 0xca, 0x27, 0xba, 0xc7, 0xdb, 0x68, 0x91,
	0xb8, 0x2e, 0x03, 0xce, 0xd5, 0xcb, 0xd5, 0xd4, 0x7f, 0xfb, 0x75, 0xf3, 0x61, 0xac, 0xd7, 0x50,
	0x48, 0x47, 0x30, 0xea, 0x0f, 0xcc, 0x5b, 0x22, 0xde, 0x43, 0xf9, 0x11, 0xb0, 0x21, 0xe5, 0x9c,
	0x06, 0x7e, 0xf4, 0x8e, 0xa4, 0xab, 0x2b, 0xdb, 0x95, 0xbb, 0x66, 0x7d, 0x38, 0xa6, 0x9a, 0xc9,
	0x6d, 0x9f, 0xfd, 0x3c, 0x87, 0xd0, 0x04, 0xc3, 0x9f, 0xa3, 0xb5, 0xc3, 0x96, 0xf9, 0xbc, 0xdd,
	0xe9, 0xb4, 0x5f, 0x1c, 0x58, 0xbd, 0x83, 0xce, 0x61, 0x6b, 0xb7, 0xbd, 0xdf, 0x6e, 0xed, 0x15,
	0x52, 0xc5, 0x07, 0x67, 0xe7, 0x46, 0x3e, 0xf4, 0xf9, 0x08, 0x1c, 0xda, 0xa7, 0xe0, 0xe2, 0x4f,
	0xd1, 0xff, 0x12, 0xe4, 0x4e, 0xab, 0xdb, 0x7d, 0xd6, 0x2a, 0x68, 0x45, 0x74, 0x76, 0x6e, 0x2c,
	0xa8, 0x1b, 0x33, 0x45, 0xd9, 0x6d, 0x1c, 0xec, 0xb6, 0x9e, 0x15, 0xe6, 0x14, 0xc5, 0x89, 0x4c,
	0x7a, 0xf8, 0x09, 0x5a, 0x4d, 0x50, 0x5e, 0xb6, 0xbb, 0x5f, 0xef, 0x99, 0x8d, 0x97, 0x85, 0x74,
	0x71, 0xe9, 0xec, 0xdc, 0xc8, 0x9e, 0x52, 0x71, 0xe4, 0x32, 0x72, 0x3a, 0xa5, 0xd4, 0x3b, 0xdc,
	0x6b, 0x74, 0x5b, 0x85, 0x8c, 0x52, 0x0a, 0x47, 0x2e, 0x11, 0x30, 0x65, 0x7e, 0xb2, 0xec, 0x14,
	0xe6, 0x95, 0xf9, 0x44, 0xe3, 0xf8, 0x29, 0x7a, 0x94, 0x20, 0x37, 0xba, 0x5d, 0xb3, 0xdd, 0xec,
	0x75, 0x5b, 0x9d, 0xc2, 0x42, 0x71, 0xe5, 0xec, 0xdc, 0x40, 0xd1, 0x35, 0xa2, 0x76, 0x28, 0x80,
	0x37, 0xe1, 0xdd, 0x75, 0x49, 0xbb, 0xbc, 0x2e, 0x69, 0x7f, 0x5c, 0x97, 0xb4, 0x1f, 0x6f, 0x4a,
	0xa9, 0xcb, 0x9b, 0x52, 0xea, 0xf7, 0x9b, 0x52, 0x0a, 0xad, 0xd3, 0xe0, 0x8e, 0x81, 0x1f, 0x6a,
	0xaf, 0x6a, 0x03, 0x2a, 0x8e, 0x42, 0xbb, 0xe6, 0x04, 0xc3, 0xfa, 0x84, 0xb4, 0x49, 0x83, 0x44,
	0x54, 0x7f, 0x33, 0xfe, 0xaa, 0xb0, 0x17, 0xe4, 0x7f, 0xf8, 0x17, 0xff, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x7a, 0x16, 0x37, 0xe4, 0x73, 0x08, 0x00, 0x00,
}

func (this *MarketDetails) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MarketDetails)
	if !ok {
		that2, ok := that.(MarketDetails)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.WebsiteUrl != that1.WebsiteUrl {
		return false
	}
	if this.IconUri != that1.IconUri {
		return false
	}
	return true
}
func (m *MarketAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MarketDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMarket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.MarketId != 0 {
		i = encodeVarintMarket(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x10
	}
	if m.BaseAccount != nil {
		{
			size, err := m.BaseAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMarket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IconUri) > 0 {
		i -= len(m.IconUri)
		copy(dAtA[i:], m.IconUri)
		i = encodeVarintMarket(dAtA, i, uint64(len(m.IconUri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WebsiteUrl) > 0 {
		i -= len(m.WebsiteUrl)
		copy(dAtA[i:], m.WebsiteUrl)
		i = encodeVarintMarket(dAtA, i, uint64(len(m.WebsiteUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMarket(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMarket(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Market) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReqAttrCreateBid) > 0 {
		for iNdEx := len(m.ReqAttrCreateBid) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReqAttrCreateBid[iNdEx])
			copy(dAtA[i:], m.ReqAttrCreateBid[iNdEx])
			i = encodeVarintMarket(dAtA, i, uint64(len(m.ReqAttrCreateBid[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ReqAttrCreateAsk) > 0 {
		for iNdEx := len(m.ReqAttrCreateAsk) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReqAttrCreateAsk[iNdEx])
			copy(dAtA[i:], m.ReqAttrCreateAsk[iNdEx])
			i = encodeVarintMarket(dAtA, i, uint64(len(m.ReqAttrCreateAsk[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AccessGrants) > 0 {
		for iNdEx := len(m.AccessGrants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccessGrants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.AllowUserSettlement {
		i--
		if m.AllowUserSettlement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.AcceptingOrders {
		i--
		if m.AcceptingOrders {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.FeeBuyerSettlementRatios) > 0 {
		for iNdEx := len(m.FeeBuyerSettlementRatios) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeBuyerSettlementRatios[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FeeBuyerSettlementFlat) > 0 {
		for iNdEx := len(m.FeeBuyerSettlementFlat) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeBuyerSettlementFlat[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.FeeSellerSettlementRatios) > 0 {
		for iNdEx := len(m.FeeSellerSettlementRatios) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeSellerSettlementRatios[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.FeeSellerSettlementFlat) > 0 {
		for iNdEx := len(m.FeeSellerSettlementFlat) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeSellerSettlementFlat[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.FeeCreateBidFlat) > 0 {
		for iNdEx := len(m.FeeCreateBidFlat) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeCreateBidFlat[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.FeeCreateAskFlat) > 0 {
		for iNdEx := len(m.FeeCreateAskFlat) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeCreateAskFlat[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.MarketDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMarket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MarketId != 0 {
		i = encodeVarintMarket(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeRatio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeRatio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeRatio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMarket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMarket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AccessGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		dAtA7 := make([]byte, len(m.Permissions)*10)
		var j6 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintMarket(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMarket(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMarket(dAtA []byte, offset int, v uint64) int {
	offset -= sovMarket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MarketAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseAccount != nil {
		l = m.BaseAccount.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovMarket(uint64(m.MarketId))
	}
	l = m.MarketDetails.Size()
	n += 1 + l + sovMarket(uint64(l))
	return n
}

func (m *MarketDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.WebsiteUrl)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.IconUri)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}

func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovMarket(uint64(m.MarketId))
	}
	l = m.MarketDetails.Size()
	n += 1 + l + sovMarket(uint64(l))
	if len(m.FeeCreateAskFlat) > 0 {
		for _, e := range m.FeeCreateAskFlat {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.FeeCreateBidFlat) > 0 {
		for _, e := range m.FeeCreateBidFlat {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.FeeSellerSettlementFlat) > 0 {
		for _, e := range m.FeeSellerSettlementFlat {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.FeeSellerSettlementRatios) > 0 {
		for _, e := range m.FeeSellerSettlementRatios {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.FeeBuyerSettlementFlat) > 0 {
		for _, e := range m.FeeBuyerSettlementFlat {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.FeeBuyerSettlementRatios) > 0 {
		for _, e := range m.FeeBuyerSettlementRatios {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.AcceptingOrders {
		n += 2
	}
	if m.AllowUserSettlement {
		n += 2
	}
	if len(m.AccessGrants) > 0 {
		for _, e := range m.AccessGrants {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.ReqAttrCreateAsk) > 0 {
		for _, s := range m.ReqAttrCreateAsk {
			l = len(s)
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.ReqAttrCreateBid) > 0 {
		for _, s := range m.ReqAttrCreateBid {
			l = len(s)
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	return n
}

func (m *FeeRatio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Price.Size()
	n += 1 + l + sovMarket(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovMarket(uint64(l))
	return n
}

func (m *AccessGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovMarket(uint64(e))
		}
		n += 1 + sovMarket(uint64(l)) + l
	}
	return n
}

func sovMarket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMarket(x uint64) (n int) {
	return sovMarket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MarketAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseAccount == nil {
				m.BaseAccount = &types.BaseAccount{}
			}
			if err := m.BaseAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarketDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebsiteUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebsiteUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarketDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCreateAskFlat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCreateAskFlat = append(m.FeeCreateAskFlat, types1.Coin{})
			if err := m.FeeCreateAskFlat[len(m.FeeCreateAskFlat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCreateBidFlat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCreateBidFlat = append(m.FeeCreateBidFlat, types1.Coin{})
			if err := m.FeeCreateBidFlat[len(m.FeeCreateBidFlat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSellerSettlementFlat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeSellerSettlementFlat = append(m.FeeSellerSettlementFlat, types1.Coin{})
			if err := m.FeeSellerSettlementFlat[len(m.FeeSellerSettlementFlat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSellerSettlementRatios", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeSellerSettlementRatios = append(m.FeeSellerSettlementRatios, FeeRatio{})
			if err := m.FeeSellerSettlementRatios[len(m.FeeSellerSettlementRatios)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBuyerSettlementFlat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeBuyerSettlementFlat = append(m.FeeBuyerSettlementFlat, types1.Coin{})
			if err := m.FeeBuyerSettlementFlat[len(m.FeeBuyerSettlementFlat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBuyerSettlementRatios", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeBuyerSettlementRatios = append(m.FeeBuyerSettlementRatios, FeeRatio{})
			if err := m.FeeBuyerSettlementRatios[len(m.FeeBuyerSettlementRatios)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptingOrders", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcceptingOrders = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowUserSettlement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowUserSettlement = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessGrants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessGrants = append(m.AccessGrants, AccessGrant{})
			if err := m.AccessGrants[len(m.AccessGrants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqAttrCreateAsk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqAttrCreateAsk = append(m.ReqAttrCreateAsk, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqAttrCreateBid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqAttrCreateBid = append(m.ReqAttrCreateBid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeRatio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeRatio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeRatio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Permission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMarket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Permission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMarket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMarket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMarket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]Permission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Permission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMarket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Permission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMarket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMarket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMarket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMarket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMarket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMarket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMarket = fmt.Errorf("proto: unexpected end of group")
)
