// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/exchange/v1/events.proto

package exchange

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventOrderCreated is an event emitted when an order is created.
type EventOrderCreated struct {
	// order_id is the numerical identifier of the order created.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// order_type is the type of order, e.g. "ask" or "bid".
	OrderType string `protobuf:"bytes,2,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
}

func (m *EventOrderCreated) Reset()         { *m = EventOrderCreated{} }
func (m *EventOrderCreated) String() string { return proto.CompactTextString(m) }
func (*EventOrderCreated) ProtoMessage()    {}
func (*EventOrderCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{0}
}
func (m *EventOrderCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderCreated.Merge(m, src)
}
func (m *EventOrderCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderCreated proto.InternalMessageInfo

func (m *EventOrderCreated) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderCreated) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

// EventOrderCancelled is an event emitted when an order is cancelled.
type EventOrderCancelled struct {
	// order_id is the numerical identifier of the order created.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// cancelled_by is the account that triggered the cancellation of the order.
	CancelledBy string `protobuf:"bytes,2,opt,name=cancelled_by,json=cancelledBy,proto3" json:"cancelled_by,omitempty"`
}

func (m *EventOrderCancelled) Reset()         { *m = EventOrderCancelled{} }
func (m *EventOrderCancelled) String() string { return proto.CompactTextString(m) }
func (*EventOrderCancelled) ProtoMessage()    {}
func (*EventOrderCancelled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{1}
}
func (m *EventOrderCancelled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderCancelled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderCancelled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderCancelled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderCancelled.Merge(m, src)
}
func (m *EventOrderCancelled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderCancelled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderCancelled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderCancelled proto.InternalMessageInfo

func (m *EventOrderCancelled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderCancelled) GetCancelledBy() string {
	if m != nil {
		return m.CancelledBy
	}
	return ""
}

// EventOrderFilled is an event emitted when an order has been filled in full.
// This event is also used for orders that were previously partially filled, but have now been filled in full.
type EventOrderFilled struct {
	// order_id is the numerical identifier of the order created.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *EventOrderFilled) Reset()         { *m = EventOrderFilled{} }
func (m *EventOrderFilled) String() string { return proto.CompactTextString(m) }
func (*EventOrderFilled) ProtoMessage()    {}
func (*EventOrderFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{2}
}
func (m *EventOrderFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderFilled.Merge(m, src)
}
func (m *EventOrderFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderFilled proto.InternalMessageInfo

func (m *EventOrderFilled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

// EventOrderPartiallyFilled is an event emitted when an order filled in part and still has more left to fill.
type EventOrderPartiallyFilled struct {
	// order_id is the numerical identifier of the order created.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// amount_filled is the coins amount string of assets that were filled (and removed from the order).
	AssetsFilled string `protobuf:"bytes,2,opt,name=assets_filled,json=assetsFilled,proto3" json:"assets_filled,omitempty"`
	// fees_filled is the coins amount string of fees removed from the order.
	FeesFilled string `protobuf:"bytes,3,opt,name=fees_filled,json=feesFilled,proto3" json:"fees_filled,omitempty"`
}

func (m *EventOrderPartiallyFilled) Reset()         { *m = EventOrderPartiallyFilled{} }
func (m *EventOrderPartiallyFilled) String() string { return proto.CompactTextString(m) }
func (*EventOrderPartiallyFilled) ProtoMessage()    {}
func (*EventOrderPartiallyFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{3}
}
func (m *EventOrderPartiallyFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderPartiallyFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderPartiallyFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderPartiallyFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderPartiallyFilled.Merge(m, src)
}
func (m *EventOrderPartiallyFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderPartiallyFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderPartiallyFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderPartiallyFilled proto.InternalMessageInfo

func (m *EventOrderPartiallyFilled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderPartiallyFilled) GetAssetsFilled() string {
	if m != nil {
		return m.AssetsFilled
	}
	return ""
}

func (m *EventOrderPartiallyFilled) GetFeesFilled() string {
	if m != nil {
		return m.FeesFilled
	}
	return ""
}

// EventMarketWithdraw is an event emitted when a withdrawal of a market's collected fees is made.
type EventMarketWithdraw struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount_withdrawn is the coins amount string of funds withdrawn from the market account.
	AmountWithdrawn string `protobuf:"bytes,2,opt,name=amount_withdrawn,json=amountWithdrawn,proto3" json:"amount_withdrawn,omitempty"`
	// destination is the account that received the funds.
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	// withdrawn_by is the account that requested the withdrawal.
	WithdrawnBy string `protobuf:"bytes,4,opt,name=withdrawn_by,json=withdrawnBy,proto3" json:"withdrawn_by,omitempty"`
}

func (m *EventMarketWithdraw) Reset()         { *m = EventMarketWithdraw{} }
func (m *EventMarketWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventMarketWithdraw) ProtoMessage()    {}
func (*EventMarketWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{4}
}
func (m *EventMarketWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketWithdraw.Merge(m, src)
}
func (m *EventMarketWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketWithdraw proto.InternalMessageInfo

func (m *EventMarketWithdraw) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketWithdraw) GetAmountWithdrawn() string {
	if m != nil {
		return m.AmountWithdrawn
	}
	return ""
}

func (m *EventMarketWithdraw) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *EventMarketWithdraw) GetWithdrawnBy() string {
	if m != nil {
		return m.WithdrawnBy
	}
	return ""
}

// EventMarketDetailsUpdated is an event emitted when a market's details are updated.
type EventMarketDetailsUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the details.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketDetailsUpdated) Reset()         { *m = EventMarketDetailsUpdated{} }
func (m *EventMarketDetailsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketDetailsUpdated) ProtoMessage()    {}
func (*EventMarketDetailsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{5}
}
func (m *EventMarketDetailsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketDetailsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketDetailsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketDetailsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketDetailsUpdated.Merge(m, src)
}
func (m *EventMarketDetailsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketDetailsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketDetailsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketDetailsUpdated proto.InternalMessageInfo

func (m *EventMarketDetailsUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketDetailsUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketEnabled is an event emitted when a market is enabled.
type EventMarketEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that enabled the market.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketEnabled) Reset()         { *m = EventMarketEnabled{} }
func (m *EventMarketEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketEnabled) ProtoMessage()    {}
func (*EventMarketEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{6}
}
func (m *EventMarketEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketEnabled.Merge(m, src)
}
func (m *EventMarketEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketEnabled proto.InternalMessageInfo

func (m *EventMarketEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketDisabled is an event emitted when a market is disabled.
type EventMarketDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that disabled the market.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketDisabled) Reset()         { *m = EventMarketDisabled{} }
func (m *EventMarketDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketDisabled) ProtoMessage()    {}
func (*EventMarketDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{7}
}
func (m *EventMarketDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketDisabled.Merge(m, src)
}
func (m *EventMarketDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketDisabled proto.InternalMessageInfo

func (m *EventMarketDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketUserSettleUpdated is an event emitted when a market's self_settle option is updated.
type EventMarketUserSettleUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the self_settle option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketUserSettleUpdated) Reset()         { *m = EventMarketUserSettleUpdated{} }
func (m *EventMarketUserSettleUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketUserSettleUpdated) ProtoMessage()    {}
func (*EventMarketUserSettleUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{8}
}
func (m *EventMarketUserSettleUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketUserSettleUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketUserSettleUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketUserSettleUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketUserSettleUpdated.Merge(m, src)
}
func (m *EventMarketUserSettleUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketUserSettleUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketUserSettleUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketUserSettleUpdated proto.InternalMessageInfo

func (m *EventMarketUserSettleUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketUserSettleUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketPermissionsUpdated is an event emitted when a market's permissions are updated.
type EventMarketPermissionsUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the permissions.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketPermissionsUpdated) Reset()         { *m = EventMarketPermissionsUpdated{} }
func (m *EventMarketPermissionsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketPermissionsUpdated) ProtoMessage()    {}
func (*EventMarketPermissionsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{9}
}
func (m *EventMarketPermissionsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketPermissionsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketPermissionsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketPermissionsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketPermissionsUpdated.Merge(m, src)
}
func (m *EventMarketPermissionsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketPermissionsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketPermissionsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketPermissionsUpdated proto.InternalMessageInfo

func (m *EventMarketPermissionsUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketPermissionsUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketReqAttrUpdated is an event emitted when a market's required attributes are updated.
type EventMarketReqAttrUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the required attributes.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketReqAttrUpdated) Reset()         { *m = EventMarketReqAttrUpdated{} }
func (m *EventMarketReqAttrUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketReqAttrUpdated) ProtoMessage()    {}
func (*EventMarketReqAttrUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{10}
}
func (m *EventMarketReqAttrUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketReqAttrUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketReqAttrUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketReqAttrUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketReqAttrUpdated.Merge(m, src)
}
func (m *EventMarketReqAttrUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketReqAttrUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketReqAttrUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketReqAttrUpdated proto.InternalMessageInfo

func (m *EventMarketReqAttrUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketReqAttrUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventCreateMarketSubmitted is an event emitted during CreateMarket indicating that a governance
// proposal was submitted to create a market.
type EventCreateMarketSubmitted struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// proposal_id is the identifier of the governance proposal that was submitted to create the market.
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// submitted_by is the account that requested the creation of the market.
	SubmittedBy string `protobuf:"bytes,3,opt,name=submitted_by,json=submittedBy,proto3" json:"submitted_by,omitempty"`
}

func (m *EventCreateMarketSubmitted) Reset()         { *m = EventCreateMarketSubmitted{} }
func (m *EventCreateMarketSubmitted) String() string { return proto.CompactTextString(m) }
func (*EventCreateMarketSubmitted) ProtoMessage()    {}
func (*EventCreateMarketSubmitted) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{11}
}
func (m *EventCreateMarketSubmitted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreateMarketSubmitted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreateMarketSubmitted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreateMarketSubmitted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreateMarketSubmitted.Merge(m, src)
}
func (m *EventCreateMarketSubmitted) XXX_Size() int {
	return m.Size()
}
func (m *EventCreateMarketSubmitted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreateMarketSubmitted.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreateMarketSubmitted proto.InternalMessageInfo

func (m *EventCreateMarketSubmitted) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventCreateMarketSubmitted) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventCreateMarketSubmitted) GetSubmittedBy() string {
	if m != nil {
		return m.SubmittedBy
	}
	return ""
}

// EventMarketCreated is an event emitted when a market has been created.
type EventMarketCreated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *EventMarketCreated) Reset()         { *m = EventMarketCreated{} }
func (m *EventMarketCreated) String() string { return proto.CompactTextString(m) }
func (*EventMarketCreated) ProtoMessage()    {}
func (*EventMarketCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{12}
}
func (m *EventMarketCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketCreated.Merge(m, src)
}
func (m *EventMarketCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketCreated proto.InternalMessageInfo

func (m *EventMarketCreated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// EventMarketFeesUpdated is an event emitted when a market's fees have been updated.
type EventMarketFeesUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *EventMarketFeesUpdated) Reset()         { *m = EventMarketFeesUpdated{} }
func (m *EventMarketFeesUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketFeesUpdated) ProtoMessage()    {}
func (*EventMarketFeesUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{13}
}
func (m *EventMarketFeesUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketFeesUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketFeesUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketFeesUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketFeesUpdated.Merge(m, src)
}
func (m *EventMarketFeesUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketFeesUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketFeesUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketFeesUpdated proto.InternalMessageInfo

func (m *EventMarketFeesUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// EventParamsUpdated is an event emitted when the exchange module's params have been updated.
type EventParamsUpdated struct {
}

func (m *EventParamsUpdated) Reset()         { *m = EventParamsUpdated{} }
func (m *EventParamsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventParamsUpdated) ProtoMessage()    {}
func (*EventParamsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{14}
}
func (m *EventParamsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventParamsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventParamsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventParamsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventParamsUpdated.Merge(m, src)
}
func (m *EventParamsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventParamsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventParamsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventParamsUpdated proto.InternalMessageInfo

func init() {
	proto.RegisterType((*EventOrderCreated)(nil), "provenance.exchange.v1.EventOrderCreated")
	proto.RegisterType((*EventOrderCancelled)(nil), "provenance.exchange.v1.EventOrderCancelled")
	proto.RegisterType((*EventOrderFilled)(nil), "provenance.exchange.v1.EventOrderFilled")
	proto.RegisterType((*EventOrderPartiallyFilled)(nil), "provenance.exchange.v1.EventOrderPartiallyFilled")
	proto.RegisterType((*EventMarketWithdraw)(nil), "provenance.exchange.v1.EventMarketWithdraw")
	proto.RegisterType((*EventMarketDetailsUpdated)(nil), "provenance.exchange.v1.EventMarketDetailsUpdated")
	proto.RegisterType((*EventMarketEnabled)(nil), "provenance.exchange.v1.EventMarketEnabled")
	proto.RegisterType((*EventMarketDisabled)(nil), "provenance.exchange.v1.EventMarketDisabled")
	proto.RegisterType((*EventMarketUserSettleUpdated)(nil), "provenance.exchange.v1.EventMarketUserSettleUpdated")
	proto.RegisterType((*EventMarketPermissionsUpdated)(nil), "provenance.exchange.v1.EventMarketPermissionsUpdated")
	proto.RegisterType((*EventMarketReqAttrUpdated)(nil), "provenance.exchange.v1.EventMarketReqAttrUpdated")
	proto.RegisterType((*EventCreateMarketSubmitted)(nil), "provenance.exchange.v1.EventCreateMarketSubmitted")
	proto.RegisterType((*EventMarketCreated)(nil), "provenance.exchange.v1.EventMarketCreated")
	proto.RegisterType((*EventMarketFeesUpdated)(nil), "provenance.exchange.v1.EventMarketFeesUpdated")
	proto.RegisterType((*EventParamsUpdated)(nil), "provenance.exchange.v1.EventParamsUpdated")
}

func init() {
	proto.RegisterFile("provenance/exchange/v1/events.proto", fileDescriptor_c1b69385a348cffa)
}

var fileDescriptor_c1b69385a348cffa = []byte{
	// 586 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x95, 0xc1, 0x4e, 0xdb, 0x4c,
	0x10, 0xc7, 0x31, 0x1f, 0xfa, 0x4a, 0x26, 0xa0, 0x52, 0x17, 0x21, 0x42, 0x8b, 0x41, 0xe6, 0x42,
	0x0f, 0xd8, 0x8a, 0xaa, 0xaa, 0x52, 0x7b, 0xc2, 0x05, 0x24, 0x0e, 0xa8, 0x51, 0x52, 0x54, 0xa9,
	0x97, 0x68, 0x13, 0x0f, 0xc9, 0x16, 0x7b, 0xd7, 0xec, 0x6e, 0x02, 0x96, 0xfa, 0x10, 0xbd, 0xf5,
	0x45, 0xfa, 0x10, 0x3d, 0xa2, 0x1e, 0xaa, 0x1e, 0xab, 0xe4, 0x45, 0x2a, 0x7b, 0x6d, 0xc7, 0x91,
	0xaa, 0x84, 0x4b, 0x8e, 0x33, 0xfe, 0xcd, 0xfc, 0x67, 0x67, 0xd6, 0xb3, 0x70, 0x10, 0x09, 0x3e,
	0x44, 0x46, 0x58, 0x17, 0x5d, 0xbc, 0xeb, 0xf6, 0x09, 0xeb, 0xa1, 0x3b, 0xac, 0xbb, 0x38, 0x44,
	0xa6, 0xa4, 0x13, 0x09, 0xae, 0xb8, 0xb9, 0x35, 0x81, 0x9c, 0x1c, 0x72, 0x86, 0xf5, 0x9d, 0x5a,
	0x97, 0xcb, 0x90, 0xcb, 0x76, 0x4a, 0xb9, 0xda, 0xd0, 0x21, 0xf6, 0x05, 0x3c, 0x39, 0x4d, 0x52,
	0xbc, 0x17, 0x3e, 0x8a, 0x77, 0x02, 0x89, 0x42, 0xdf, 0xac, 0xc1, 0x2a, 0x4f, 0xec, 0x36, 0xf5,
	0xb7, 0x8d, 0x7d, 0xe3, 0x70, 0xa5, 0xf9, 0x28, 0xb5, 0xcf, 0x7d, 0x73, 0x17, 0x40, 0x7f, 0x52,
	0x71, 0x84, 0xdb, 0xcb, 0xfb, 0xc6, 0x61, 0xa5, 0x59, 0x49, 0x3d, 0x1f, 0xe2, 0x08, 0xed, 0x10,
	0x9e, 0x96, 0xd2, 0x25, 0x85, 0x04, 0xc1, 0xec, 0x84, 0x6f, 0x61, 0xad, 0x9b, 0x73, 0xed, 0x4e,
	0xac, 0x53, 0x7a, 0xdb, 0x3f, 0xbf, 0x1f, 0x6d, 0x66, 0x85, 0x1e, 0xfb, 0xbe, 0x40, 0x29, 0x5b,
	0x4a, 0x50, 0xd6, 0x6b, 0x56, 0x0b, 0xda, 0x8b, 0xed, 0x23, 0xd8, 0x98, 0xc8, 0x9d, 0xd1, 0x39,
	0x5a, 0xf6, 0x17, 0xa8, 0x4d, 0xf0, 0x06, 0x11, 0x8a, 0x92, 0x20, 0x88, 0xe7, 0xc6, 0x99, 0x07,
	0xb0, 0x4e, 0xa4, 0x44, 0x25, 0xdb, 0x57, 0x29, 0x9b, 0x9d, 0x7b, 0x4d, 0x3b, 0xb3, 0xf8, 0x3d,
	0xa8, 0x5e, 0x21, 0x16, 0xc8, 0x7f, 0x29, 0x02, 0x89, 0x4b, 0x03, 0xf6, 0x2f, 0x23, 0x6b, 0xce,
	0x05, 0x11, 0xd7, 0xa8, 0x3e, 0x52, 0xd5, 0xf7, 0x05, 0xb9, 0x35, 0x9f, 0x41, 0x25, 0x4c, 0x3d,
	0xb9, 0xf2, 0x7a, 0x73, 0x55, 0x3b, 0xce, 0x7d, 0xf3, 0x05, 0x6c, 0x90, 0x90, 0x0f, 0x98, 0x6a,
	0xdf, 0x66, 0x3c, 0xcb, 0xd4, 0x1f, 0x6b, 0x7f, 0x9e, 0x86, 0x99, 0x6f, 0xa0, 0xea, 0xa3, 0x54,
	0x94, 0x11, 0x45, 0x39, 0xd3, 0x05, 0xcc, 0x6a, 0x64, 0x09, 0x4e, 0xa6, 0x50, 0xe4, 0x4f, 0xa6,
	0xb0, 0x32, 0x2f, 0xb8, 0xa0, 0xbd, 0xd8, 0xbe, 0xc9, 0xda, 0xaa, 0xcf, 0x75, 0x82, 0x8a, 0xd0,
	0x40, 0x5e, 0x46, 0x7e, 0x7a, 0x97, 0x66, 0x9e, 0xee, 0x35, 0xc0, 0x40, 0x73, 0x0f, 0x19, 0x7d,
	0x25, 0x63, 0xbd, 0xd8, 0xfe, 0x0c, 0x66, 0x49, 0xf2, 0x94, 0x91, 0x4e, 0xb0, 0x30, 0xad, 0xeb,
	0xa9, 0xb1, 0x9d, 0x50, 0xb9, 0x48, 0x31, 0x05, 0xcf, 0x4b, 0x62, 0x97, 0x12, 0x45, 0x0b, 0x95,
	0x0a, 0x70, 0xb1, 0xed, 0x1c, 0xc0, 0x6e, 0x49, 0xb5, 0x81, 0x22, 0xa4, 0x52, 0x52, 0xce, 0x16,
	0x3c, 0xc5, 0xe9, 0x8b, 0xd3, 0xc4, 0x9b, 0x63, 0xa5, 0xc4, 0x62, 0x25, 0xbf, 0x19, 0xb0, 0x93,
	0x6a, 0xea, 0x5d, 0xa7, 0x95, 0x5b, 0x83, 0x4e, 0x48, 0xd5, 0x5c, 0xd1, 0x3d, 0xa8, 0x46, 0x82,
	0x47, 0x5c, 0x92, 0x20, 0xf9, 0xbc, 0x9c, 0x2e, 0x09, 0xc8, 0x5d, 0x7a, 0x97, 0xc9, 0x3c, 0x55,
	0x52, 0xd7, 0xdc, 0x5f, 0xb0, 0xa0, 0xbd, 0xd8, 0xae, 0x4f, 0x5d, 0xe9, 0x7c, 0x15, 0xcf, 0x2a,
	0xc8, 0x7e, 0x05, 0x5b, 0xa5, 0x90, 0x33, 0xc4, 0x07, 0xcd, 0xcb, 0xde, 0xcc, 0x94, 0x1a, 0x44,
	0x90, 0x30, 0x0f, 0xf1, 0xf0, 0xc7, 0xc8, 0x32, 0xee, 0x47, 0x96, 0xf1, 0x67, 0x64, 0x19, 0x5f,
	0xc7, 0xd6, 0xd2, 0xfd, 0xd8, 0x5a, 0xfa, 0x3d, 0xb6, 0x96, 0xa0, 0x46, 0xb9, 0xf3, 0xef, 0x97,
	0xa5, 0x61, 0x7c, 0x72, 0x7a, 0x54, 0xf5, 0x07, 0x1d, 0xa7, 0xcb, 0x43, 0x77, 0x02, 0x1d, 0x51,
	0x5e, 0xb2, 0xdc, 0xbb, 0xe2, 0xcd, 0xea, 0xfc, 0x9f, 0xbe, 0x3b, 0x2f, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0x33, 0xb3, 0x39, 0x5f, 0xd1, 0x06, 0x00, 0x00,
}

func (m *EventOrderCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderCancelled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderCancelled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderCancelled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledBy) > 0 {
		i -= len(m.CancelledBy)
		copy(dAtA[i:], m.CancelledBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CancelledBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderPartiallyFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderPartiallyFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderPartiallyFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeesFilled) > 0 {
		i -= len(m.FeesFilled)
		copy(dAtA[i:], m.FeesFilled)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FeesFilled)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetsFilled) > 0 {
		i -= len(m.AssetsFilled)
		copy(dAtA[i:], m.AssetsFilled)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetsFilled)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WithdrawnBy) > 0 {
		i -= len(m.WithdrawnBy)
		copy(dAtA[i:], m.WithdrawnBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.WithdrawnBy)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AmountWithdrawn) > 0 {
		i -= len(m.AmountWithdrawn)
		copy(dAtA[i:], m.AmountWithdrawn)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AmountWithdrawn)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketDetailsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketDetailsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketDetailsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketUserSettleUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketUserSettleUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketUserSettleUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketPermissionsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketPermissionsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketPermissionsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketReqAttrUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketReqAttrUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketReqAttrUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventCreateMarketSubmitted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreateMarketSubmitted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreateMarketSubmitted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubmittedBy) > 0 {
		i -= len(m.SubmittedBy)
		copy(dAtA[i:], m.SubmittedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SubmittedBy)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketFeesUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketFeesUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketFeesUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventParamsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventParamsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventParamsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventOrderCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderCancelled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.CancelledBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	return n
}

func (m *EventOrderPartiallyFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.AssetsFilled)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.FeesFilled)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.AmountWithdrawn)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.WithdrawnBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketDetailsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketUserSettleUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketPermissionsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketReqAttrUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventCreateMarketSubmitted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	l = len(m.SubmittedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	return n
}

func (m *EventMarketFeesUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	return n
}

func (m *EventParamsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventOrderCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderCancelled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderCancelled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderCancelled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderPartiallyFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderPartiallyFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderPartiallyFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetsFilled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetsFilled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesFilled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeesFilled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountWithdrawn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawnBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketDetailsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketDetailsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketDetailsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketUserSettleUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketUserSettleUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketUserSettleUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketPermissionsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketPermissionsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketPermissionsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketReqAttrUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketReqAttrUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketReqAttrUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCreateMarketSubmitted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreateMarketSubmitted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreateMarketSubmitted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubmittedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketFeesUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketFeesUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketFeesUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventParamsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventParamsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventParamsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
