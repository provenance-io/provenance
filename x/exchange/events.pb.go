// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/exchange/v1/events.proto

package exchange

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventOrderCreated is an event emitted when an order is created.
type EventOrderCreated struct {
	// order_id is the numerical identifier of the order created.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// order_type is the type of order, e.g. "ask" or "bid".
	OrderType string `protobuf:"bytes,2,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
}

func (m *EventOrderCreated) Reset()         { *m = EventOrderCreated{} }
func (m *EventOrderCreated) String() string { return proto.CompactTextString(m) }
func (*EventOrderCreated) ProtoMessage()    {}
func (*EventOrderCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{0}
}
func (m *EventOrderCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderCreated.Merge(m, src)
}
func (m *EventOrderCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderCreated proto.InternalMessageInfo

func (m *EventOrderCreated) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderCreated) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

// EventOrderCancelled is an event emitted when an order is cancelled.
type EventOrderCancelled struct {
	// order_id is the numerical identifier of the order cancelled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// cancelled_by is the account that triggered the cancellation of the order.
	CancelledBy string `protobuf:"bytes,2,opt,name=cancelled_by,json=cancelledBy,proto3" json:"cancelled_by,omitempty"`
}

func (m *EventOrderCancelled) Reset()         { *m = EventOrderCancelled{} }
func (m *EventOrderCancelled) String() string { return proto.CompactTextString(m) }
func (*EventOrderCancelled) ProtoMessage()    {}
func (*EventOrderCancelled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{1}
}
func (m *EventOrderCancelled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderCancelled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderCancelled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderCancelled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderCancelled.Merge(m, src)
}
func (m *EventOrderCancelled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderCancelled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderCancelled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderCancelled proto.InternalMessageInfo

func (m *EventOrderCancelled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderCancelled) GetCancelledBy() string {
	if m != nil {
		return m.CancelledBy
	}
	return ""
}

// EventOrderFilled is an event emitted when an order has been filled in full.
// This event is also used for orders that were previously partially filled, but have now been filled in full.
type EventOrderFilled struct {
	// order_id is the numerical identifier of the order filled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// assets is the coins amount string of assets bought/sold for this order.
	Assets string `protobuf:"bytes,2,opt,name=assets,proto3" json:"assets,omitempty"`
	// price is the coins amount string of the price payed/received for this order.
	Price string `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// fees is the coins amount string of settlement fees paid with this order.
	Fees string `protobuf:"bytes,4,opt,name=fees,proto3" json:"fees,omitempty"`
}

func (m *EventOrderFilled) Reset()         { *m = EventOrderFilled{} }
func (m *EventOrderFilled) String() string { return proto.CompactTextString(m) }
func (*EventOrderFilled) ProtoMessage()    {}
func (*EventOrderFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{2}
}
func (m *EventOrderFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderFilled.Merge(m, src)
}
func (m *EventOrderFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderFilled proto.InternalMessageInfo

func (m *EventOrderFilled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderFilled) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventOrderFilled) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *EventOrderFilled) GetFees() string {
	if m != nil {
		return m.Fees
	}
	return ""
}

// EventOrderPartiallyFilled is an event emitted when an order filled in part and still has more left to fill.
type EventOrderPartiallyFilled struct {
	// order_id is the numerical identifier of the order partially filled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// assets is the coins amount string of assets that were filled and removed from the order.
	Assets string `protobuf:"bytes,2,opt,name=assets,proto3" json:"assets,omitempty"`
	// price is the coins amount string of the price payed/received for this order.
	// For ask orders, this might be more than the amount that was removed from the order's price.
	Price string `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// fees is the coins amount string of settlement fees paid with this partial order.
	// For ask orders, this might be more than the amount that was removed from the order's settlement fees.
	Fees string `protobuf:"bytes,4,opt,name=fees,proto3" json:"fees,omitempty"`
}

func (m *EventOrderPartiallyFilled) Reset()         { *m = EventOrderPartiallyFilled{} }
func (m *EventOrderPartiallyFilled) String() string { return proto.CompactTextString(m) }
func (*EventOrderPartiallyFilled) ProtoMessage()    {}
func (*EventOrderPartiallyFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{3}
}
func (m *EventOrderPartiallyFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderPartiallyFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderPartiallyFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderPartiallyFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderPartiallyFilled.Merge(m, src)
}
func (m *EventOrderPartiallyFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderPartiallyFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderPartiallyFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderPartiallyFilled proto.InternalMessageInfo

func (m *EventOrderPartiallyFilled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderPartiallyFilled) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventOrderPartiallyFilled) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *EventOrderPartiallyFilled) GetFees() string {
	if m != nil {
		return m.Fees
	}
	return ""
}

// EventMarketWithdraw is an event emitted when a withdrawal of a market's collected fees is made.
type EventMarketWithdraw struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount is the coins amount string of funds withdrawn from the market account.
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// destination is the account that received the funds.
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	// withdrawn_by is the account that requested the withdrawal.
	WithdrawnBy string `protobuf:"bytes,4,opt,name=withdrawn_by,json=withdrawnBy,proto3" json:"withdrawn_by,omitempty"`
}

func (m *EventMarketWithdraw) Reset()         { *m = EventMarketWithdraw{} }
func (m *EventMarketWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventMarketWithdraw) ProtoMessage()    {}
func (*EventMarketWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{4}
}
func (m *EventMarketWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketWithdraw.Merge(m, src)
}
func (m *EventMarketWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketWithdraw proto.InternalMessageInfo

func (m *EventMarketWithdraw) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketWithdraw) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EventMarketWithdraw) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *EventMarketWithdraw) GetWithdrawnBy() string {
	if m != nil {
		return m.WithdrawnBy
	}
	return ""
}

// EventMarketDetailsUpdated is an event emitted when a market's details are updated.
type EventMarketDetailsUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the details.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketDetailsUpdated) Reset()         { *m = EventMarketDetailsUpdated{} }
func (m *EventMarketDetailsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketDetailsUpdated) ProtoMessage()    {}
func (*EventMarketDetailsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{5}
}
func (m *EventMarketDetailsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketDetailsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketDetailsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketDetailsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketDetailsUpdated.Merge(m, src)
}
func (m *EventMarketDetailsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketDetailsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketDetailsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketDetailsUpdated proto.InternalMessageInfo

func (m *EventMarketDetailsUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketDetailsUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketEnabled is an event emitted when a market is enabled.
type EventMarketEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that enabled the market.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketEnabled) Reset()         { *m = EventMarketEnabled{} }
func (m *EventMarketEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketEnabled) ProtoMessage()    {}
func (*EventMarketEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{6}
}
func (m *EventMarketEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketEnabled.Merge(m, src)
}
func (m *EventMarketEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketEnabled proto.InternalMessageInfo

func (m *EventMarketEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketDisabled is an event emitted when a market is disabled.
type EventMarketDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that disabled the market.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketDisabled) Reset()         { *m = EventMarketDisabled{} }
func (m *EventMarketDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketDisabled) ProtoMessage()    {}
func (*EventMarketDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{7}
}
func (m *EventMarketDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketDisabled.Merge(m, src)
}
func (m *EventMarketDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketDisabled proto.InternalMessageInfo

func (m *EventMarketDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketUserSettleEnabled is an event emitted when a market's user_settle option is enabled.
type EventMarketUserSettleEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the user_settle option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketUserSettleEnabled) Reset()         { *m = EventMarketUserSettleEnabled{} }
func (m *EventMarketUserSettleEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketUserSettleEnabled) ProtoMessage()    {}
func (*EventMarketUserSettleEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{8}
}
func (m *EventMarketUserSettleEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketUserSettleEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketUserSettleEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketUserSettleEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketUserSettleEnabled.Merge(m, src)
}
func (m *EventMarketUserSettleEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketUserSettleEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketUserSettleEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketUserSettleEnabled proto.InternalMessageInfo

func (m *EventMarketUserSettleEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketUserSettleEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketUserSettleDisabled is an event emitted when a market's user_settle option is disabled.
type EventMarketUserSettleDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the user_settle option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketUserSettleDisabled) Reset()         { *m = EventMarketUserSettleDisabled{} }
func (m *EventMarketUserSettleDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketUserSettleDisabled) ProtoMessage()    {}
func (*EventMarketUserSettleDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{9}
}
func (m *EventMarketUserSettleDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketUserSettleDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketUserSettleDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketUserSettleDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketUserSettleDisabled.Merge(m, src)
}
func (m *EventMarketUserSettleDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketUserSettleDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketUserSettleDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketUserSettleDisabled proto.InternalMessageInfo

func (m *EventMarketUserSettleDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketUserSettleDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketPermissionsUpdated is an event emitted when a market's permissions are updated.
type EventMarketPermissionsUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the permissions.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketPermissionsUpdated) Reset()         { *m = EventMarketPermissionsUpdated{} }
func (m *EventMarketPermissionsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketPermissionsUpdated) ProtoMessage()    {}
func (*EventMarketPermissionsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{10}
}
func (m *EventMarketPermissionsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketPermissionsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketPermissionsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketPermissionsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketPermissionsUpdated.Merge(m, src)
}
func (m *EventMarketPermissionsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketPermissionsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketPermissionsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketPermissionsUpdated proto.InternalMessageInfo

func (m *EventMarketPermissionsUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketPermissionsUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketReqAttrUpdated is an event emitted when a market's required attributes are updated.
type EventMarketReqAttrUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the required attributes.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketReqAttrUpdated) Reset()         { *m = EventMarketReqAttrUpdated{} }
func (m *EventMarketReqAttrUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketReqAttrUpdated) ProtoMessage()    {}
func (*EventMarketReqAttrUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{11}
}
func (m *EventMarketReqAttrUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketReqAttrUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketReqAttrUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketReqAttrUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketReqAttrUpdated.Merge(m, src)
}
func (m *EventMarketReqAttrUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketReqAttrUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketReqAttrUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketReqAttrUpdated proto.InternalMessageInfo

func (m *EventMarketReqAttrUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketReqAttrUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketCreated is an event emitted when a market has been created.
type EventMarketCreated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *EventMarketCreated) Reset()         { *m = EventMarketCreated{} }
func (m *EventMarketCreated) String() string { return proto.CompactTextString(m) }
func (*EventMarketCreated) ProtoMessage()    {}
func (*EventMarketCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{12}
}
func (m *EventMarketCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketCreated.Merge(m, src)
}
func (m *EventMarketCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketCreated proto.InternalMessageInfo

func (m *EventMarketCreated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// EventMarketFeesUpdated is an event emitted when a market's fees have been updated.
type EventMarketFeesUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *EventMarketFeesUpdated) Reset()         { *m = EventMarketFeesUpdated{} }
func (m *EventMarketFeesUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketFeesUpdated) ProtoMessage()    {}
func (*EventMarketFeesUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{13}
}
func (m *EventMarketFeesUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketFeesUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketFeesUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketFeesUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketFeesUpdated.Merge(m, src)
}
func (m *EventMarketFeesUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketFeesUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketFeesUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketFeesUpdated proto.InternalMessageInfo

func (m *EventMarketFeesUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// EventParamsUpdated is an event emitted when the exchange module's params have been updated.
type EventParamsUpdated struct {
}

func (m *EventParamsUpdated) Reset()         { *m = EventParamsUpdated{} }
func (m *EventParamsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventParamsUpdated) ProtoMessage()    {}
func (*EventParamsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{14}
}
func (m *EventParamsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventParamsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventParamsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventParamsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventParamsUpdated.Merge(m, src)
}
func (m *EventParamsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventParamsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventParamsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventParamsUpdated proto.InternalMessageInfo

func init() {
	proto.RegisterType((*EventOrderCreated)(nil), "provenance.exchange.v1.EventOrderCreated")
	proto.RegisterType((*EventOrderCancelled)(nil), "provenance.exchange.v1.EventOrderCancelled")
	proto.RegisterType((*EventOrderFilled)(nil), "provenance.exchange.v1.EventOrderFilled")
	proto.RegisterType((*EventOrderPartiallyFilled)(nil), "provenance.exchange.v1.EventOrderPartiallyFilled")
	proto.RegisterType((*EventMarketWithdraw)(nil), "provenance.exchange.v1.EventMarketWithdraw")
	proto.RegisterType((*EventMarketDetailsUpdated)(nil), "provenance.exchange.v1.EventMarketDetailsUpdated")
	proto.RegisterType((*EventMarketEnabled)(nil), "provenance.exchange.v1.EventMarketEnabled")
	proto.RegisterType((*EventMarketDisabled)(nil), "provenance.exchange.v1.EventMarketDisabled")
	proto.RegisterType((*EventMarketUserSettleEnabled)(nil), "provenance.exchange.v1.EventMarketUserSettleEnabled")
	proto.RegisterType((*EventMarketUserSettleDisabled)(nil), "provenance.exchange.v1.EventMarketUserSettleDisabled")
	proto.RegisterType((*EventMarketPermissionsUpdated)(nil), "provenance.exchange.v1.EventMarketPermissionsUpdated")
	proto.RegisterType((*EventMarketReqAttrUpdated)(nil), "provenance.exchange.v1.EventMarketReqAttrUpdated")
	proto.RegisterType((*EventMarketCreated)(nil), "provenance.exchange.v1.EventMarketCreated")
	proto.RegisterType((*EventMarketFeesUpdated)(nil), "provenance.exchange.v1.EventMarketFeesUpdated")
	proto.RegisterType((*EventParamsUpdated)(nil), "provenance.exchange.v1.EventParamsUpdated")
}

func init() {
	proto.RegisterFile("provenance/exchange/v1/events.proto", fileDescriptor_c1b69385a348cffa)
}

var fileDescriptor_c1b69385a348cffa = []byte{
	// 535 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x95, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xe3, 0xef, 0x0b, 0xa5, 0x99, 0x82, 0x04, 0x26, 0x8a, 0x12, 0xa0, 0x56, 0x65, 0x2e,
	0xbd, 0xd4, 0x56, 0x84, 0x10, 0x12, 0x9c, 0x1a, 0xda, 0x4a, 0x1c, 0x2a, 0x22, 0x97, 0x0a, 0x89,
	0x4b, 0xb4, 0xb1, 0x87, 0x64, 0xa9, 0xbd, 0xeb, 0xee, 0x6e, 0xd2, 0xf8, 0x2d, 0x78, 0x18, 0xde,
	0x80, 0x0b, 0xc7, 0x8a, 0x13, 0x47, 0x94, 0xbc, 0x08, 0xf2, 0xda, 0x4e, 0x1c, 0xa9, 0x4a, 0x7b,
	0x31, 0xb7, 0xfc, 0x27, 0xff, 0x99, 0xdf, 0xce, 0xec, 0xc8, 0x0b, 0x2f, 0x62, 0xc1, 0xa7, 0xc8,
	0x08, 0xf3, 0xd1, 0xc5, 0x99, 0x3f, 0x26, 0x6c, 0x84, 0xee, 0xb4, 0xeb, 0xe2, 0x14, 0x99, 0x92,
	0x4e, 0x2c, 0xb8, 0xe2, 0x66, 0x6b, 0x65, 0x72, 0x0a, 0x93, 0x33, 0xed, 0x3e, 0xed, 0xf8, 0x5c,
	0x46, 0x5c, 0x0e, 0xb4, 0xcb, 0xcd, 0x44, 0x96, 0x62, 0x9f, 0xc2, 0xe3, 0xe3, 0xb4, 0xc4, 0x07,
	0x11, 0xa0, 0x78, 0x27, 0x90, 0x28, 0x0c, 0xcc, 0x0e, 0x6c, 0xf3, 0x54, 0x0f, 0x68, 0xd0, 0x36,
	0xf6, 0x8c, 0xfd, 0xba, 0x77, 0x5f, 0xeb, 0xf7, 0x81, 0xb9, 0x0b, 0x90, 0xfd, 0xa5, 0x92, 0x18,
	0xdb, 0xff, 0xed, 0x19, 0xfb, 0x0d, 0xaf, 0xa1, 0x23, 0x1f, 0x93, 0x18, 0xed, 0x08, 0x9e, 0x94,
	0xca, 0xa5, 0x07, 0x09, 0xc3, 0xcd, 0x05, 0xdf, 0xc2, 0x03, 0xbf, 0xf0, 0x0d, 0x86, 0x49, 0x56,
	0xb2, 0xd7, 0xfe, 0xf5, 0xfd, 0xa0, 0x99, 0x1f, 0xf4, 0x30, 0x08, 0x04, 0x4a, 0x79, 0xa6, 0x04,
	0x65, 0x23, 0x6f, 0x67, 0xe9, 0xee, 0x25, 0x36, 0x87, 0x47, 0x2b, 0xdc, 0x09, 0xbd, 0x8d, 0xd5,
	0x82, 0x2d, 0x22, 0x25, 0x2a, 0x99, 0x1f, 0x3c, 0x57, 0x66, 0x13, 0xee, 0xc5, 0x82, 0xfa, 0xd8,
	0xfe, 0x5f, 0x87, 0x33, 0x61, 0x9a, 0x50, 0xff, 0x82, 0x28, 0xdb, 0x75, 0x1d, 0xd4, 0xbf, 0xed,
	0x19, 0x74, 0x56, 0xc0, 0x3e, 0x11, 0x8a, 0x92, 0x30, 0x4c, 0xfe, 0x05, 0xf9, 0x87, 0x91, 0x8f,
	0xf6, 0x94, 0x88, 0x0b, 0x54, 0x9f, 0xa8, 0x1a, 0x07, 0x82, 0x5c, 0x99, 0xcf, 0xa0, 0x11, 0xe9,
	0x48, 0x41, 0x7d, 0xe8, 0x6d, 0x67, 0x81, 0x1c, 0x1b, 0xf1, 0x09, 0x53, 0x4b, 0xac, 0x56, 0xe6,
	0x1b, 0xd8, 0x09, 0x50, 0x2a, 0xca, 0x88, 0xa2, 0x9c, 0x65, 0xf0, 0x4d, 0x33, 0x2f, 0x99, 0xd3,
	0x0b, 0xbb, 0xca, 0xe1, 0x2c, 0xbd, 0xb0, 0xfa, 0x6d, 0xc9, 0x4b, 0x77, 0x2f, 0xb1, 0x2f, 0xf3,
	0xf9, 0x65, 0x4d, 0x1c, 0xa1, 0x22, 0x34, 0x94, 0xe7, 0x71, 0xa0, 0xd7, 0x6e, 0x63, 0x2b, 0xaf,
	0x01, 0x26, 0x99, 0xef, 0x2e, 0x5b, 0xd2, 0xc8, 0xbd, 0xbd, 0xc4, 0xfe, 0x0a, 0x66, 0x09, 0x79,
	0xcc, 0xc8, 0x30, 0xac, 0x8c, 0x75, 0xb1, 0x76, 0x47, 0x47, 0x54, 0x56, 0x09, 0x53, 0xf0, 0xbc,
	0x04, 0x3b, 0x97, 0x28, 0xce, 0x50, 0xa9, 0x10, 0xab, 0x6d, 0x71, 0x02, 0xbb, 0x37, 0x52, 0x2b,
	0x6e, 0x76, 0x1d, 0xdb, 0x47, 0x11, 0x51, 0x29, 0x29, 0x67, 0x15, 0x2f, 0xcf, 0xfa, 0xbe, 0x7a,
	0x78, 0x79, 0xa8, 0x94, 0xa8, 0x16, 0xd9, 0x5d, 0xdb, 0xd7, 0xe2, 0x93, 0xbc, 0x89, 0x65, 0xbf,
	0x82, 0x56, 0x29, 0xe5, 0x04, 0xf1, 0x4e, 0x53, 0xb1, 0x9b, 0x39, 0xa9, 0x4f, 0x04, 0x89, 0x8a,
	0x94, 0x1e, 0xfe, 0x9c, 0x5b, 0xc6, 0xf5, 0xdc, 0x32, 0xfe, 0xcc, 0x2d, 0xe3, 0xdb, 0xc2, 0xaa,
	0x5d, 0x2f, 0xac, 0xda, 0xef, 0x85, 0x55, 0x83, 0x0e, 0xe5, 0xce, 0xcd, 0x2f, 0x4c, 0xdf, 0xf8,
	0xec, 0x8c, 0xa8, 0x1a, 0x4f, 0x86, 0x8e, 0xcf, 0x23, 0x77, 0x65, 0x3a, 0xa0, 0xbc, 0xa4, 0xdc,
	0xd9, 0xf2, 0xed, 0x1a, 0x6e, 0xe9, 0xf7, 0xe7, 0xe5, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x24,
	0x2e, 0x9d, 0xf5, 0xd9, 0x06, 0x00, 0x00,
}

func (m *EventOrderCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderCancelled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderCancelled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderCancelled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledBy) > 0 {
		i -= len(m.CancelledBy)
		copy(dAtA[i:], m.CancelledBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CancelledBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fees) > 0 {
		i -= len(m.Fees)
		copy(dAtA[i:], m.Fees)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Fees)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderPartiallyFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderPartiallyFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderPartiallyFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fees) > 0 {
		i -= len(m.Fees)
		copy(dAtA[i:], m.Fees)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Fees)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WithdrawnBy) > 0 {
		i -= len(m.WithdrawnBy)
		copy(dAtA[i:], m.WithdrawnBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.WithdrawnBy)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketDetailsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketDetailsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketDetailsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketUserSettleEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketUserSettleEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketUserSettleEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketUserSettleDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketUserSettleDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketUserSettleDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketPermissionsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketPermissionsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketPermissionsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketReqAttrUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketReqAttrUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketReqAttrUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketFeesUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketFeesUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketFeesUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventParamsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventParamsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventParamsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventOrderCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderCancelled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.CancelledBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Fees)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderPartiallyFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Fees)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.WithdrawnBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketDetailsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketUserSettleEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketUserSettleDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketPermissionsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketReqAttrUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	return n
}

func (m *EventMarketFeesUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	return n
}

func (m *EventParamsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventOrderCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderCancelled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderCancelled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderCancelled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fees = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderPartiallyFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderPartiallyFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderPartiallyFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fees = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawnBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketDetailsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketDetailsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketDetailsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketUserSettleEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketUserSettleEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketUserSettleEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketUserSettleDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketUserSettleDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketUserSettleDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketPermissionsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketPermissionsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketPermissionsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketReqAttrUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketReqAttrUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketReqAttrUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketFeesUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketFeesUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketFeesUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventParamsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventParamsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventParamsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
