// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/exchange/v1/events.proto

package exchange

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventOrderCreated is an event emitted when an order is created.
type EventOrderCreated struct {
	// order_id is the numerical identifier of the order created.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// order_type is the type of order, e.g. "ask" or "bid".
	OrderType string `protobuf:"bytes,2,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// external_id is the order's external id.
	ExternalId string `protobuf:"bytes,4,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventOrderCreated) Reset()         { *m = EventOrderCreated{} }
func (m *EventOrderCreated) String() string { return proto.CompactTextString(m) }
func (*EventOrderCreated) ProtoMessage()    {}
func (*EventOrderCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{0}
}
func (m *EventOrderCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderCreated.Merge(m, src)
}
func (m *EventOrderCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderCreated proto.InternalMessageInfo

func (m *EventOrderCreated) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderCreated) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

func (m *EventOrderCreated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventOrderCreated) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventOrderCancelled is an event emitted when an order is cancelled.
type EventOrderCancelled struct {
	// order_id is the numerical identifier of the order cancelled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// cancelled_by is the account that triggered the cancellation of the order.
	CancelledBy string `protobuf:"bytes,2,opt,name=cancelled_by,json=cancelledBy,proto3" json:"cancelled_by,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// external_id is the order's external id.
	ExternalId string `protobuf:"bytes,4,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventOrderCancelled) Reset()         { *m = EventOrderCancelled{} }
func (m *EventOrderCancelled) String() string { return proto.CompactTextString(m) }
func (*EventOrderCancelled) ProtoMessage()    {}
func (*EventOrderCancelled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{1}
}
func (m *EventOrderCancelled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderCancelled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderCancelled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderCancelled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderCancelled.Merge(m, src)
}
func (m *EventOrderCancelled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderCancelled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderCancelled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderCancelled proto.InternalMessageInfo

func (m *EventOrderCancelled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderCancelled) GetCancelledBy() string {
	if m != nil {
		return m.CancelledBy
	}
	return ""
}

func (m *EventOrderCancelled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventOrderCancelled) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventOrderFilled is an event emitted when an order has been filled in full.
// This event is also used for orders that were previously partially filled, but have now been filled in full.
type EventOrderFilled struct {
	// order_id is the numerical identifier of the order filled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// assets is the coins amount string of assets bought/sold for this order.
	Assets string `protobuf:"bytes,2,opt,name=assets,proto3" json:"assets,omitempty"`
	// price is the coins amount string of the price payed/received for this order.
	Price string `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// fees is the coins amount string of settlement fees paid with this order.
	Fees string `protobuf:"bytes,4,opt,name=fees,proto3" json:"fees,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// external_id is the order's external id.
	ExternalId string `protobuf:"bytes,6,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventOrderFilled) Reset()         { *m = EventOrderFilled{} }
func (m *EventOrderFilled) String() string { return proto.CompactTextString(m) }
func (*EventOrderFilled) ProtoMessage()    {}
func (*EventOrderFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{2}
}
func (m *EventOrderFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderFilled.Merge(m, src)
}
func (m *EventOrderFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderFilled proto.InternalMessageInfo

func (m *EventOrderFilled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderFilled) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventOrderFilled) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *EventOrderFilled) GetFees() string {
	if m != nil {
		return m.Fees
	}
	return ""
}

func (m *EventOrderFilled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventOrderFilled) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventOrderPartiallyFilled is an event emitted when an order filled in part and still has more left to fill.
type EventOrderPartiallyFilled struct {
	// order_id is the numerical identifier of the order partially filled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// assets is the coins amount string of assets that were filled and removed from the order.
	Assets string `protobuf:"bytes,2,opt,name=assets,proto3" json:"assets,omitempty"`
	// price is the coins amount string of the price payed/received for this order.
	// For ask orders, this might be more than the amount that was removed from the order's price.
	Price string `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// fees is the coins amount string of settlement fees paid with this partial order.
	// For ask orders, this might be more than the amount that was removed from the order's settlement fees.
	Fees string `protobuf:"bytes,4,opt,name=fees,proto3" json:"fees,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// external_id is the order's external id.
	ExternalId string `protobuf:"bytes,6,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventOrderPartiallyFilled) Reset()         { *m = EventOrderPartiallyFilled{} }
func (m *EventOrderPartiallyFilled) String() string { return proto.CompactTextString(m) }
func (*EventOrderPartiallyFilled) ProtoMessage()    {}
func (*EventOrderPartiallyFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{3}
}
func (m *EventOrderPartiallyFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderPartiallyFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderPartiallyFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderPartiallyFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderPartiallyFilled.Merge(m, src)
}
func (m *EventOrderPartiallyFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderPartiallyFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderPartiallyFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderPartiallyFilled proto.InternalMessageInfo

func (m *EventOrderPartiallyFilled) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderPartiallyFilled) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventOrderPartiallyFilled) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *EventOrderPartiallyFilled) GetFees() string {
	if m != nil {
		return m.Fees
	}
	return ""
}

func (m *EventOrderPartiallyFilled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventOrderPartiallyFilled) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventOrderExternalIDUpdated is an event emitted when an order's external id is updated.
type EventOrderExternalIDUpdated struct {
	// order_id is the numerical identifier of the order partially filled.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// external_id is the order's new external id.
	ExternalId string `protobuf:"bytes,3,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventOrderExternalIDUpdated) Reset()         { *m = EventOrderExternalIDUpdated{} }
func (m *EventOrderExternalIDUpdated) String() string { return proto.CompactTextString(m) }
func (*EventOrderExternalIDUpdated) ProtoMessage()    {}
func (*EventOrderExternalIDUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{4}
}
func (m *EventOrderExternalIDUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderExternalIDUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderExternalIDUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderExternalIDUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderExternalIDUpdated.Merge(m, src)
}
func (m *EventOrderExternalIDUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderExternalIDUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderExternalIDUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderExternalIDUpdated proto.InternalMessageInfo

func (m *EventOrderExternalIDUpdated) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventOrderExternalIDUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventOrderExternalIDUpdated) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventFundsCommitted is an event emitted when funds are committed to a market.
type EventFundsCommitted struct {
	// account is the bech32 address string of the account.
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount is the coins string of the newly committed funds.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// tag is the string provided in the message causing this event.
	Tag string `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *EventFundsCommitted) Reset()         { *m = EventFundsCommitted{} }
func (m *EventFundsCommitted) String() string { return proto.CompactTextString(m) }
func (*EventFundsCommitted) ProtoMessage()    {}
func (*EventFundsCommitted) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{5}
}
func (m *EventFundsCommitted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFundsCommitted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFundsCommitted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFundsCommitted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFundsCommitted.Merge(m, src)
}
func (m *EventFundsCommitted) XXX_Size() int {
	return m.Size()
}
func (m *EventFundsCommitted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFundsCommitted.DiscardUnknown(m)
}

var xxx_messageInfo_EventFundsCommitted proto.InternalMessageInfo

func (m *EventFundsCommitted) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *EventFundsCommitted) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventFundsCommitted) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EventFundsCommitted) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// EventCommitmentReleased is an event emitted when funds are released from their commitment.
type EventCommitmentReleased struct {
	// account is the bech32 address string of the account.
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount is the coins string of the funds that were released from commitment.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// tag is the string provided in the message causing this event.
	Tag string `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *EventCommitmentReleased) Reset()         { *m = EventCommitmentReleased{} }
func (m *EventCommitmentReleased) String() string { return proto.CompactTextString(m) }
func (*EventCommitmentReleased) ProtoMessage()    {}
func (*EventCommitmentReleased) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{6}
}
func (m *EventCommitmentReleased) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCommitmentReleased) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCommitmentReleased.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCommitmentReleased) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCommitmentReleased.Merge(m, src)
}
func (m *EventCommitmentReleased) XXX_Size() int {
	return m.Size()
}
func (m *EventCommitmentReleased) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCommitmentReleased.DiscardUnknown(m)
}

var xxx_messageInfo_EventCommitmentReleased proto.InternalMessageInfo

func (m *EventCommitmentReleased) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *EventCommitmentReleased) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventCommitmentReleased) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EventCommitmentReleased) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// EventMarketWithdraw is an event emitted when a withdrawal of a market's collected fees is made.
type EventMarketWithdraw struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount is the coins amount string of funds withdrawn from the market account.
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// destination is the account that received the funds.
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	// withdrawn_by is the account that requested the withdrawal.
	WithdrawnBy string `protobuf:"bytes,4,opt,name=withdrawn_by,json=withdrawnBy,proto3" json:"withdrawn_by,omitempty"`
}

func (m *EventMarketWithdraw) Reset()         { *m = EventMarketWithdraw{} }
func (m *EventMarketWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventMarketWithdraw) ProtoMessage()    {}
func (*EventMarketWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{7}
}
func (m *EventMarketWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketWithdraw.Merge(m, src)
}
func (m *EventMarketWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketWithdraw proto.InternalMessageInfo

func (m *EventMarketWithdraw) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketWithdraw) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EventMarketWithdraw) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *EventMarketWithdraw) GetWithdrawnBy() string {
	if m != nil {
		return m.WithdrawnBy
	}
	return ""
}

// EventMarketDetailsUpdated is an event emitted when a market's details are updated.
type EventMarketDetailsUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the details.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketDetailsUpdated) Reset()         { *m = EventMarketDetailsUpdated{} }
func (m *EventMarketDetailsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketDetailsUpdated) ProtoMessage()    {}
func (*EventMarketDetailsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{8}
}
func (m *EventMarketDetailsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketDetailsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketDetailsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketDetailsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketDetailsUpdated.Merge(m, src)
}
func (m *EventMarketDetailsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketDetailsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketDetailsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketDetailsUpdated proto.InternalMessageInfo

func (m *EventMarketDetailsUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketDetailsUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketEnabled is an event emitted when a market is enabled.
// Deprecated: This event is no longer used. It is replaced with EventMarketOrdersEnabled.
//
// Deprecated: Do not use.
type EventMarketEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that enabled the market.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketEnabled) Reset()         { *m = EventMarketEnabled{} }
func (m *EventMarketEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketEnabled) ProtoMessage()    {}
func (*EventMarketEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{9}
}
func (m *EventMarketEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketEnabled.Merge(m, src)
}
func (m *EventMarketEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketEnabled proto.InternalMessageInfo

func (m *EventMarketEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketDisabled is an event emitted when a market is disabled.
// Deprecated: This event is no longer used. It is replaced with EventMarketOrdersDisabled.
//
// Deprecated: Do not use.
type EventMarketDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that disabled the market.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketDisabled) Reset()         { *m = EventMarketDisabled{} }
func (m *EventMarketDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketDisabled) ProtoMessage()    {}
func (*EventMarketDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{10}
}
func (m *EventMarketDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketDisabled.Merge(m, src)
}
func (m *EventMarketDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketDisabled proto.InternalMessageInfo

func (m *EventMarketDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketOrdersEnabled is an event emitted when a market enables order creation.
type EventMarketOrdersEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the accepting_orders option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketOrdersEnabled) Reset()         { *m = EventMarketOrdersEnabled{} }
func (m *EventMarketOrdersEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketOrdersEnabled) ProtoMessage()    {}
func (*EventMarketOrdersEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{11}
}
func (m *EventMarketOrdersEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketOrdersEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketOrdersEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketOrdersEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketOrdersEnabled.Merge(m, src)
}
func (m *EventMarketOrdersEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketOrdersEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketOrdersEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketOrdersEnabled proto.InternalMessageInfo

func (m *EventMarketOrdersEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketOrdersEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketOrdersEnabled is an event emitted when a market disables order creation.
type EventMarketOrdersDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the accepting_orders option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketOrdersDisabled) Reset()         { *m = EventMarketOrdersDisabled{} }
func (m *EventMarketOrdersDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketOrdersDisabled) ProtoMessage()    {}
func (*EventMarketOrdersDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{12}
}
func (m *EventMarketOrdersDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketOrdersDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketOrdersDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketOrdersDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketOrdersDisabled.Merge(m, src)
}
func (m *EventMarketOrdersDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketOrdersDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketOrdersDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketOrdersDisabled proto.InternalMessageInfo

func (m *EventMarketOrdersDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketOrdersDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketUserSettleEnabled is an event emitted when a market's user_settle option is enabled.
type EventMarketUserSettleEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the user_settle option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketUserSettleEnabled) Reset()         { *m = EventMarketUserSettleEnabled{} }
func (m *EventMarketUserSettleEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketUserSettleEnabled) ProtoMessage()    {}
func (*EventMarketUserSettleEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{13}
}
func (m *EventMarketUserSettleEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketUserSettleEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketUserSettleEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketUserSettleEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketUserSettleEnabled.Merge(m, src)
}
func (m *EventMarketUserSettleEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketUserSettleEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketUserSettleEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketUserSettleEnabled proto.InternalMessageInfo

func (m *EventMarketUserSettleEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketUserSettleEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketUserSettleDisabled is an event emitted when a market's user_settle option is disabled.
type EventMarketUserSettleDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the user_settle option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketUserSettleDisabled) Reset()         { *m = EventMarketUserSettleDisabled{} }
func (m *EventMarketUserSettleDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketUserSettleDisabled) ProtoMessage()    {}
func (*EventMarketUserSettleDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{14}
}
func (m *EventMarketUserSettleDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketUserSettleDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketUserSettleDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketUserSettleDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketUserSettleDisabled.Merge(m, src)
}
func (m *EventMarketUserSettleDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketUserSettleDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketUserSettleDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketUserSettleDisabled proto.InternalMessageInfo

func (m *EventMarketUserSettleDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketUserSettleDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketCommitmentsEnabled is an event emitted when a market's accepting_commitments option is enabled.
type EventMarketCommitmentsEnabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the accepting_commitments option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketCommitmentsEnabled) Reset()         { *m = EventMarketCommitmentsEnabled{} }
func (m *EventMarketCommitmentsEnabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketCommitmentsEnabled) ProtoMessage()    {}
func (*EventMarketCommitmentsEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{15}
}
func (m *EventMarketCommitmentsEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketCommitmentsEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketCommitmentsEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketCommitmentsEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketCommitmentsEnabled.Merge(m, src)
}
func (m *EventMarketCommitmentsEnabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketCommitmentsEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketCommitmentsEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketCommitmentsEnabled proto.InternalMessageInfo

func (m *EventMarketCommitmentsEnabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketCommitmentsEnabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketCommitmentsDisabled is an event emitted when a market's accepting_commitments option is disabled.
type EventMarketCommitmentsDisabled struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the accepting_commitments option.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketCommitmentsDisabled) Reset()         { *m = EventMarketCommitmentsDisabled{} }
func (m *EventMarketCommitmentsDisabled) String() string { return proto.CompactTextString(m) }
func (*EventMarketCommitmentsDisabled) ProtoMessage()    {}
func (*EventMarketCommitmentsDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{16}
}
func (m *EventMarketCommitmentsDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketCommitmentsDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketCommitmentsDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketCommitmentsDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketCommitmentsDisabled.Merge(m, src)
}
func (m *EventMarketCommitmentsDisabled) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketCommitmentsDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketCommitmentsDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketCommitmentsDisabled proto.InternalMessageInfo

func (m *EventMarketCommitmentsDisabled) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketCommitmentsDisabled) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketIntermediaryDenomUpdated is an event emitted when a market updates its
// commitment_settlement_intermediary_denom field.
type EventMarketIntermediaryDenomUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the intermediary denom.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketIntermediaryDenomUpdated) Reset()         { *m = EventMarketIntermediaryDenomUpdated{} }
func (m *EventMarketIntermediaryDenomUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketIntermediaryDenomUpdated) ProtoMessage()    {}
func (*EventMarketIntermediaryDenomUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{17}
}
func (m *EventMarketIntermediaryDenomUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketIntermediaryDenomUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketIntermediaryDenomUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketIntermediaryDenomUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketIntermediaryDenomUpdated.Merge(m, src)
}
func (m *EventMarketIntermediaryDenomUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketIntermediaryDenomUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketIntermediaryDenomUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketIntermediaryDenomUpdated proto.InternalMessageInfo

func (m *EventMarketIntermediaryDenomUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketIntermediaryDenomUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketPermissionsUpdated is an event emitted when a market's permissions are updated.
type EventMarketPermissionsUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the permissions.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketPermissionsUpdated) Reset()         { *m = EventMarketPermissionsUpdated{} }
func (m *EventMarketPermissionsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketPermissionsUpdated) ProtoMessage()    {}
func (*EventMarketPermissionsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{18}
}
func (m *EventMarketPermissionsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketPermissionsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketPermissionsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketPermissionsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketPermissionsUpdated.Merge(m, src)
}
func (m *EventMarketPermissionsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketPermissionsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketPermissionsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketPermissionsUpdated proto.InternalMessageInfo

func (m *EventMarketPermissionsUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketPermissionsUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketReqAttrUpdated is an event emitted when a market's required attributes are updated.
type EventMarketReqAttrUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// updated_by is the account that updated the required attributes.
	UpdatedBy string `protobuf:"bytes,2,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
}

func (m *EventMarketReqAttrUpdated) Reset()         { *m = EventMarketReqAttrUpdated{} }
func (m *EventMarketReqAttrUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketReqAttrUpdated) ProtoMessage()    {}
func (*EventMarketReqAttrUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{19}
}
func (m *EventMarketReqAttrUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketReqAttrUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketReqAttrUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketReqAttrUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketReqAttrUpdated.Merge(m, src)
}
func (m *EventMarketReqAttrUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketReqAttrUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketReqAttrUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketReqAttrUpdated proto.InternalMessageInfo

func (m *EventMarketReqAttrUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *EventMarketReqAttrUpdated) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

// EventMarketCreated is an event emitted when a market has been created.
type EventMarketCreated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *EventMarketCreated) Reset()         { *m = EventMarketCreated{} }
func (m *EventMarketCreated) String() string { return proto.CompactTextString(m) }
func (*EventMarketCreated) ProtoMessage()    {}
func (*EventMarketCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{20}
}
func (m *EventMarketCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketCreated.Merge(m, src)
}
func (m *EventMarketCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketCreated proto.InternalMessageInfo

func (m *EventMarketCreated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// EventMarketFeesUpdated is an event emitted when a market's fees have been updated.
type EventMarketFeesUpdated struct {
	// market_id is the numerical identifier of the market.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *EventMarketFeesUpdated) Reset()         { *m = EventMarketFeesUpdated{} }
func (m *EventMarketFeesUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMarketFeesUpdated) ProtoMessage()    {}
func (*EventMarketFeesUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{21}
}
func (m *EventMarketFeesUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketFeesUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketFeesUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketFeesUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketFeesUpdated.Merge(m, src)
}
func (m *EventMarketFeesUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketFeesUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketFeesUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketFeesUpdated proto.InternalMessageInfo

func (m *EventMarketFeesUpdated) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// EventParamsUpdated is an event emitted when the exchange module's params have been updated.
type EventParamsUpdated struct {
}

func (m *EventParamsUpdated) Reset()         { *m = EventParamsUpdated{} }
func (m *EventParamsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventParamsUpdated) ProtoMessage()    {}
func (*EventParamsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{22}
}
func (m *EventParamsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventParamsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventParamsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventParamsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventParamsUpdated.Merge(m, src)
}
func (m *EventParamsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventParamsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventParamsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventParamsUpdated proto.InternalMessageInfo

// EventPaymentCreated is an event emitted when a payment is created.
type EventPaymentCreated struct {
	// source is the account that created the Payment.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// source_amount is the coins amount string of the funds that the source will pay (to the target).
	SourceAmount string `protobuf:"bytes,2,opt,name=source_amount,json=sourceAmount,proto3" json:"source_amount,omitempty"`
	// target is the account that can accept the Payment.
	Target string `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	// target_amount is the coins amount string of the funds that the target will pay (to the source).
	TargetAmount string `protobuf:"bytes,4,opt,name=target_amount,json=targetAmount,proto3" json:"target_amount,omitempty"`
	// external_id is used along with the source to uniquely identify this Payment.
	ExternalId string `protobuf:"bytes,5,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventPaymentCreated) Reset()         { *m = EventPaymentCreated{} }
func (m *EventPaymentCreated) String() string { return proto.CompactTextString(m) }
func (*EventPaymentCreated) ProtoMessage()    {}
func (*EventPaymentCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{23}
}
func (m *EventPaymentCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPaymentCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPaymentCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPaymentCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPaymentCreated.Merge(m, src)
}
func (m *EventPaymentCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventPaymentCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPaymentCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventPaymentCreated proto.InternalMessageInfo

func (m *EventPaymentCreated) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *EventPaymentCreated) GetSourceAmount() string {
	if m != nil {
		return m.SourceAmount
	}
	return ""
}

func (m *EventPaymentCreated) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *EventPaymentCreated) GetTargetAmount() string {
	if m != nil {
		return m.TargetAmount
	}
	return ""
}

func (m *EventPaymentCreated) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventPaymentUpdated is an event emitted when a payment is updated.
type EventPaymentUpdated struct {
	// source is the account that updated (and previously created) the Payment.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// source_amount is the coins amount string of the funds that the source will pay (to the target).
	SourceAmount string `protobuf:"bytes,2,opt,name=source_amount,json=sourceAmount,proto3" json:"source_amount,omitempty"`
	// old_target is the account that used to be able to accept the Payment (but not any more).
	OldTarget string `protobuf:"bytes,3,opt,name=old_target,json=oldTarget,proto3" json:"old_target,omitempty"`
	// new_target is the account that is now able to accept the Payment.
	NewTarget string `protobuf:"bytes,4,opt,name=new_target,json=newTarget,proto3" json:"new_target,omitempty"`
	// target_amount is the coins amount string of the funds that the target will pay (to the source).
	TargetAmount string `protobuf:"bytes,5,opt,name=target_amount,json=targetAmount,proto3" json:"target_amount,omitempty"`
	// external_id is used along with the source to uniquely identify this Payment.
	ExternalId string `protobuf:"bytes,6,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventPaymentUpdated) Reset()         { *m = EventPaymentUpdated{} }
func (m *EventPaymentUpdated) String() string { return proto.CompactTextString(m) }
func (*EventPaymentUpdated) ProtoMessage()    {}
func (*EventPaymentUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{24}
}
func (m *EventPaymentUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPaymentUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPaymentUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPaymentUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPaymentUpdated.Merge(m, src)
}
func (m *EventPaymentUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventPaymentUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPaymentUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventPaymentUpdated proto.InternalMessageInfo

func (m *EventPaymentUpdated) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *EventPaymentUpdated) GetSourceAmount() string {
	if m != nil {
		return m.SourceAmount
	}
	return ""
}

func (m *EventPaymentUpdated) GetOldTarget() string {
	if m != nil {
		return m.OldTarget
	}
	return ""
}

func (m *EventPaymentUpdated) GetNewTarget() string {
	if m != nil {
		return m.NewTarget
	}
	return ""
}

func (m *EventPaymentUpdated) GetTargetAmount() string {
	if m != nil {
		return m.TargetAmount
	}
	return ""
}

func (m *EventPaymentUpdated) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventPaymentAccepted is an event emitted when a payment is accepted.
type EventPaymentAccepted struct {
	// source is the account that created the Payment.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// source_amount is the coins amount string of the funds that the source will pay (to the target).
	SourceAmount string `protobuf:"bytes,2,opt,name=source_amount,json=sourceAmount,proto3" json:"source_amount,omitempty"`
	// target is the account that accepted the Payment.
	Target string `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	// target_amount is the coins amount string of the funds that the target will pay (to the source).
	TargetAmount string `protobuf:"bytes,4,opt,name=target_amount,json=targetAmount,proto3" json:"target_amount,omitempty"`
	// external_id is used along with the source to uniquely identify this Payment.
	ExternalId string `protobuf:"bytes,5,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventPaymentAccepted) Reset()         { *m = EventPaymentAccepted{} }
func (m *EventPaymentAccepted) String() string { return proto.CompactTextString(m) }
func (*EventPaymentAccepted) ProtoMessage()    {}
func (*EventPaymentAccepted) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{25}
}
func (m *EventPaymentAccepted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPaymentAccepted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPaymentAccepted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPaymentAccepted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPaymentAccepted.Merge(m, src)
}
func (m *EventPaymentAccepted) XXX_Size() int {
	return m.Size()
}
func (m *EventPaymentAccepted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPaymentAccepted.DiscardUnknown(m)
}

var xxx_messageInfo_EventPaymentAccepted proto.InternalMessageInfo

func (m *EventPaymentAccepted) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *EventPaymentAccepted) GetSourceAmount() string {
	if m != nil {
		return m.SourceAmount
	}
	return ""
}

func (m *EventPaymentAccepted) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *EventPaymentAccepted) GetTargetAmount() string {
	if m != nil {
		return m.TargetAmount
	}
	return ""
}

func (m *EventPaymentAccepted) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventPaymentRejected is an event emitted when a payment is rejected (by the target).
type EventPaymentRejected struct {
	// source is the account that created the Payment.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// target is the account that rejected the Payment.
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// external_id is used along with the source to uniquely identify this Payment.
	ExternalId string `protobuf:"bytes,3,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventPaymentRejected) Reset()         { *m = EventPaymentRejected{} }
func (m *EventPaymentRejected) String() string { return proto.CompactTextString(m) }
func (*EventPaymentRejected) ProtoMessage()    {}
func (*EventPaymentRejected) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{26}
}
func (m *EventPaymentRejected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPaymentRejected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPaymentRejected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPaymentRejected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPaymentRejected.Merge(m, src)
}
func (m *EventPaymentRejected) XXX_Size() int {
	return m.Size()
}
func (m *EventPaymentRejected) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPaymentRejected.DiscardUnknown(m)
}

var xxx_messageInfo_EventPaymentRejected proto.InternalMessageInfo

func (m *EventPaymentRejected) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *EventPaymentRejected) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *EventPaymentRejected) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

// EventPaymentCancelled is an event emitted when a payment is cancelled (by the source).
type EventPaymentCancelled struct {
	// source is the account that cancelled (and created) the Payment.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// target is the account that could have accepted the Payment.
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// external_id is used along with the source to uniquely identify this Payment.
	ExternalId string `protobuf:"bytes,3,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
}

func (m *EventPaymentCancelled) Reset()         { *m = EventPaymentCancelled{} }
func (m *EventPaymentCancelled) String() string { return proto.CompactTextString(m) }
func (*EventPaymentCancelled) ProtoMessage()    {}
func (*EventPaymentCancelled) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b69385a348cffa, []int{27}
}
func (m *EventPaymentCancelled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPaymentCancelled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPaymentCancelled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPaymentCancelled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPaymentCancelled.Merge(m, src)
}
func (m *EventPaymentCancelled) XXX_Size() int {
	return m.Size()
}
func (m *EventPaymentCancelled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPaymentCancelled.DiscardUnknown(m)
}

var xxx_messageInfo_EventPaymentCancelled proto.InternalMessageInfo

func (m *EventPaymentCancelled) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *EventPaymentCancelled) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *EventPaymentCancelled) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func init() {
	proto.RegisterType((*EventOrderCreated)(nil), "provenance.exchange.v1.EventOrderCreated")
	proto.RegisterType((*EventOrderCancelled)(nil), "provenance.exchange.v1.EventOrderCancelled")
	proto.RegisterType((*EventOrderFilled)(nil), "provenance.exchange.v1.EventOrderFilled")
	proto.RegisterType((*EventOrderPartiallyFilled)(nil), "provenance.exchange.v1.EventOrderPartiallyFilled")
	proto.RegisterType((*EventOrderExternalIDUpdated)(nil), "provenance.exchange.v1.EventOrderExternalIDUpdated")
	proto.RegisterType((*EventFundsCommitted)(nil), "provenance.exchange.v1.EventFundsCommitted")
	proto.RegisterType((*EventCommitmentReleased)(nil), "provenance.exchange.v1.EventCommitmentReleased")
	proto.RegisterType((*EventMarketWithdraw)(nil), "provenance.exchange.v1.EventMarketWithdraw")
	proto.RegisterType((*EventMarketDetailsUpdated)(nil), "provenance.exchange.v1.EventMarketDetailsUpdated")
	proto.RegisterType((*EventMarketEnabled)(nil), "provenance.exchange.v1.EventMarketEnabled")
	proto.RegisterType((*EventMarketDisabled)(nil), "provenance.exchange.v1.EventMarketDisabled")
	proto.RegisterType((*EventMarketOrdersEnabled)(nil), "provenance.exchange.v1.EventMarketOrdersEnabled")
	proto.RegisterType((*EventMarketOrdersDisabled)(nil), "provenance.exchange.v1.EventMarketOrdersDisabled")
	proto.RegisterType((*EventMarketUserSettleEnabled)(nil), "provenance.exchange.v1.EventMarketUserSettleEnabled")
	proto.RegisterType((*EventMarketUserSettleDisabled)(nil), "provenance.exchange.v1.EventMarketUserSettleDisabled")
	proto.RegisterType((*EventMarketCommitmentsEnabled)(nil), "provenance.exchange.v1.EventMarketCommitmentsEnabled")
	proto.RegisterType((*EventMarketCommitmentsDisabled)(nil), "provenance.exchange.v1.EventMarketCommitmentsDisabled")
	proto.RegisterType((*EventMarketIntermediaryDenomUpdated)(nil), "provenance.exchange.v1.EventMarketIntermediaryDenomUpdated")
	proto.RegisterType((*EventMarketPermissionsUpdated)(nil), "provenance.exchange.v1.EventMarketPermissionsUpdated")
	proto.RegisterType((*EventMarketReqAttrUpdated)(nil), "provenance.exchange.v1.EventMarketReqAttrUpdated")
	proto.RegisterType((*EventMarketCreated)(nil), "provenance.exchange.v1.EventMarketCreated")
	proto.RegisterType((*EventMarketFeesUpdated)(nil), "provenance.exchange.v1.EventMarketFeesUpdated")
	proto.RegisterType((*EventParamsUpdated)(nil), "provenance.exchange.v1.EventParamsUpdated")
	proto.RegisterType((*EventPaymentCreated)(nil), "provenance.exchange.v1.EventPaymentCreated")
	proto.RegisterType((*EventPaymentUpdated)(nil), "provenance.exchange.v1.EventPaymentUpdated")
	proto.RegisterType((*EventPaymentAccepted)(nil), "provenance.exchange.v1.EventPaymentAccepted")
	proto.RegisterType((*EventPaymentRejected)(nil), "provenance.exchange.v1.EventPaymentRejected")
	proto.RegisterType((*EventPaymentCancelled)(nil), "provenance.exchange.v1.EventPaymentCancelled")
}

func init() {
	proto.RegisterFile("provenance/exchange/v1/events.proto", fileDescriptor_c1b69385a348cffa)
}

var fileDescriptor_c1b69385a348cffa = []byte{
	// 884 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x31, 0x6f, 0xe4, 0x44,
	0x14, 0xce, 0x6c, 0x92, 0xbd, 0xdb, 0x97, 0x9c, 0x74, 0x98, 0x10, 0x36, 0x1c, 0xb7, 0x44, 0x4e,
	0x93, 0xe6, 0x76, 0x2f, 0x20, 0x14, 0xe9, 0xa8, 0xb2, 0x97, 0x44, 0x4a, 0x81, 0x58, 0xf9, 0x72,
	0x42, 0xa2, 0x59, 0x4d, 0xec, 0xc7, 0x66, 0xc0, 0x9e, 0xf1, 0xcd, 0xcc, 0x6e, 0x62, 0xf1, 0x13,
	0x68, 0xae, 0xa0, 0x83, 0x92, 0x0e, 0xd1, 0x21, 0xfe, 0x00, 0x0d, 0xe5, 0x89, 0x8a, 0x12, 0x25,
	0xf0, 0x3f, 0x90, 0x3d, 0x76, 0xd6, 0xce, 0xe6, 0xec, 0x15, 0xc8, 0x22, 0xa2, 0x9b, 0x19, 0xbf,
	0xf7, 0xbe, 0xef, 0x7b, 0x9e, 0x79, 0x6f, 0x06, 0xb6, 0x42, 0x29, 0x26, 0xc8, 0x29, 0x77, 0xb1,
	0x87, 0xe7, 0xee, 0x29, 0xe5, 0x23, 0xec, 0x4d, 0x76, 0x7a, 0x38, 0x41, 0xae, 0x55, 0x37, 0x94,
	0x42, 0x0b, 0x6b, 0x7d, 0x6a, 0xd4, 0xcd, 0x8c, 0xba, 0x93, 0x9d, 0x77, 0x36, 0x5c, 0xa1, 0x02,
	0xa1, 0x86, 0x89, 0x55, 0xcf, 0x4c, 0x8c, 0x8b, 0xfd, 0x35, 0x81, 0x37, 0x0e, 0xe2, 0x18, 0x9f,
	0x48, 0x0f, 0xe5, 0x53, 0x89, 0x54, 0xa3, 0x67, 0x6d, 0xc0, 0x5d, 0x11, 0xcf, 0x87, 0xcc, 0x6b,
	0x93, 0x4d, 0xb2, 0xbd, 0xe4, 0xdc, 0x49, 0xe6, 0x47, 0x9e, 0xf5, 0x10, 0xc0, 0x7c, 0xd2, 0x51,
	0x88, 0xed, 0xc6, 0x26, 0xd9, 0x6e, 0x39, 0xad, 0x64, 0xe5, 0x38, 0x0a, 0xd1, 0x7a, 0x00, 0xad,
	0x80, 0xca, 0x2f, 0x51, 0xc7, 0xae, 0x8b, 0x9b, 0x64, 0xfb, 0x9e, 0x73, 0xd7, 0x2c, 0x1c, 0x79,
	0xd6, 0x7b, 0xb0, 0x82, 0xe7, 0x1a, 0x25, 0xa7, 0x7e, 0xfc, 0x79, 0x29, 0x71, 0x86, 0x6c, 0xe9,
	0xc8, 0xb3, 0x7f, 0x20, 0xf0, 0x66, 0x8e, 0x4d, 0x2c, 0xc4, 0xf7, 0xcb, 0xf9, 0x7c, 0x04, 0xab,
	0x6e, 0x66, 0x37, 0x3c, 0x89, 0x0c, 0xa3, 0x7e, 0xfb, 0xb7, 0x9f, 0x1e, 0xad, 0xa5, 0x42, 0xf7,
	0x3c, 0x4f, 0xa2, 0x52, 0xcf, 0xb4, 0x64, 0x7c, 0xe4, 0xac, 0x5c, 0x59, 0xf7, 0xa3, 0x7f, 0xc9,
	0xf6, 0x47, 0x02, 0xf7, 0xa7, 0x6c, 0x0f, 0x59, 0x15, 0xd5, 0x75, 0x68, 0x52, 0xa5, 0x50, 0xab,
	0x34, 0x6d, 0xe9, 0xcc, 0x5a, 0x83, 0xe5, 0x50, 0x32, 0x17, 0x13, 0x06, 0x2d, 0xc7, 0x4c, 0x2c,
	0x0b, 0x96, 0x3e, 0x47, 0x54, 0x29, 0x6e, 0x32, 0x2e, 0xf2, 0x5d, 0x2e, 0xe7, 0xdb, 0x9c, 0xe1,
	0xfb, 0x33, 0x81, 0x8d, 0x29, 0xdf, 0x01, 0x95, 0x9a, 0x51, 0xdf, 0x8f, 0x6e, 0x3f, 0xf1, 0x09,
	0x3c, 0x98, 0xf2, 0x3e, 0xc8, 0xd6, 0xf7, 0x9f, 0x87, 0x5e, 0xd5, 0x6e, 0x2d, 0xe0, 0x36, 0xca,
	0x71, 0x17, 0x67, 0x70, 0x5f, 0x66, 0xdb, 0xf1, 0x70, 0xcc, 0x3d, 0xf5, 0x54, 0x04, 0x01, 0xd3,
	0x31, 0xe0, 0xfb, 0x70, 0x87, 0xba, 0xae, 0x18, 0x73, 0x9d, 0xe0, 0x95, 0x6d, 0xb7, 0xcc, 0xb0,
	0x9c, 0x49, 0x9c, 0xe0, 0x20, 0x89, 0xb7, 0x98, 0x26, 0x38, 0x99, 0x59, 0xf7, 0x61, 0x51, 0xd3,
	0x51, 0x9a, 0xc9, 0x78, 0x68, 0x7f, 0x43, 0xe0, 0xed, 0x84, 0x92, 0x61, 0x13, 0x20, 0xd7, 0x0e,
	0xfa, 0x48, 0xd5, 0x7f, 0x4b, 0xeb, 0x97, 0x2c, 0x53, 0x1f, 0x27, 0xbe, 0x9f, 0x32, 0x7d, 0xea,
	0x49, 0x7a, 0x56, 0x0c, 0x4f, 0x5e, 0x1b, 0xbe, 0x51, 0x08, 0xff, 0x04, 0x56, 0x3c, 0x54, 0x9a,
	0x71, 0xaa, 0x99, 0xe0, 0x06, 0xbb, 0xec, 0x44, 0xe7, 0x8c, 0xe3, 0x72, 0x70, 0x96, 0x82, 0xf3,
	0xb8, 0x1c, 0x2c, 0x55, 0x39, 0x5f, 0x59, 0xf7, 0x23, 0xfb, 0x45, 0x7a, 0x3e, 0x8c, 0x88, 0x7d,
	0xd4, 0x94, 0xf9, 0x2a, 0xdb, 0x65, 0xa5, 0x52, 0x76, 0x01, 0xc6, 0xc6, 0x6e, 0x9e, 0x1a, 0xd4,
	0x4a, 0x6d, 0xfb, 0x91, 0xcd, 0xc1, 0xca, 0x41, 0x1e, 0x70, 0x7a, 0xe2, 0xd7, 0x85, 0xf5, 0xa4,
	0xd1, 0x26, 0xb6, 0x28, 0xfc, 0xa7, 0x7d, 0xa6, 0xea, 0x06, 0x0c, 0xa1, 0x9d, 0x03, 0x4c, 0x4e,
	0xb0, 0xaa, 0x55, 0xe6, 0xb5, 0xbf, 0x68, 0x10, 0xeb, 0x15, 0x6a, 0x6b, 0x78, 0x37, 0x07, 0xf9,
	0x5c, 0xa1, 0x7c, 0x86, 0x5a, 0xfb, 0x58, 0xaf, 0xd0, 0x31, 0x3c, 0xbc, 0x11, 0xb5, 0x66, 0xb1,
	0x45, 0xd8, 0x69, 0x1d, 0xaa, 0xf9, 0xb7, 0x4e, 0xa0, 0x73, 0x33, 0x6c, 0xcd, 0x72, 0xbf, 0x82,
	0xad, 0x1c, 0xee, 0x11, 0xd7, 0x28, 0x03, 0xf4, 0x18, 0x95, 0xd1, 0x3e, 0x72, 0x11, 0xd4, 0x5b,
	0x1e, 0x8a, 0xb9, 0x1e, 0xa0, 0x0c, 0x98, 0x52, 0x4c, 0xf0, 0x9a, 0xab, 0x52, 0xf1, 0x08, 0x39,
	0xf8, 0x62, 0x4f, 0x6b, 0x59, 0x2f, 0xe4, 0x4e, 0xa1, 0x10, 0x66, 0x17, 0xd1, 0x32, 0x2c, 0xfb,
	0x43, 0x58, 0xcf, 0xb9, 0x1c, 0x22, 0xce, 0x95, 0x15, 0x7b, 0x2d, 0x45, 0x1a, 0x50, 0x49, 0x83,
	0xcc, 0xc5, 0xfe, 0x33, 0xeb, 0x60, 0x03, 0x1a, 0xc5, 0xdb, 0x2a, 0x63, 0xf0, 0x18, 0x9a, 0x4a,
	0x8c, 0xa5, 0x8b, 0x95, 0x3d, 0x35, 0xb5, 0xb3, 0xb6, 0xe0, 0x9e, 0x19, 0x0d, 0x0b, 0xdd, 0x6d,
	0xd5, 0x2c, 0xee, 0x99, 0x1e, 0xf7, 0x18, 0x9a, 0x9a, 0xca, 0x11, 0xea, 0xca, 0xf6, 0x96, 0xda,
	0xc5, 0x61, 0xcd, 0x28, 0x0b, 0x6b, 0xda, 0xef, 0xaa, 0x59, 0x4c, 0xc3, 0x5e, 0xbb, 0xd2, 0x2c,
	0xcf, 0x5c, 0x69, 0xbe, 0x6f, 0x14, 0x65, 0x66, 0x19, 0xab, 0x49, 0xe6, 0x2e, 0x80, 0xf0, 0xbd,
	0xe1, 0x9c, 0x52, 0x5b, 0xc2, 0xf7, 0x8e, 0x8d, 0xda, 0x5d, 0x00, 0x8e, 0x67, 0x99, 0x63, 0x55,
	0x17, 0x6f, 0x71, 0x3c, 0x3b, 0x7e, 0x4d, 0x9a, 0x96, 0xab, 0xd3, 0x34, 0x7b, 0xe3, 0xfc, 0x8b,
	0xc0, 0x5a, 0x3e, 0x4d, 0x7b, 0xae, 0x8b, 0xe1, 0xff, 0x70, 0x3b, 0x7c, 0x7b, 0x4d, 0xa7, 0x83,
	0x5f, 0xa0, 0xfb, 0xcf, 0x74, 0x4e, 0x25, 0x34, 0xe6, 0x94, 0x50, 0x79, 0xff, 0xfe, 0x8e, 0xc0,
	0x5b, 0x85, 0x33, 0x79, 0xf5, 0x20, 0xbc, 0x0d, 0xf4, 0xfa, 0xf8, 0xeb, 0x45, 0x87, 0xbc, 0xba,
	0xe8, 0x90, 0x3f, 0x2e, 0x3a, 0xe4, 0xe5, 0x65, 0x67, 0xe1, 0xd5, 0x65, 0x67, 0xe1, 0xf7, 0xcb,
	0xce, 0x02, 0x6c, 0x30, 0xd1, 0xbd, 0xf9, 0x2d, 0x3e, 0x20, 0x9f, 0x75, 0x47, 0x4c, 0x9f, 0x8e,
	0x4f, 0xba, 0xae, 0x08, 0x7a, 0x53, 0xa3, 0x47, 0x4c, 0xe4, 0x66, 0xbd, 0xf3, 0xab, 0x57, 0xfe,
	0x49, 0x33, 0x79, 0xa9, 0x7f, 0xf0, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x47, 0x79, 0x48, 0x20,
	0x03, 0x10, 0x00, 0x00,
}

func (m *EventOrderCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x22
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderCancelled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderCancelled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderCancelled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x22
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CancelledBy) > 0 {
		i -= len(m.CancelledBy)
		copy(dAtA[i:], m.CancelledBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CancelledBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Fees) > 0 {
		i -= len(m.Fees)
		copy(dAtA[i:], m.Fees)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Fees)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderPartiallyFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderPartiallyFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderPartiallyFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Fees) > 0 {
		i -= len(m.Fees)
		copy(dAtA[i:], m.Fees)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Fees)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderExternalIDUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderExternalIDUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderExternalIDUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x10
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventFundsCommitted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFundsCommitted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFundsCommitted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCommitmentReleased) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCommitmentReleased) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCommitmentReleased) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WithdrawnBy) > 0 {
		i -= len(m.WithdrawnBy)
		copy(dAtA[i:], m.WithdrawnBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.WithdrawnBy)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketDetailsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketDetailsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketDetailsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketOrdersEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketOrdersEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketOrdersEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketOrdersDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketOrdersDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketOrdersDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketUserSettleEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketUserSettleEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketUserSettleEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketUserSettleDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketUserSettleDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketUserSettleDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketCommitmentsEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketCommitmentsEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketCommitmentsEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketCommitmentsDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketCommitmentsDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketCommitmentsDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketIntermediaryDenomUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketIntermediaryDenomUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketIntermediaryDenomUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketPermissionsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketPermissionsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketPermissionsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketReqAttrUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketReqAttrUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketReqAttrUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketFeesUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketFeesUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketFeesUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventParamsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventParamsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventParamsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EventPaymentCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPaymentCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPaymentCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TargetAmount) > 0 {
		i -= len(m.TargetAmount)
		copy(dAtA[i:], m.TargetAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TargetAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceAmount) > 0 {
		i -= len(m.SourceAmount)
		copy(dAtA[i:], m.SourceAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPaymentUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPaymentUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPaymentUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TargetAmount) > 0 {
		i -= len(m.TargetAmount)
		copy(dAtA[i:], m.TargetAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TargetAmount)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewTarget) > 0 {
		i -= len(m.NewTarget)
		copy(dAtA[i:], m.NewTarget)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewTarget)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldTarget) > 0 {
		i -= len(m.OldTarget)
		copy(dAtA[i:], m.OldTarget)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OldTarget)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceAmount) > 0 {
		i -= len(m.SourceAmount)
		copy(dAtA[i:], m.SourceAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPaymentAccepted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPaymentAccepted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPaymentAccepted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TargetAmount) > 0 {
		i -= len(m.TargetAmount)
		copy(dAtA[i:], m.TargetAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TargetAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceAmount) > 0 {
		i -= len(m.SourceAmount)
		copy(dAtA[i:], m.SourceAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPaymentRejected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPaymentRejected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPaymentRejected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPaymentCancelled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPaymentCancelled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPaymentCancelled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventOrderCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderCancelled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.CancelledBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Fees)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderPartiallyFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Fees)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderExternalIDUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventFundsCommitted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventCommitmentReleased) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.WithdrawnBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketDetailsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketOrdersEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketOrdersDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketUserSettleEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketUserSettleDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketCommitmentsEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketCommitmentsDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketIntermediaryDenomUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketPermissionsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketReqAttrUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	return n
}

func (m *EventMarketFeesUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	return n
}

func (m *EventParamsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EventPaymentCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SourceAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TargetAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPaymentUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SourceAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OldTarget)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewTarget)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TargetAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPaymentAccepted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SourceAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TargetAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPaymentRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPaymentCancelled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventOrderCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderCancelled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderCancelled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderCancelled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fees = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderPartiallyFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderPartiallyFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderPartiallyFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fees = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderExternalIDUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderExternalIDUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderExternalIDUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFundsCommitted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFundsCommitted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFundsCommitted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCommitmentReleased) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCommitmentReleased: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCommitmentReleased: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawnBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketDetailsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketDetailsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketDetailsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketOrdersEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketOrdersEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketOrdersEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketOrdersDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketOrdersDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketOrdersDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketUserSettleEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketUserSettleEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketUserSettleEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketUserSettleDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketUserSettleDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketUserSettleDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketCommitmentsEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketCommitmentsEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketCommitmentsEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketCommitmentsDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketCommitmentsDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketCommitmentsDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketIntermediaryDenomUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketIntermediaryDenomUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketIntermediaryDenomUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketPermissionsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketPermissionsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketPermissionsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketReqAttrUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketReqAttrUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketReqAttrUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketFeesUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketFeesUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketFeesUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventParamsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventParamsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventParamsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPaymentCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPaymentCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPaymentCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPaymentUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPaymentUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPaymentUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldTarget = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTarget = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPaymentAccepted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPaymentAccepted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPaymentAccepted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPaymentRejected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPaymentRejected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPaymentRejected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPaymentCancelled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPaymentCancelled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPaymentCancelled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
