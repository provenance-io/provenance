// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/asset/v1/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventAssetBurned is emitted when an asset is burned.
// This event is triggered by the MsgBurnAsset message handler when an
// asset is successfully burned and removed from circulation.
type EventAssetBurned struct {
	// asset_class_id is the class identifier of the burned asset
	AssetClassId string `protobuf:"bytes,1,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
	// asset_id is the unique identifier of the burned asset
	AssetId string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// owner is the address of the account that owned the asset before it was burned
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *EventAssetBurned) Reset()         { *m = EventAssetBurned{} }
func (m *EventAssetBurned) String() string { return proto.CompactTextString(m) }
func (*EventAssetBurned) ProtoMessage()    {}
func (*EventAssetBurned) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7fb48cc4f1623ab, []int{0}
}
func (m *EventAssetBurned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAssetBurned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAssetBurned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAssetBurned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAssetBurned.Merge(m, src)
}
func (m *EventAssetBurned) XXX_Size() int {
	return m.Size()
}
func (m *EventAssetBurned) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAssetBurned.DiscardUnknown(m)
}

var xxx_messageInfo_EventAssetBurned proto.InternalMessageInfo

func (m *EventAssetBurned) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *EventAssetBurned) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *EventAssetBurned) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// EventAssetClassCreated is emitted when a new asset class is created.
// This event is triggered by the MsgCreateAssetClass message handler when
// an asset class is successfully created.
type EventAssetClassCreated struct {
	// asset_class_id is the unique identifier of the created asset class
	AssetClassId string `protobuf:"bytes,1,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
	// asset_name is the human-readable name of the asset class
	AssetName string `protobuf:"bytes,2,opt,name=asset_name,json=assetName,proto3" json:"asset_name,omitempty"`
	// asset_symbol is the symbol or ticker for the asset class
	AssetSymbol string `protobuf:"bytes,3,opt,name=asset_symbol,json=assetSymbol,proto3" json:"asset_symbol,omitempty"`
}

func (m *EventAssetClassCreated) Reset()         { *m = EventAssetClassCreated{} }
func (m *EventAssetClassCreated) String() string { return proto.CompactTextString(m) }
func (*EventAssetClassCreated) ProtoMessage()    {}
func (*EventAssetClassCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7fb48cc4f1623ab, []int{1}
}
func (m *EventAssetClassCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAssetClassCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAssetClassCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAssetClassCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAssetClassCreated.Merge(m, src)
}
func (m *EventAssetClassCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventAssetClassCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAssetClassCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventAssetClassCreated proto.InternalMessageInfo

func (m *EventAssetClassCreated) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *EventAssetClassCreated) GetAssetName() string {
	if m != nil {
		return m.AssetName
	}
	return ""
}

func (m *EventAssetClassCreated) GetAssetSymbol() string {
	if m != nil {
		return m.AssetSymbol
	}
	return ""
}

// EventAssetCreated is emitted when a new asset is created.
// This event is triggered by the MsgCreateAsset message handler when
// an asset is successfully created and minted.
type EventAssetCreated struct {
	// asset_class_id is the class identifier of the created asset
	AssetClassId string `protobuf:"bytes,1,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
	// asset_id is the unique identifier of the created asset
	AssetId string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// owner is the address of the account that owns the newly created asset
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *EventAssetCreated) Reset()         { *m = EventAssetCreated{} }
func (m *EventAssetCreated) String() string { return proto.CompactTextString(m) }
func (*EventAssetCreated) ProtoMessage()    {}
func (*EventAssetCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7fb48cc4f1623ab, []int{2}
}
func (m *EventAssetCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAssetCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAssetCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAssetCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAssetCreated.Merge(m, src)
}
func (m *EventAssetCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventAssetCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAssetCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventAssetCreated proto.InternalMessageInfo

func (m *EventAssetCreated) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *EventAssetCreated) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *EventAssetCreated) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// EventPoolCreated is emitted when a new pool is created.
// This event is triggered by the MsgCreatePool message handler when
// a pool is successfully created with assets.
type EventPoolCreated struct {
	// pool is the coin representation of the created pool
	Pool string `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	// asset_count is the number of assets added to the pool
	AssetCount uint32 `protobuf:"varint,2,opt,name=asset_count,json=assetCount,proto3" json:"asset_count,omitempty"`
	// owner is the address of the account that created the pool
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *EventPoolCreated) Reset()         { *m = EventPoolCreated{} }
func (m *EventPoolCreated) String() string { return proto.CompactTextString(m) }
func (*EventPoolCreated) ProtoMessage()    {}
func (*EventPoolCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7fb48cc4f1623ab, []int{3}
}
func (m *EventPoolCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPoolCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPoolCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPoolCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPoolCreated.Merge(m, src)
}
func (m *EventPoolCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventPoolCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPoolCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventPoolCreated proto.InternalMessageInfo

func (m *EventPoolCreated) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *EventPoolCreated) GetAssetCount() uint32 {
	if m != nil {
		return m.AssetCount
	}
	return 0
}

func (m *EventPoolCreated) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// EventTokenizationCreated is emitted when a tokenization marker is created.
// This event is triggered by the MsgCreateTokenization message handler when
// a tokenization is successfully created for an asset.
type EventTokenizationCreated struct {
	// tokenization is the coin representation of the tokenization marker
	Tokenization string `protobuf:"bytes,1,opt,name=tokenization,proto3" json:"tokenization,omitempty"`
	// asset_class_id is the class identifier of the tokenized asset
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
	// asset_id is the unique identifier of the tokenized asset
	AssetId string `protobuf:"bytes,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// owner is the address of the account that created the tokenization
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *EventTokenizationCreated) Reset()         { *m = EventTokenizationCreated{} }
func (m *EventTokenizationCreated) String() string { return proto.CompactTextString(m) }
func (*EventTokenizationCreated) ProtoMessage()    {}
func (*EventTokenizationCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7fb48cc4f1623ab, []int{4}
}
func (m *EventTokenizationCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTokenizationCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTokenizationCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTokenizationCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTokenizationCreated.Merge(m, src)
}
func (m *EventTokenizationCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventTokenizationCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTokenizationCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventTokenizationCreated proto.InternalMessageInfo

func (m *EventTokenizationCreated) GetTokenization() string {
	if m != nil {
		return m.Tokenization
	}
	return ""
}

func (m *EventTokenizationCreated) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *EventTokenizationCreated) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *EventTokenizationCreated) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// EventSecuritizationCreated is emitted when a securitization is created.
// This event is triggered by the MsgCreateSecuritization message handler when
// a securitization is successfully created with tranches and pools.
type EventSecuritizationCreated struct {
	// securitization_id is the unique identifier of the created securitization
	SecuritizationId string `protobuf:"bytes,1,opt,name=securitization_id,json=securitizationId,proto3" json:"securitization_id,omitempty"`
	// tranche_count is the number of tranches in the securitization
	TrancheCount uint32 `protobuf:"varint,2,opt,name=tranche_count,json=trancheCount,proto3" json:"tranche_count,omitempty"`
	// pool_count is the number of pools in the securitization
	PoolCount uint32 `protobuf:"varint,3,opt,name=pool_count,json=poolCount,proto3" json:"pool_count,omitempty"`
	// owner is the address of the account that created the securitization
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *EventSecuritizationCreated) Reset()         { *m = EventSecuritizationCreated{} }
func (m *EventSecuritizationCreated) String() string { return proto.CompactTextString(m) }
func (*EventSecuritizationCreated) ProtoMessage()    {}
func (*EventSecuritizationCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7fb48cc4f1623ab, []int{5}
}
func (m *EventSecuritizationCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecuritizationCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecuritizationCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecuritizationCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecuritizationCreated.Merge(m, src)
}
func (m *EventSecuritizationCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventSecuritizationCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecuritizationCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecuritizationCreated proto.InternalMessageInfo

func (m *EventSecuritizationCreated) GetSecuritizationId() string {
	if m != nil {
		return m.SecuritizationId
	}
	return ""
}

func (m *EventSecuritizationCreated) GetTrancheCount() uint32 {
	if m != nil {
		return m.TrancheCount
	}
	return 0
}

func (m *EventSecuritizationCreated) GetPoolCount() uint32 {
	if m != nil {
		return m.PoolCount
	}
	return 0
}

func (m *EventSecuritizationCreated) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func init() {
	proto.RegisterType((*EventAssetBurned)(nil), "provenance.asset.v1.EventAssetBurned")
	proto.RegisterType((*EventAssetClassCreated)(nil), "provenance.asset.v1.EventAssetClassCreated")
	proto.RegisterType((*EventAssetCreated)(nil), "provenance.asset.v1.EventAssetCreated")
	proto.RegisterType((*EventPoolCreated)(nil), "provenance.asset.v1.EventPoolCreated")
	proto.RegisterType((*EventTokenizationCreated)(nil), "provenance.asset.v1.EventTokenizationCreated")
	proto.RegisterType((*EventSecuritizationCreated)(nil), "provenance.asset.v1.EventSecuritizationCreated")
}

func init() { proto.RegisterFile("provenance/asset/v1/events.proto", fileDescriptor_b7fb48cc4f1623ab) }

var fileDescriptor_b7fb48cc4f1623ab = []byte{
	// 457 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x4f, 0x6b, 0x13, 0x41,
	0x18, 0xc6, 0x33, 0x4d, 0xfd, 0x93, 0xb7, 0xa9, 0xb4, 0xab, 0xc8, 0xb6, 0xd0, 0xb5, 0x46, 0x0f,
	0x82, 0x74, 0x97, 0xe0, 0x27, 0x68, 0x82, 0x87, 0x20, 0x88, 0x24, 0x9e, 0xbc, 0x84, 0xc9, 0xce,
	0xd0, 0x0e, 0x66, 0xe7, 0x0d, 0x33, 0x93, 0xd4, 0x7a, 0x12, 0xf4, 0x03, 0xf8, 0x4d, 0xbc, 0x78,
	0xf5, 0xee, 0xb1, 0x78, 0xf2, 0x28, 0xc9, 0x17, 0x91, 0x7d, 0x67, 0x42, 0x92, 0xa2, 0x98, 0x80,
	0xb7, 0x7d, 0x9f, 0xf7, 0xd9, 0x7d, 0x7e, 0x3c, 0xc3, 0x2c, 0x1c, 0x8f, 0x0c, 0x4e, 0xa4, 0xe6,
	0x3a, 0x97, 0x19, 0xb7, 0x56, 0xba, 0x6c, 0xd2, 0xcc, 0xe4, 0x44, 0x6a, 0x67, 0xd3, 0x91, 0x41,
	0x87, 0xd1, 0xdd, 0x85, 0x23, 0x25, 0x47, 0x3a, 0x69, 0x1e, 0x1e, 0xe4, 0x68, 0x0b, 0xb4, 0x7d,
	0xb2, 0x64, 0x7e, 0xf0, 0xfe, 0xc6, 0x47, 0x06, 0x7b, 0xcf, 0xcb, 0x0f, 0x9c, 0x96, 0xe6, 0xd6,
	0xd8, 0x68, 0x29, 0xa2, 0xc7, 0x70, 0x87, 0xde, 0xed, 0xe7, 0x43, 0x6e, 0x6d, 0x5f, 0x89, 0x98,
	0x1d, 0xb3, 0x27, 0xb5, 0x6e, 0x9d, 0xd4, 0x76, 0x29, 0x76, 0x44, 0x74, 0x00, 0xb7, 0xbd, 0x4b,
	0x89, 0x78, 0x8b, 0xf6, 0xb7, 0x68, 0xee, 0x88, 0x28, 0x85, 0x1b, 0x78, 0xa1, 0xa5, 0x89, 0xab,
	0xa5, 0xde, 0x8a, 0x7f, 0x7c, 0x3d, 0xb9, 0x17, 0x62, 0x4f, 0x85, 0x30, 0xd2, 0xda, 0x9e, 0x33,
	0x4a, 0x9f, 0x75, 0xbd, 0xad, 0xf1, 0x81, 0xc1, 0xfd, 0x05, 0x05, 0x05, 0xb4, 0x8d, 0xe4, 0x6e,
	0x6d, 0x96, 0x23, 0x00, 0xef, 0xd2, 0xbc, 0x90, 0x81, 0xa6, 0x46, 0xca, 0x4b, 0x5e, 0xc8, 0xe8,
	0x21, 0x78, 0x7b, 0xdf, 0x5e, 0x16, 0x03, 0x1c, 0x7a, 0xac, 0xee, 0x0e, 0x69, 0x3d, 0x92, 0x1a,
	0x9f, 0x18, 0xec, 0x2f, 0x21, 0x6c, 0x94, 0xfe, 0x1f, 0x9b, 0xb8, 0x08, 0xc7, 0xf1, 0x0a, 0x71,
	0x38, 0x87, 0x88, 0x60, 0x7b, 0x84, 0x38, 0x0c, 0xd1, 0xf4, 0x1c, 0x3d, 0x80, 0x9d, 0x00, 0x86,
	0x63, 0xed, 0x28, 0x75, 0xb7, 0xeb, 0x3b, 0x68, 0x97, 0xca, 0xc6, 0xc1, 0x5f, 0x18, 0xc4, 0x94,
	0xfc, 0x1a, 0xdf, 0x4a, 0xad, 0xde, 0x73, 0xa7, 0x50, 0xcf, 0x09, 0x1a, 0x50, 0x77, 0x4b, 0xf2,
	0xbc, 0x84, 0x65, 0xed, 0x0f, 0x55, 0x6d, 0xfd, 0xa3, 0xaa, 0xea, 0x5f, 0xaa, 0xda, 0x5e, 0x8f,
	0xf8, 0x1b, 0x83, 0x43, 0x22, 0xee, 0xc9, 0x7c, 0x6c, 0x94, 0xbb, 0xc6, 0xfc, 0x14, 0xf6, 0xed,
	0xca, 0x62, 0x71, 0x7a, 0x7b, 0xab, 0x8b, 0x8e, 0x88, 0x1e, 0xc1, 0xae, 0x33, 0x5c, 0xe7, 0xe7,
	0x72, 0xa5, 0xd0, 0x7a, 0x10, 0x7d, 0xa5, 0x47, 0x00, 0x65, 0xf7, 0xc1, 0x51, 0x25, 0x47, 0xad,
	0x54, 0xae, 0x35, 0xbe, 0x1e, 0x7f, 0xeb, 0xc5, 0xf7, 0x69, 0xc2, 0xae, 0xa6, 0x09, 0xfb, 0x35,
	0x4d, 0xd8, 0xe7, 0x59, 0x52, 0xb9, 0x9a, 0x25, 0x95, 0x9f, 0xb3, 0xa4, 0xf2, 0xa6, 0x79, 0xa6,
	0xdc, 0xf9, 0x78, 0x90, 0xe6, 0x58, 0x64, 0x8b, 0xfb, 0x7c, 0xa2, 0x70, 0x69, 0xca, 0xde, 0x85,
	0x3f, 0x80, 0xbb, 0x1c, 0x49, 0x3b, 0xb8, 0x49, 0xd7, 0xf9, 0xd9, 0xef, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xff, 0x36, 0xe6, 0xb0, 0x22, 0x04, 0x00, 0x00,
}

func (m *EventAssetBurned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAssetBurned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAssetBurned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAssetClassCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAssetClassCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAssetClassCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetSymbol) > 0 {
		i -= len(m.AssetSymbol)
		copy(dAtA[i:], m.AssetSymbol)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetName) > 0 {
		i -= len(m.AssetName)
		copy(dAtA[i:], m.AssetName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAssetCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAssetCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAssetCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPoolCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPoolCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPoolCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AssetCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AssetCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Pool) > 0 {
		i -= len(m.Pool)
		copy(dAtA[i:], m.Pool)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Pool)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTokenizationCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTokenizationCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTokenizationCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tokenization) > 0 {
		i -= len(m.Tokenization)
		copy(dAtA[i:], m.Tokenization)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Tokenization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSecuritizationCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecuritizationCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecuritizationCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if m.PoolCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolCount))
		i--
		dAtA[i] = 0x18
	}
	if m.TrancheCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TrancheCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SecuritizationId) > 0 {
		i -= len(m.SecuritizationId)
		copy(dAtA[i:], m.SecuritizationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SecuritizationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventAssetBurned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventAssetClassCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AssetName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AssetSymbol)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventAssetCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPoolCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.AssetCount != 0 {
		n += 1 + sovEvents(uint64(m.AssetCount))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventTokenizationCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tokenization)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSecuritizationCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SecuritizationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.TrancheCount != 0 {
		n += 1 + sovEvents(uint64(m.TrancheCount))
	}
	if m.PoolCount != 0 {
		n += 1 + sovEvents(uint64(m.PoolCount))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventAssetBurned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAssetBurned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAssetBurned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAssetClassCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAssetClassCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAssetClassCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAssetCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAssetCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAssetCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPoolCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPoolCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPoolCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetCount", wireType)
			}
			m.AssetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTokenizationCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTokenizationCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTokenizationCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecuritizationCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecuritizationCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecuritizationCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecuritizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecuritizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrancheCount", wireType)
			}
			m.TrancheCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrancheCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolCount", wireType)
			}
			m.PoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
