// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/smartaccounts/v1/provenanceaccount.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types1 "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	types "github.com/cosmos/cosmos-sdk/x/auth/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Enum for credential type
type CredentialType int32

const (
	// Unspecified credential type
	CredentialType_CREDENTIAL_TYPE_UNSPECIFIED CredentialType = 0
	// ED25519 credential type
	CredentialType_CREDENTIAL_TYPE_ED25519 CredentialType = 1
	// K256 credential type, this will the usual cosmos credential
	CredentialType_CREDENTIAL_TYPE_K256 CredentialType = 2
	// P256 credential type
	CredentialType_CREDENTIAL_TYPE_P256 CredentialType = 3
	// WebAuthn credential type
	CredentialType_CREDENTIAL_TYPE_WEBAUTHN CredentialType = 4
	// WebAuthn with UV credential type
	CredentialType_CREDENTIAL_TYPE_WEBAUTHN_UV CredentialType = 5
)

var CredentialType_name = map[int32]string{
	0: "CREDENTIAL_TYPE_UNSPECIFIED",
	1: "CREDENTIAL_TYPE_ED25519",
	2: "CREDENTIAL_TYPE_K256",
	3: "CREDENTIAL_TYPE_P256",
	4: "CREDENTIAL_TYPE_WEBAUTHN",
	5: "CREDENTIAL_TYPE_WEBAUTHN_UV",
}

var CredentialType_value = map[string]int32{
	"CREDENTIAL_TYPE_UNSPECIFIED": 0,
	"CREDENTIAL_TYPE_ED25519":     1,
	"CREDENTIAL_TYPE_K256":        2,
	"CREDENTIAL_TYPE_P256":        3,
	"CREDENTIAL_TYPE_WEBAUTHN":    4,
	"CREDENTIAL_TYPE_WEBAUTHN_UV": 5,
}

func (x CredentialType) String() string {
	return proto.EnumName(CredentialType_name, int32(x))
}

func (CredentialType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{0}
}

// ProvenanceAccount is a Type Of Smart Account assumes presence of a BaseAccount.
type ProvenanceAccount struct {
	// address is the address of the account.
	// This will be the same as the base account based on discussion on Jan30th, 2025.
	//  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
	//  Makes inheritance explicit
	//  Provides access to BaseAccount fields (account_number, sequence, etc.)
	//  Follows Cosmos SDK conventions
	//  Simplifies implementation of account interfaces
	*types.BaseAccount `protobuf:"bytes,1,opt,name=base_account,json=baseAccount,proto3,embedded=base_account" json:"base_account,omitempty"`
	// smart_account_number is the global sequence number.
	SmartAccountNumber uint64 `protobuf:"varint,2,opt,name=smart_account_number,json=smartAccountNumber,proto3" json:"smart_account_number,omitempty"`
	// list of credential types supported by the account
	Credentials []*Credential `protobuf:"bytes,3,rep,name=credentials,proto3" json:"credentials,omitempty"`
	// set to false but if set to true only smart account authentication is allowed.
	IsSmartAccountOnlyAuthentication bool `protobuf:"varint,4,opt,name=is_smart_account_only_authentication,json=isSmartAccountOnlyAuthentication,proto3" json:"is_smart_account_only_authentication,omitempty"`
}

func (m *ProvenanceAccount) Reset()         { *m = ProvenanceAccount{} }
func (m *ProvenanceAccount) String() string { return proto.CompactTextString(m) }
func (*ProvenanceAccount) ProtoMessage()    {}
func (*ProvenanceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{0}
}
func (m *ProvenanceAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvenanceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvenanceAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvenanceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvenanceAccount.Merge(m, src)
}
func (m *ProvenanceAccount) XXX_Size() int {
	return m.Size()
}
func (m *ProvenanceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvenanceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_ProvenanceAccount proto.InternalMessageInfo

// MsgInit is used to initialize a provenance account.
type MsgInit struct {
	// sender is the address of the sender of this message.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// list of credential types supported by the account
	// at least one has to be provided.
	Credentials []*Credential `protobuf:"bytes,2,rep,name=credentials,proto3" json:"credentials,omitempty"`
}

func (m *MsgInit) Reset()         { *m = MsgInit{} }
func (m *MsgInit) String() string { return proto.CompactTextString(m) }
func (*MsgInit) ProtoMessage()    {}
func (*MsgInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{1}
}
func (m *MsgInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInit.Merge(m, src)
}
func (m *MsgInit) XXX_Size() int {
	return m.Size()
}
func (m *MsgInit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInit proto.InternalMessageInfo

func (m *MsgInit) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgInit) GetCredentials() []*Credential {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// MsgInitResponse is the response returned after smart account initialization.
// For now, This is empty.
type MsgInitResponse struct {
	// account_address is the address of the newly created account.
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address,omitempty"`
	// sequence is the current sequence of the account.
	Sequence uint64 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (m *MsgInitResponse) Reset()         { *m = MsgInitResponse{} }
func (m *MsgInitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInitResponse) ProtoMessage()    {}
func (*MsgInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{2}
}
func (m *MsgInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInitResponse.Merge(m, src)
}
func (m *MsgInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInitResponse proto.InternalMessageInfo

func (m *MsgInitResponse) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *MsgInitResponse) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type Credential struct {
	*BaseCredential `protobuf:"bytes,1,opt,name=base_credential,json=baseCredential,proto3,embedded=base_credential" json:"base_credential,omitempty"`
	// Types that are valid to be assigned to Authenticator:
	//	*Credential_Fido2Authenticator
	//	*Credential_K256Authenticator
	//	*Credential_SessionAuthenticator
	Authenticator isCredential_Authenticator `protobuf_oneof:"authenticator"`
}

func (m *Credential) Reset()         { *m = Credential{} }
func (m *Credential) String() string { return proto.CompactTextString(m) }
func (*Credential) ProtoMessage()    {}
func (*Credential) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{3}
}
func (m *Credential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Credential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Credential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Credential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Credential.Merge(m, src)
}
func (m *Credential) XXX_Size() int {
	return m.Size()
}
func (m *Credential) XXX_DiscardUnknown() {
	xxx_messageInfo_Credential.DiscardUnknown(m)
}

var xxx_messageInfo_Credential proto.InternalMessageInfo

type isCredential_Authenticator interface {
	isCredential_Authenticator()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Credential_Fido2Authenticator struct {
	Fido2Authenticator *Fido2Authenticator `protobuf:"bytes,2,opt,name=fido2_authenticator,json=fido2Authenticator,proto3,oneof" json:"fido2_authenticator,omitempty"`
}
type Credential_K256Authenticator struct {
	K256Authenticator *K256Authenticator `protobuf:"bytes,3,opt,name=k256_authenticator,json=k256Authenticator,proto3,oneof" json:"k256_authenticator,omitempty"`
}
type Credential_SessionAuthenticator struct {
	SessionAuthenticator *SessionAuthenticator `protobuf:"bytes,4,opt,name=session_authenticator,json=sessionAuthenticator,proto3,oneof" json:"session_authenticator,omitempty"`
}

func (*Credential_Fido2Authenticator) isCredential_Authenticator()   {}
func (*Credential_K256Authenticator) isCredential_Authenticator()    {}
func (*Credential_SessionAuthenticator) isCredential_Authenticator() {}

func (m *Credential) GetAuthenticator() isCredential_Authenticator {
	if m != nil {
		return m.Authenticator
	}
	return nil
}

func (m *Credential) GetFido2Authenticator() *Fido2Authenticator {
	if x, ok := m.GetAuthenticator().(*Credential_Fido2Authenticator); ok {
		return x.Fido2Authenticator
	}
	return nil
}

func (m *Credential) GetK256Authenticator() *K256Authenticator {
	if x, ok := m.GetAuthenticator().(*Credential_K256Authenticator); ok {
		return x.K256Authenticator
	}
	return nil
}

func (m *Credential) GetSessionAuthenticator() *SessionAuthenticator {
	if x, ok := m.GetAuthenticator().(*Credential_SessionAuthenticator); ok {
		return x.SessionAuthenticator
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Credential) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Credential_Fido2Authenticator)(nil),
		(*Credential_K256Authenticator)(nil),
		(*Credential_SessionAuthenticator)(nil),
	}
}

// Credential message
type BaseCredential struct {
	// assigned globally unique in order of creation (like BaseAccount.account_number)
	CredentialNumber uint64 `protobuf:"varint,1,opt,name=credential_number,json=credentialNumber,proto3" json:"credential_number,omitempty"`
	// this is the public key of the credential
	// The public key portion of a Relying Party-specific credential key pair, generated by an authenticator and returned
	// to a Relying Party at registration time (see also public key credential). The private key portion of the credential
	// key pair is known as the credential private key. Note that in the case of self attestation, the credential key pair
	// is also used as the attestation key pair, see self attestation for details.
	PublicKey *types1.Any `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// see CredentialType enum
	Variant CredentialType `protobuf:"varint,3,opt,name=variant,proto3,enum=provenance.smartaccounts.v1.CredentialType" json:"variant,omitempty"`
	// Seconds since UNIX epoch timestamp
	CreateTime int64 `protobuf:"varint,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
}

func (m *BaseCredential) Reset()         { *m = BaseCredential{} }
func (m *BaseCredential) String() string { return proto.CompactTextString(m) }
func (*BaseCredential) ProtoMessage()    {}
func (*BaseCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{4}
}
func (m *BaseCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseCredential.Merge(m, src)
}
func (m *BaseCredential) XXX_Size() int {
	return m.Size()
}
func (m *BaseCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseCredential.DiscardUnknown(m)
}

var xxx_messageInfo_BaseCredential proto.InternalMessageInfo

func (m *BaseCredential) GetCredentialNumber() uint64 {
	if m != nil {
		return m.CredentialNumber
	}
	return 0
}

func (m *BaseCredential) GetPublicKey() *types1.Any {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *BaseCredential) GetVariant() CredentialType {
	if m != nil {
		return m.Variant
	}
	return CredentialType_CREDENTIAL_TYPE_UNSPECIFIED
}

func (m *BaseCredential) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

type Fido2Authenticator struct {
	// A probabilistically-unique byte sequence identifying a public key credential source and its authentication
	// assertions. The credential id (from the id attribute) is the base64url encoding of the data contained in the
	// [[identifier]] internal slot.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// this is the username of the credential
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Note on why to store aaGuid
	// The AAGUID itself doesn’t directly identify a user but could potentially be used to infer the device type or model.
	// Storing the AAGUID is not mandatory but is useful for enforcing security policies, auditing, and accessing device
	// metadata. because of privacy, for now store it.
	Aaguid []byte `protobuf:"bytes,3,opt,name=aaguid,proto3" json:"aaguid,omitempty"`
	// This is the response returned by the browser after a WebAuthn credential
	// is created using navigator.credentials.create().
	// base64 encoded string
	CredentialCreationResponse string `protobuf:"bytes,4,opt,name=credential_creation_response,json=credentialCreationResponse,proto3" json:"credential_creation_response,omitempty"`
	// store the rp id
	RpId string `protobuf:"bytes,5,opt,name=rp_id,json=rpId,proto3" json:"rp_id,omitempty"`
	// store the rp origin
	RpOrigin string `protobuf:"bytes,6,opt,name=rp_origin,json=rpOrigin,proto3" json:"rp_origin,omitempty"`
}

func (m *Fido2Authenticator) Reset()         { *m = Fido2Authenticator{} }
func (m *Fido2Authenticator) String() string { return proto.CompactTextString(m) }
func (*Fido2Authenticator) ProtoMessage()    {}
func (*Fido2Authenticator) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{5}
}
func (m *Fido2Authenticator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fido2Authenticator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fido2Authenticator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fido2Authenticator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fido2Authenticator.Merge(m, src)
}
func (m *Fido2Authenticator) XXX_Size() int {
	return m.Size()
}
func (m *Fido2Authenticator) XXX_DiscardUnknown() {
	xxx_messageInfo_Fido2Authenticator.DiscardUnknown(m)
}

var xxx_messageInfo_Fido2Authenticator proto.InternalMessageInfo

func (m *Fido2Authenticator) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Fido2Authenticator) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Fido2Authenticator) GetAaguid() []byte {
	if m != nil {
		return m.Aaguid
	}
	return nil
}

func (m *Fido2Authenticator) GetCredentialCreationResponse() string {
	if m != nil {
		return m.CredentialCreationResponse
	}
	return ""
}

func (m *Fido2Authenticator) GetRpId() string {
	if m != nil {
		return m.RpId
	}
	return ""
}

func (m *Fido2Authenticator) GetRpOrigin() string {
	if m != nil {
		return m.RpOrigin
	}
	return ""
}

type K256Authenticator struct {
}

func (m *K256Authenticator) Reset()         { *m = K256Authenticator{} }
func (m *K256Authenticator) String() string { return proto.CompactTextString(m) }
func (*K256Authenticator) ProtoMessage()    {}
func (*K256Authenticator) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{6}
}
func (m *K256Authenticator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K256Authenticator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K256Authenticator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K256Authenticator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K256Authenticator.Merge(m, src)
}
func (m *K256Authenticator) XXX_Size() int {
	return m.Size()
}
func (m *K256Authenticator) XXX_DiscardUnknown() {
	xxx_messageInfo_K256Authenticator.DiscardUnknown(m)
}

var xxx_messageInfo_K256Authenticator proto.InternalMessageInfo

// Only valid for the duration of the session, public key for now is only k256 based.
type SessionAuthenticator struct {
	// / block height at which it is invalidated
	EndSessionHeight int64 `protobuf:"varint,1,opt,name=end_session_height,json=endSessionHeight,proto3" json:"end_session_height,omitempty"`
	// / seconds component of block consensus timestamp
	TimedOut bool `protobuf:"varint,2,opt,name=timed_out,json=timedOut,proto3" json:"timed_out,omitempty"`
}

func (m *SessionAuthenticator) Reset()         { *m = SessionAuthenticator{} }
func (m *SessionAuthenticator) String() string { return proto.CompactTextString(m) }
func (*SessionAuthenticator) ProtoMessage()    {}
func (*SessionAuthenticator) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{7}
}
func (m *SessionAuthenticator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionAuthenticator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionAuthenticator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionAuthenticator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionAuthenticator.Merge(m, src)
}
func (m *SessionAuthenticator) XXX_Size() int {
	return m.Size()
}
func (m *SessionAuthenticator) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionAuthenticator.DiscardUnknown(m)
}

var xxx_messageInfo_SessionAuthenticator proto.InternalMessageInfo

func (m *SessionAuthenticator) GetEndSessionHeight() int64 {
	if m != nil {
		return m.EndSessionHeight
	}
	return 0
}

func (m *SessionAuthenticator) GetTimedOut() bool {
	if m != nil {
		return m.TimedOut
	}
	return false
}

// Params defines the set of module parameters.
type Params struct {
	// check if the smart account module is enabled.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// max_credential_allowed is the max number of smart credentials allowed per base account.
	MaxCredentialAllowed uint32 `protobuf:"varint,2,opt,name=max_credential_allowed,json=maxCredentialAllowed,proto3" json:"max_credential_allowed,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_f95583143ed49bf1, []int{8}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Params) GetMaxCredentialAllowed() uint32 {
	if m != nil {
		return m.MaxCredentialAllowed
	}
	return 0
}

func init() {
	proto.RegisterEnum("provenance.smartaccounts.v1.CredentialType", CredentialType_name, CredentialType_value)
	proto.RegisterType((*ProvenanceAccount)(nil), "provenance.smartaccounts.v1.ProvenanceAccount")
	proto.RegisterType((*MsgInit)(nil), "provenance.smartaccounts.v1.MsgInit")
	proto.RegisterType((*MsgInitResponse)(nil), "provenance.smartaccounts.v1.MsgInitResponse")
	proto.RegisterType((*Credential)(nil), "provenance.smartaccounts.v1.Credential")
	proto.RegisterType((*BaseCredential)(nil), "provenance.smartaccounts.v1.BaseCredential")
	proto.RegisterType((*Fido2Authenticator)(nil), "provenance.smartaccounts.v1.Fido2Authenticator")
	proto.RegisterType((*K256Authenticator)(nil), "provenance.smartaccounts.v1.K256Authenticator")
	proto.RegisterType((*SessionAuthenticator)(nil), "provenance.smartaccounts.v1.SessionAuthenticator")
	proto.RegisterType((*Params)(nil), "provenance.smartaccounts.v1.Params")
}

func init() {
	proto.RegisterFile("provenance/smartaccounts/v1/provenanceaccount.proto", fileDescriptor_f95583143ed49bf1)
}

var fileDescriptor_f95583143ed49bf1 = []byte{
	// 1030 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x3f, 0x6f, 0xdb, 0x46,
	0x14, 0x17, 0x25, 0xc5, 0x96, 0x4f, 0x89, 0x2c, 0x9f, 0xd5, 0x84, 0xb1, 0x03, 0x59, 0x10, 0x0a,
	0xc4, 0x70, 0x1a, 0xb2, 0x92, 0xeb, 0x00, 0xf1, 0x54, 0xc9, 0x56, 0x60, 0x21, 0xad, 0x6d, 0xd0,
	0x76, 0x8a, 0x66, 0x21, 0x8e, 0xe4, 0x99, 0x3e, 0x58, 0xbc, 0x63, 0x79, 0xa4, 0x6b, 0x75, 0xec,
	0x54, 0x74, 0x2a, 0xd0, 0xa5, 0x63, 0xc6, 0x8e, 0x19, 0xda, 0x0f, 0xd0, 0xad, 0x43, 0x07, 0xa3,
	0x53, 0xd1, 0xa1, 0x28, 0xec, 0x21, 0xfd, 0x18, 0x05, 0x8f, 0x27, 0x51, 0xa2, 0x0d, 0x17, 0xe8,
	0x22, 0xe8, 0xbd, 0xdf, 0x7b, 0xef, 0xf7, 0xfe, 0x1e, 0x08, 0xd6, 0xfd, 0x80, 0x9d, 0x61, 0x8a,
	0xa8, 0x8d, 0x75, 0xee, 0xa1, 0x20, 0x44, 0xb6, 0xcd, 0x22, 0x1a, 0x72, 0xfd, 0xac, 0xa5, 0xa7,
	0x98, 0xd4, 0x6a, 0x7e, 0xc0, 0x42, 0x06, 0x97, 0x53, 0x40, 0x9b, 0x72, 0xd2, 0xce, 0x5a, 0x4b,
	0x0f, 0x5d, 0xc6, 0xdc, 0x01, 0xd6, 0x85, 0xa9, 0x15, 0x1d, 0xeb, 0x88, 0x0e, 0x13, 0xbf, 0xa5,
	0x07, 0x36, 0xe3, 0x1e, 0xe3, 0xba, 0xc7, 0xdd, 0x38, 0xbc, 0xc7, 0x5d, 0x09, 0xd4, 0x25, 0x60,
	0x21, 0x8e, 0xf5, 0xb3, 0x96, 0x85, 0x43, 0xd4, 0xd2, 0x6d, 0x46, 0xa8, 0xc4, 0x6b, 0x2e, 0x73,
	0x99, 0xf8, 0xab, 0xc7, 0xff, 0xa4, 0xf6, 0x61, 0xe2, 0x65, 0x26, 0x40, 0x22, 0x64, 0x02, 0xa2,
	0x28, 0x3c, 0x19, 0x07, 0x8c, 0x05, 0x89, 0x2f, 0x20, 0x8f, 0x50, 0xa6, 0x8b, 0xdf, 0x44, 0xd5,
	0xfc, 0x39, 0x0f, 0x16, 0xf6, 0xc7, 0x75, 0x75, 0x92, 0x8a, 0x60, 0x1f, 0xdc, 0x8d, 0x93, 0x32,
	0x65, 0x85, 0xaa, 0xd2, 0x50, 0x56, 0xcb, 0xed, 0x86, 0x26, 0xd9, 0x44, 0x48, 0x19, 0x5f, 0xeb,
	0x22, 0x3e, 0xf2, 0xeb, 0x16, 0x2f, 0xfe, 0x5a, 0x51, 0x8c, 0xb2, 0x95, 0xaa, 0xe0, 0x87, 0xa0,
	0x26, 0x9a, 0x35, 0x8a, 0x65, 0xd2, 0xc8, 0xb3, 0x70, 0xa0, 0xe6, 0x1b, 0xca, 0x6a, 0xd1, 0x80,
	0x02, 0x93, 0xb6, 0xbb, 0x02, 0x81, 0x7d, 0x50, 0xb6, 0x03, 0xec, 0x60, 0x1a, 0x12, 0x34, 0xe0,
	0x6a, 0xa1, 0x51, 0x58, 0x2d, 0xb7, 0x1f, 0x6b, 0xb7, 0x74, 0x5f, 0xdb, 0x1a, 0xdb, 0x1b, 0x93,
	0xbe, 0x70, 0x17, 0xbc, 0x4f, 0xb8, 0x39, 0xcd, 0xcf, 0xe8, 0x60, 0x68, 0xc6, 0x15, 0xc4, 0x46,
	0x36, 0x0a, 0x09, 0xa3, 0x6a, 0xb1, 0xa1, 0xac, 0x96, 0x8c, 0x06, 0xe1, 0x07, 0x13, 0xe9, 0xec,
	0xd1, 0xc1, 0xb0, 0x33, 0x65, 0xb7, 0x59, 0xfa, 0xe6, 0xcd, 0x4a, 0xee, 0x9f, 0x37, 0x2b, 0xb9,
	0xe6, 0xf7, 0x0a, 0x98, 0xfd, 0x94, 0xbb, 0x7d, 0x4a, 0xe2, 0x12, 0x67, 0x38, 0xa6, 0x0e, 0x0e,
	0x44, 0x9f, 0xe6, 0xba, 0xea, 0xef, 0x3f, 0x3d, 0xad, 0xc9, 0x56, 0x75, 0x1c, 0x27, 0xc0, 0x9c,
	0x1f, 0x84, 0x01, 0xa1, 0xae, 0x21, 0xed, 0xb2, 0x25, 0xe6, 0xff, 0x7f, 0x89, 0x9b, 0xe5, 0xaf,
	0xdf, 0xbd, 0x5d, 0x93, 0x71, 0x9b, 0xaf, 0xc0, 0xbc, 0x4c, 0xca, 0xc0, 0xdc, 0x67, 0x94, 0x63,
	0xf8, 0x18, 0xcc, 0x8f, 0x2a, 0x47, 0x49, 0x2e, 0x49, 0x96, 0x46, 0x45, 0xaa, 0x65, 0x86, 0x70,
	0x09, 0x94, 0x38, 0xfe, 0x22, 0xc2, 0xd4, 0xc6, 0x72, 0x38, 0x63, 0xb9, 0xf9, 0x63, 0x01, 0x80,
	0x34, 0x01, 0xf8, 0x1a, 0xcc, 0x8b, 0xf5, 0x48, 0xf3, 0x90, 0x1b, 0xf2, 0xe4, 0xd6, 0x12, 0xe2,
	0x4d, 0x49, 0xa3, 0xc8, 0x65, 0xa9, 0x58, 0x53, 0x5a, 0x68, 0x81, 0xc5, 0x63, 0xe2, 0xb0, 0xf6,
	0xe4, 0x88, 0x58, 0xb2, 0x2e, 0xe5, 0xb6, 0x7e, 0x6b, 0xfc, 0x17, 0xb1, 0x5f, 0x67, 0xd2, 0x6d,
	0x27, 0x67, 0xc0, 0xe3, 0x6b, 0x5a, 0x68, 0x02, 0x78, 0xda, 0xde, 0x78, 0x96, 0xa1, 0x28, 0x08,
	0x0a, 0xed, 0x56, 0x8a, 0x97, 0xed, 0x8d, 0x67, 0x59, 0x86, 0x85, 0xd3, 0xac, 0x12, 0x9e, 0x80,
	0xf7, 0x38, 0xe6, 0x9c, 0x30, 0x9a, 0xe1, 0x28, 0x0a, 0x8e, 0xd6, 0xad, 0x1c, 0x07, 0x89, 0x67,
	0x96, 0xa6, 0xc6, 0x6f, 0xd0, 0x77, 0xe7, 0xc1, 0xbd, 0x29, 0x86, 0xe6, 0x9f, 0x0a, 0xa8, 0x4c,
	0x37, 0x1a, 0x3e, 0x01, 0x0b, 0xe9, 0xa4, 0x46, 0xf7, 0xa7, 0x88, 0x11, 0x57, 0x53, 0x40, 0x5e,
	0xdf, 0x3a, 0x00, 0x7e, 0x64, 0x0d, 0x88, 0x6d, 0x9e, 0xe2, 0xa1, 0x6c, 0x7b, 0x4d, 0x4b, 0x5e,
	0x37, 0x6d, 0xf4, 0xba, 0x69, 0x1d, 0x3a, 0x34, 0xe6, 0x12, 0xbb, 0x97, 0x78, 0x08, 0x7b, 0x60,
	0xf6, 0x0c, 0x05, 0x04, 0xd1, 0x50, 0x74, 0xb1, 0xf2, 0x1f, 0x8b, 0x90, 0xe6, 0x76, 0x38, 0xf4,
	0xb1, 0x31, 0xf2, 0x85, 0x2b, 0xe2, 0x2c, 0x50, 0x88, 0xcd, 0x90, 0x78, 0x58, 0x34, 0xab, 0x60,
	0x80, 0x44, 0x75, 0x48, 0x3c, 0xdc, 0xfc, 0x4d, 0x01, 0xf0, 0xfa, 0x94, 0x61, 0x05, 0xe4, 0x89,
	0x23, 0xd7, 0x3a, 0x4f, 0x9c, 0x78, 0x95, 0x23, 0x8e, 0x03, 0x8a, 0xbc, 0x64, 0x95, 0xe7, 0x8c,
	0xb1, 0x0c, 0xef, 0x83, 0x19, 0x84, 0xdc, 0x88, 0x38, 0x22, 0xd3, 0xbb, 0x86, 0x94, 0xe0, 0xc7,
	0xe0, 0xd1, 0x44, 0x93, 0x04, 0x67, 0x3c, 0xbe, 0x40, 0xde, 0x91, 0x48, 0x66, 0xce, 0x58, 0x4a,
	0x6d, 0xb6, 0xa4, 0xc9, 0xf8, 0xd2, 0x16, 0xc1, 0x9d, 0xc0, 0x37, 0x89, 0xa3, 0xde, 0x11, 0xa6,
	0xc5, 0xc0, 0xef, 0x3b, 0x70, 0x19, 0xcc, 0x05, 0xbe, 0xc9, 0x02, 0xe2, 0x12, 0xaa, 0xce, 0x24,
	0xb9, 0x04, 0xfe, 0x9e, 0x90, 0x9b, 0x8b, 0x60, 0xe1, 0xda, 0x42, 0x35, 0x11, 0xa8, 0xdd, 0xb4,
	0x01, 0xf0, 0x03, 0x00, 0x31, 0x75, 0xcc, 0xd1, 0x5e, 0x9d, 0x60, 0xe2, 0x9e, 0x24, 0x2f, 0x73,
	0xc1, 0xa8, 0x62, 0xea, 0x48, 0xa7, 0x1d, 0xa1, 0x8f, 0x79, 0xe3, 0x1e, 0x3a, 0x26, 0x8b, 0x42,
	0xd1, 0x83, 0x92, 0x51, 0x12, 0x8a, 0xbd, 0x28, 0x6c, 0x7e, 0x05, 0x66, 0xf6, 0x51, 0x80, 0x3c,
	0x0e, 0x55, 0x30, 0x8b, 0x29, 0xb2, 0x06, 0x38, 0x69, 0x5f, 0xc9, 0x18, 0x89, 0xf0, 0x23, 0x70,
	0xdf, 0x43, 0xe7, 0x13, 0x27, 0x6e, 0xa2, 0xc1, 0x80, 0x7d, 0x89, 0x1d, 0x11, 0xed, 0x9e, 0x51,
	0xf3, 0xd0, 0x79, 0x3a, 0xc7, 0x4e, 0x82, 0x6d, 0x36, 0x7e, 0x48, 0x1e, 0x48, 0xe5, 0xdb, 0x77,
	0x6f, 0xd7, 0x16, 0x27, 0x07, 0xaf, 0xfb, 0x82, 0x71, 0xed, 0x17, 0x05, 0x54, 0xa6, 0xe7, 0x0f,
	0x57, 0xc0, 0xf2, 0x96, 0xd1, 0xdb, 0xee, 0xed, 0x1e, 0xf6, 0x3b, 0x9f, 0x98, 0x87, 0x9f, 0xef,
	0xf7, 0xcc, 0xa3, 0xdd, 0x83, 0xfd, 0xde, 0x56, 0xff, 0x45, 0xbf, 0xb7, 0x5d, 0xcd, 0xc1, 0x65,
	0xf0, 0x20, 0x6b, 0xd0, 0xdb, 0x6e, 0x6f, 0x6c, 0xb4, 0x9e, 0x57, 0x15, 0xa8, 0x82, 0x5a, 0x16,
	0x8c, 0x9b, 0x5a, 0xcd, 0xdf, 0x84, 0xec, 0xc7, 0x48, 0x01, 0x3e, 0x02, 0x6a, 0x16, 0xf9, 0xac,
	0xd7, 0xed, 0x1c, 0x1d, 0xee, 0xec, 0x56, 0x8b, 0x37, 0xe5, 0x33, 0x42, 0xcd, 0xa3, 0x57, 0xd5,
	0x3b, 0xdd, 0x83, 0x5f, 0x2f, 0xeb, 0xca, 0xc5, 0x65, 0x5d, 0xf9, 0xfb, 0xb2, 0xae, 0x7c, 0x77,
	0x55, 0xcf, 0x5d, 0x5c, 0xd5, 0x73, 0x7f, 0x5c, 0xd5, 0x73, 0xaf, 0x9f, 0xbb, 0x24, 0x3c, 0x89,
	0x2c, 0xcd, 0x66, 0xde, 0xc4, 0x77, 0xc4, 0x53, 0xc2, 0x26, 0x24, 0xfd, 0x3c, 0xf3, 0xcd, 0x11,
	0x0e, 0x7d, 0xcc, 0xad, 0x19, 0x71, 0x5c, 0xeb, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xf1, 0x51,
	0x6b, 0x69, 0x9c, 0x08, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.MaxCredentialAllowed != that1.MaxCredentialAllowed {
		return false
	}
	return true
}
func (m *ProvenanceAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvenanceAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvenanceAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSmartAccountOnlyAuthentication {
		i--
		if m.IsSmartAccountOnlyAuthentication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Credentials) > 0 {
		for iNdEx := len(m.Credentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SmartAccountNumber != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.SmartAccountNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.BaseAccount != nil {
		{
			size, err := m.BaseAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for iNdEx := len(m.Credentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Credential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Authenticator != nil {
		{
			size := m.Authenticator.Size()
			i -= size
			if _, err := m.Authenticator.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.BaseCredential != nil {
		{
			size, err := m.BaseCredential.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Credential_Fido2Authenticator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credential_Fido2Authenticator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Fido2Authenticator != nil {
		{
			size, err := m.Fido2Authenticator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Credential_K256Authenticator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credential_K256Authenticator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.K256Authenticator != nil {
		{
			size, err := m.K256Authenticator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Credential_SessionAuthenticator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credential_SessionAuthenticator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionAuthenticator != nil {
		{
			size, err := m.SessionAuthenticator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BaseCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateTime != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Variant != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.Variant))
		i--
		dAtA[i] = 0x18
	}
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvenanceaccount(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CredentialNumber != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.CredentialNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Fido2Authenticator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fido2Authenticator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fido2Authenticator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RpOrigin) > 0 {
		i -= len(m.RpOrigin)
		copy(dAtA[i:], m.RpOrigin)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.RpOrigin)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RpId) > 0 {
		i -= len(m.RpId)
		copy(dAtA[i:], m.RpId)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.RpId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CredentialCreationResponse) > 0 {
		i -= len(m.CredentialCreationResponse)
		copy(dAtA[i:], m.CredentialCreationResponse)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.CredentialCreationResponse)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aaguid) > 0 {
		i -= len(m.Aaguid)
		copy(dAtA[i:], m.Aaguid)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.Aaguid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K256Authenticator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K256Authenticator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K256Authenticator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SessionAuthenticator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionAuthenticator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionAuthenticator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimedOut {
		i--
		if m.TimedOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EndSessionHeight != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.EndSessionHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxCredentialAllowed != 0 {
		i = encodeVarintProvenanceaccount(dAtA, i, uint64(m.MaxCredentialAllowed))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProvenanceaccount(dAtA []byte, offset int, v uint64) int {
	offset -= sovProvenanceaccount(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProvenanceAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseAccount != nil {
		l = m.BaseAccount.Size()
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	if m.SmartAccountNumber != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.SmartAccountNumber))
	}
	if len(m.Credentials) > 0 {
		for _, e := range m.Credentials {
			l = e.Size()
			n += 1 + l + sovProvenanceaccount(uint64(l))
		}
	}
	if m.IsSmartAccountOnlyAuthentication {
		n += 2
	}
	return n
}

func (m *MsgInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	if len(m.Credentials) > 0 {
		for _, e := range m.Credentials {
			l = e.Size()
			n += 1 + l + sovProvenanceaccount(uint64(l))
		}
	}
	return n
}

func (m *MsgInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.Sequence))
	}
	return n
}

func (m *Credential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseCredential != nil {
		l = m.BaseCredential.Size()
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	if m.Authenticator != nil {
		n += m.Authenticator.Size()
	}
	return n
}

func (m *Credential_Fido2Authenticator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fido2Authenticator != nil {
		l = m.Fido2Authenticator.Size()
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	return n
}
func (m *Credential_K256Authenticator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K256Authenticator != nil {
		l = m.K256Authenticator.Size()
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	return n
}
func (m *Credential_SessionAuthenticator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionAuthenticator != nil {
		l = m.SessionAuthenticator.Size()
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	return n
}
func (m *BaseCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CredentialNumber != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.CredentialNumber))
	}
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	if m.Variant != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.Variant))
	}
	if m.CreateTime != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.CreateTime))
	}
	return n
}

func (m *Fido2Authenticator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	l = len(m.Aaguid)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	l = len(m.CredentialCreationResponse)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	l = len(m.RpId)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	l = len(m.RpOrigin)
	if l > 0 {
		n += 1 + l + sovProvenanceaccount(uint64(l))
	}
	return n
}

func (m *K256Authenticator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SessionAuthenticator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndSessionHeight != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.EndSessionHeight))
	}
	if m.TimedOut {
		n += 2
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.MaxCredentialAllowed != 0 {
		n += 1 + sovProvenanceaccount(uint64(m.MaxCredentialAllowed))
	}
	return n
}

func sovProvenanceaccount(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProvenanceaccount(x uint64) (n int) {
	return sovProvenanceaccount(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProvenanceAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvenanceAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvenanceAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseAccount == nil {
				m.BaseAccount = &types.BaseAccount{}
			}
			if err := m.BaseAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartAccountNumber", wireType)
			}
			m.SmartAccountNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmartAccountNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = append(m.Credentials, &Credential{})
			if err := m.Credentials[len(m.Credentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSmartAccountOnlyAuthentication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSmartAccountOnlyAuthentication = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = append(m.Credentials, &Credential{})
			if err := m.Credentials[len(m.Credentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCredential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseCredential == nil {
				m.BaseCredential = &BaseCredential{}
			}
			if err := m.BaseCredential.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fido2Authenticator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Fido2Authenticator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Authenticator = &Credential_Fido2Authenticator{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K256Authenticator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K256Authenticator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Authenticator = &Credential_K256Authenticator{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAuthenticator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionAuthenticator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Authenticator = &Credential_SessionAuthenticator{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialNumber", wireType)
			}
			m.CredentialNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CredentialNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &types1.Any{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variant", wireType)
			}
			m.Variant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Variant |= CredentialType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fido2Authenticator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fido2Authenticator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fido2Authenticator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaguid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aaguid = append(m.Aaguid[:0], dAtA[iNdEx:postIndex]...)
			if m.Aaguid == nil {
				m.Aaguid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialCreationResponse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialCreationResponse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K256Authenticator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K256Authenticator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K256Authenticator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionAuthenticator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionAuthenticator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionAuthenticator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSessionHeight", wireType)
			}
			m.EndSessionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndSessionHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimedOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimedOut = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCredentialAllowed", wireType)
			}
			m.MaxCredentialAllowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCredentialAllowed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProvenanceaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvenanceaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProvenanceaccount(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProvenanceaccount
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProvenanceaccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProvenanceaccount
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProvenanceaccount
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProvenanceaccount
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProvenanceaccount        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProvenanceaccount          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProvenanceaccount = fmt.Errorf("proto: unexpected end of group")
)
