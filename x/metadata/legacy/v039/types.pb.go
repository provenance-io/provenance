// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v0/types.proto

package v039

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PublicKeyType int32

const (
	PublicKeyType_ELLIPTIC PublicKeyType = 0
)

var PublicKeyType_name = map[int32]string{
	0: "ELLIPTIC",
}

var PublicKeyType_value = map[string]int32{
	"ELLIPTIC": 0,
}

func (x PublicKeyType) String() string {
	return proto.EnumName(PublicKeyType_name, int32(x))
}

func (PublicKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{0}
}

type PublicKeyCurve int32

const (
	PublicKeyCurve_SECP256K1 PublicKeyCurve = 0
	PublicKeyCurve_P256      PublicKeyCurve = 1
)

var PublicKeyCurve_name = map[int32]string{
	0: "SECP256K1",
	1: "P256",
}

var PublicKeyCurve_value = map[string]int32{
	"SECP256K1": 0,
	"P256":      1,
}

func (x PublicKeyCurve) String() string {
	return proto.EnumName(PublicKeyCurve_name, int32(x))
}

func (PublicKeyCurve) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{1}
}

type PartyType int32

const (
	PartyType_PARTY_TYPE_UNKNOWN    PartyType = 0
	PartyType_PARTY_TYPE_ORIGINATOR PartyType = 1
	PartyType_PARTY_TYPE_SERVICER   PartyType = 2
	PartyType_PARTY_TYPE_INVESTOR   PartyType = 3
	PartyType_PARTY_TYPE_CUSTODIAN  PartyType = 4
	PartyType_PARTY_TYPE_OWNER      PartyType = 5
	PartyType_PARTY_TYPE_AFFILIATE  PartyType = 6
	PartyType_PARTY_TYPE_OMNIBUS    PartyType = 7
	PartyType_PARTY_TYPE_PROVENANCE PartyType = 8
	PartyType_PARTY_TYPE_MARKER     PartyType = 9
)

var PartyType_name = map[int32]string{
	0: "PARTY_TYPE_UNKNOWN",
	1: "PARTY_TYPE_ORIGINATOR",
	2: "PARTY_TYPE_SERVICER",
	3: "PARTY_TYPE_INVESTOR",
	4: "PARTY_TYPE_CUSTODIAN",
	5: "PARTY_TYPE_OWNER",
	6: "PARTY_TYPE_AFFILIATE",
	7: "PARTY_TYPE_OMNIBUS",
	8: "PARTY_TYPE_PROVENANCE",
	9: "PARTY_TYPE_MARKER",
}

var PartyType_value = map[string]int32{
	"PARTY_TYPE_UNKNOWN":    0,
	"PARTY_TYPE_ORIGINATOR": 1,
	"PARTY_TYPE_SERVICER":   2,
	"PARTY_TYPE_INVESTOR":   3,
	"PARTY_TYPE_CUSTODIAN":  4,
	"PARTY_TYPE_OWNER":      5,
	"PARTY_TYPE_AFFILIATE":  6,
	"PARTY_TYPE_OMNIBUS":    7,
	"PARTY_TYPE_PROVENANCE": 8,
	"PARTY_TYPE_MARKER":     9,
}

func (x PartyType) String() string {
	return proto.EnumName(PartyType_name, int32(x))
}

func (PartyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{2}
}

// Wrapper for an ISO8601 date string. EX: "2020-05-22"
type Date struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Date) Reset()         { *m = Date{} }
func (m *Date) String() string { return proto.CompactTextString(m) }
func (*Date) ProtoMessage()    {}
func (*Date) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{0}
}
func (m *Date) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Date) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Date.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Date) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Date.Merge(m, src)
}
func (m *Date) XXX_Size() int {
	return m.Size()
}
func (m *Date) XXX_DiscardUnknown() {
	xxx_messageInfo_Date.DiscardUnknown(m)
}

var xxx_messageInfo_Date proto.InternalMessageInfo

func (m *Date) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Wrapper type for a standard uuid.
type UUID struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UUID) Reset()         { *m = UUID{} }
func (m *UUID) String() string { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()    {}
func (*UUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{1}
}
func (m *UUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID.Merge(m, src)
}
func (m *UUID) XXX_Size() int {
	return m.Size()
}
func (m *UUID) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID.DiscardUnknown(m)
}

var xxx_messageInfo_UUID proto.InternalMessageInfo

func (m *UUID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Wrap a boolean result type.
type BooleanResult struct {
	Value bool `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *BooleanResult) Reset()         { *m = BooleanResult{} }
func (m *BooleanResult) String() string { return proto.CompactTextString(m) }
func (*BooleanResult) ProtoMessage()    {}
func (*BooleanResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{2}
}
func (m *BooleanResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BooleanResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BooleanResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BooleanResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BooleanResult.Merge(m, src)
}
func (m *BooleanResult) XXX_Size() int {
	return m.Size()
}
func (m *BooleanResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BooleanResult.DiscardUnknown(m)
}

var xxx_messageInfo_BooleanResult proto.InternalMessageInfo

func (m *BooleanResult) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

// Wrap a location.
type Location struct {
	Ref       *ProvenanceReference `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	Classname string               `protobuf:"bytes,2,opt,name=classname,proto3" json:"classname,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{3}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetRef() *ProvenanceReference {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Location) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

// Wrap a factual data element.
type Fact struct {
	Name         string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DataLocation *Location `protobuf:"bytes,2,opt,name=data_location,json=dataLocation,proto3" json:"data_location,omitempty"`
}

func (m *Fact) Reset()         { *m = Fact{} }
func (m *Fact) String() string { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()    {}
func (*Fact) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{4}
}
func (m *Fact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fact.Merge(m, src)
}
func (m *Fact) XXX_Size() int {
	return m.Size()
}
func (m *Fact) XXX_DiscardUnknown() {
	xxx_messageInfo_Fact.DiscardUnknown(m)
}

var xxx_messageInfo_Fact proto.InternalMessageInfo

func (m *Fact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Fact) GetDataLocation() *Location {
	if m != nil {
		return m.DataLocation
	}
	return nil
}

type ProvenanceReference struct {
	// [Req] [Scope.uuid]
	// Scope ID
	ScopeUuid *UUID `protobuf:"bytes,1,opt,name=scope_uuid,json=scopeUuid,proto3" json:"scope_uuid,omitempty"`
	// [Opt] [RecordGroup.group_uuid]
	// require record to be within a specific group
	GroupUuid *UUID `protobuf:"bytes,2,opt,name=group_uuid,json=groupUuid,proto3" json:"group_uuid,omitempty"`
	// [Opt] [Record.result_hash]
	// specify a specific record inside a scope (and group) by result-hash
	Hash string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	// [Opt] [Record.result_name]
	// specify a result-name of a record within a scope
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ProvenanceReference) Reset()         { *m = ProvenanceReference{} }
func (m *ProvenanceReference) String() string { return proto.CompactTextString(m) }
func (*ProvenanceReference) ProtoMessage()    {}
func (*ProvenanceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{5}
}
func (m *ProvenanceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvenanceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvenanceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvenanceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvenanceReference.Merge(m, src)
}
func (m *ProvenanceReference) XXX_Size() int {
	return m.Size()
}
func (m *ProvenanceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvenanceReference.DiscardUnknown(m)
}

var xxx_messageInfo_ProvenanceReference proto.InternalMessageInfo

func (m *ProvenanceReference) GetScopeUuid() *UUID {
	if m != nil {
		return m.ScopeUuid
	}
	return nil
}

func (m *ProvenanceReference) GetGroupUuid() *UUID {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *ProvenanceReference) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProvenanceReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Wrapper around a standard signature.
type Signature struct {
	// Signature Detail
	Algo      string `protobuf:"bytes,1,opt,name=algo,proto3" json:"algo,omitempty"`
	Provider  string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	Signature string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Identity of signer
	Signer *SigningAndEncryptionPublicKeys `protobuf:"bytes,4,opt,name=signer,proto3" json:"signer,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{6}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *Signature) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Signature) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

// A collection of signatures
type SignatureSet struct {
	Signatures []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *SignatureSet) Reset()         { *m = SignatureSet{} }
func (m *SignatureSet) String() string { return proto.CompactTextString(m) }
func (*SignatureSet) ProtoMessage()    {}
func (*SignatureSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{7}
}
func (m *SignatureSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureSet.Merge(m, src)
}
func (m *SignatureSet) XXX_Size() int {
	return m.Size()
}
func (m *SignatureSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureSet.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureSet proto.InternalMessageInfo

func (m *SignatureSet) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type PublicKey struct {
	PublicKeyBytes []byte         `protobuf:"bytes,1,opt,name=public_key_bytes,json=publicKeyBytes,proto3" json:"public_key_bytes,omitempty"`
	Type           PublicKeyType  `protobuf:"varint,2,opt,name=type,proto3,enum=types.PublicKeyType" json:"type,omitempty"`
	Curve          PublicKeyCurve `protobuf:"varint,3,opt,name=curve,proto3,enum=types.PublicKeyCurve" json:"curve,omitempty"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{8}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKeyBytes() []byte {
	if m != nil {
		return m.PublicKeyBytes
	}
	return nil
}

func (m *PublicKey) GetType() PublicKeyType {
	if m != nil {
		return m.Type
	}
	return PublicKeyType_ELLIPTIC
}

func (m *PublicKey) GetCurve() PublicKeyCurve {
	if m != nil {
		return m.Curve
	}
	return PublicKeyCurve_SECP256K1
}

type SigningAndEncryptionPublicKeys struct {
	SigningPublicKey    *PublicKey `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	EncryptionPublicKey *PublicKey `protobuf:"bytes,2,opt,name=encryption_public_key,json=encryptionPublicKey,proto3" json:"encryption_public_key,omitempty"`
}

func (m *SigningAndEncryptionPublicKeys) Reset()         { *m = SigningAndEncryptionPublicKeys{} }
func (m *SigningAndEncryptionPublicKeys) String() string { return proto.CompactTextString(m) }
func (*SigningAndEncryptionPublicKeys) ProtoMessage()    {}
func (*SigningAndEncryptionPublicKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{9}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningAndEncryptionPublicKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.Merge(m, src)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Size() int {
	return m.Size()
}
func (m *SigningAndEncryptionPublicKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.DiscardUnknown(m)
}

var xxx_messageInfo_SigningAndEncryptionPublicKeys proto.InternalMessageInfo

func (m *SigningAndEncryptionPublicKeys) GetSigningPublicKey() *PublicKey {
	if m != nil {
		return m.SigningPublicKey
	}
	return nil
}

func (m *SigningAndEncryptionPublicKeys) GetEncryptionPublicKey() *PublicKey {
	if m != nil {
		return m.EncryptionPublicKey
	}
	return nil
}

// Audit
type AuditFields struct {
	CreatedDate *GogoTimeHack `protobuf:"bytes,1,opt,name=created_date,json=createdDate,proto3" json:"created_date,omitempty"`
	CreatedBy   string        `protobuf:"bytes,2,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	UpdatedDate *GogoTimeHack `protobuf:"bytes,3,opt,name=updated_date,json=updatedDate,proto3" json:"updated_date,omitempty"`
	UpdatedBy   string        `protobuf:"bytes,4,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty"`
	Version     int32         `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	Message     string        `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *AuditFields) Reset()         { *m = AuditFields{} }
func (m *AuditFields) String() string { return proto.CompactTextString(m) }
func (*AuditFields) ProtoMessage()    {}
func (*AuditFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{10}
}
func (m *AuditFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditFields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditFields.Merge(m, src)
}
func (m *AuditFields) XXX_Size() int {
	return m.Size()
}
func (m *AuditFields) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditFields.DiscardUnknown(m)
}

var xxx_messageInfo_AuditFields proto.InternalMessageInfo

func (m *AuditFields) GetCreatedDate() *GogoTimeHack {
	if m != nil {
		return m.CreatedDate
	}
	return nil
}

func (m *AuditFields) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *AuditFields) GetUpdatedDate() *GogoTimeHack {
	if m != nil {
		return m.UpdatedDate
	}
	return nil
}

func (m *AuditFields) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

func (m *AuditFields) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *AuditFields) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// proto 3 timestamp structure (hack to get around gogo issues with invalid dates)
type GogoTimeHack struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Nanos   int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *GogoTimeHack) Reset()         { *m = GogoTimeHack{} }
func (m *GogoTimeHack) String() string { return proto.CompactTextString(m) }
func (*GogoTimeHack) ProtoMessage()    {}
func (*GogoTimeHack) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac8a3eaef23a1ec9, []int{11}
}
func (m *GogoTimeHack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GogoTimeHack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GogoTimeHack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GogoTimeHack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GogoTimeHack.Merge(m, src)
}
func (m *GogoTimeHack) XXX_Size() int {
	return m.Size()
}
func (m *GogoTimeHack) XXX_DiscardUnknown() {
	xxx_messageInfo_GogoTimeHack.DiscardUnknown(m)
}

var xxx_messageInfo_GogoTimeHack proto.InternalMessageInfo

func (m *GogoTimeHack) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *GogoTimeHack) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

func init() {
	proto.RegisterEnum("types.PublicKeyType", PublicKeyType_name, PublicKeyType_value)
	proto.RegisterEnum("types.PublicKeyCurve", PublicKeyCurve_name, PublicKeyCurve_value)
	proto.RegisterEnum("types.PartyType", PartyType_name, PartyType_value)
	proto.RegisterType((*Date)(nil), "types.Date")
	proto.RegisterType((*UUID)(nil), "types.UUID")
	proto.RegisterType((*BooleanResult)(nil), "types.BooleanResult")
	proto.RegisterType((*Location)(nil), "types.Location")
	proto.RegisterType((*Fact)(nil), "types.Fact")
	proto.RegisterType((*ProvenanceReference)(nil), "types.ProvenanceReference")
	proto.RegisterType((*Signature)(nil), "types.Signature")
	proto.RegisterType((*SignatureSet)(nil), "types.SignatureSet")
	proto.RegisterType((*PublicKey)(nil), "types.PublicKey")
	proto.RegisterType((*SigningAndEncryptionPublicKeys)(nil), "types.SigningAndEncryptionPublicKeys")
	proto.RegisterType((*AuditFields)(nil), "types.AuditFields")
	proto.RegisterType((*GogoTimeHack)(nil), "types.GogoTimeHack")
}

func init() {
	proto.RegisterFile("provenance/metadata/v0/types.proto", fileDescriptor_ac8a3eaef23a1ec9)
}

var fileDescriptor_ac8a3eaef23a1ec9 = []byte{
	// 911 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0xf5, 0xe3, 0x48, 0x23, 0xd9, 0x65, 0xd7, 0x76, 0xab, 0x04, 0x89, 0x60, 0x10, 0x08,
	0xa0, 0xba, 0xad, 0xe4, 0x2a, 0x6d, 0x80, 0x16, 0x68, 0x50, 0x4a, 0xa6, 0x53, 0xc2, 0x0e, 0x45,
	0xac, 0x24, 0x07, 0xe9, 0x45, 0x58, 0x91, 0x1b, 0x99, 0x08, 0x45, 0xb2, 0xfc, 0x11, 0xca, 0x7b,
	0x8f, 0x3d, 0xf4, 0x52, 0xa0, 0x4f, 0xd0, 0x67, 0xe9, 0x31, 0xc7, 0x1e, 0x0b, 0xfb, 0x01, 0xfa,
	0x0a, 0xc5, 0x2e, 0x49, 0x91, 0x56, 0x12, 0xdf, 0x76, 0xe6, 0xfb, 0xe6, 0x9b, 0x6f, 0x56, 0x43,
	0x2d, 0x48, 0x9e, 0xef, 0xae, 0xa9, 0x43, 0x1c, 0x83, 0xf6, 0x57, 0x34, 0x24, 0x26, 0x09, 0x49,
	0x7f, 0x7d, 0xd2, 0x0f, 0x63, 0x8f, 0x06, 0x3d, 0xcf, 0x77, 0x43, 0x17, 0xd5, 0x78, 0x20, 0x3d,
	0x84, 0xea, 0x29, 0x09, 0x29, 0x3a, 0x80, 0xda, 0x9a, 0xd8, 0x11, 0x6d, 0x0b, 0x47, 0x42, 0xb7,
	0x81, 0x93, 0x80, 0xa1, 0xb3, 0x99, 0x7a, 0xfa, 0x01, 0xf4, 0x31, 0xec, 0x0e, 0x5d, 0xd7, 0xa6,
	0xc4, 0xc1, 0x34, 0x88, 0xec, 0xf0, 0x36, 0xad, 0x9e, 0xd1, 0x2e, 0xa1, 0x7e, 0xe1, 0x1a, 0x24,
	0xb4, 0x5c, 0x07, 0x7d, 0x01, 0x15, 0x9f, 0xbe, 0xe6, 0x78, 0x73, 0xf0, 0xa0, 0x97, 0x18, 0xd2,
	0x37, 0x6e, 0x31, 0x7d, 0x4d, 0x7d, 0xca, 0x0e, 0x8c, 0x86, 0x1e, 0x42, 0xc3, 0xb0, 0x49, 0x10,
	0x38, 0x64, 0x45, 0xdb, 0x65, 0xde, 0x3a, 0x4f, 0x48, 0x3a, 0x54, 0xcf, 0x88, 0x11, 0x22, 0x04,
	0x55, 0x4e, 0x48, 0xbc, 0xf1, 0x33, 0xfa, 0x1a, 0x76, 0xd9, 0xd0, 0x73, 0x3b, 0x6d, 0xcc, 0xab,
	0x9b, 0x83, 0x8f, 0xd2, 0x8e, 0x99, 0x1f, 0xdc, 0x62, 0xac, 0x2c, 0x92, 0xfe, 0x10, 0x60, 0xff,
	0x3d, 0x66, 0xd0, 0x31, 0x40, 0x60, 0xb8, 0x1e, 0x9d, 0x47, 0x91, 0x65, 0xa6, 0xe6, 0x9b, 0xa9,
	0x14, 0xbb, 0x1f, 0xdc, 0xe0, 0xf0, 0x2c, 0xb2, 0x4c, 0xc6, 0x5d, 0xfa, 0x6e, 0xe4, 0x25, 0xdc,
	0xf2, 0x7b, 0xb8, 0x1c, 0xe6, 0x5c, 0x04, 0xd5, 0x2b, 0x12, 0x5c, 0xb5, 0x2b, 0x89, 0x73, 0x76,
	0xde, 0x4c, 0x53, 0xcd, 0xa7, 0x91, 0xfe, 0x14, 0xa0, 0x31, 0xb1, 0x96, 0x0e, 0x09, 0x23, 0x9f,
	0x32, 0x06, 0xb1, 0x97, 0x6e, 0x36, 0x2f, 0x3b, 0xa3, 0x07, 0x50, 0x67, 0xbf, 0xb9, 0x65, 0x52,
	0x3f, 0xbd, 0xa8, 0x4d, 0xcc, 0x6e, 0x31, 0xc8, 0x8a, 0xd3, 0x56, 0x79, 0x02, 0x7d, 0x0f, 0x3b,
	0x2c, 0xa0, 0x3e, 0xef, 0xd8, 0x1c, 0x3c, 0x4e, 0xbd, 0xb2, 0x7e, 0x96, 0xb3, 0x94, 0x1d, 0x53,
	0x71, 0x0c, 0x3f, 0xf6, 0xd8, 0x05, 0xe9, 0xd1, 0xc2, 0xb6, 0x8c, 0x73, 0x1a, 0x07, 0x38, 0x2d,
	0x92, 0x7e, 0x80, 0xd6, 0xc6, 0xd9, 0x84, 0x86, 0xe8, 0x04, 0x60, 0xa3, 0x1d, 0xb4, 0x85, 0xa3,
	0x4a, 0xb7, 0x39, 0x10, 0x0b, 0x92, 0x1c, 0xc0, 0x05, 0x8e, 0xf4, 0x9b, 0x00, 0x8d, 0x8d, 0x30,
	0xea, 0x82, 0xe8, 0xf1, 0x60, 0xfe, 0x86, 0xc6, 0xf3, 0x45, 0x1c, 0x72, 0x15, 0xa1, 0xdb, 0xc2,
	0x7b, 0x5e, 0x46, 0x1a, 0xb2, 0x2c, 0xea, 0x42, 0x95, 0xc9, 0xf2, 0x71, 0xf7, 0x06, 0x07, 0xd9,
	0x2e, 0x65, 0xa4, 0x69, 0xec, 0x51, 0xcc, 0x19, 0xe8, 0x73, 0xa8, 0x19, 0x91, 0xbf, 0x4e, 0x86,
	0xdf, 0x1b, 0x1c, 0x6e, 0x53, 0x47, 0x0c, 0xc4, 0x09, 0x47, 0xfa, 0x4b, 0x80, 0xce, 0xdd, 0xb3,
	0xa3, 0x67, 0x80, 0x82, 0x84, 0x31, 0xcf, 0xbd, 0xa6, 0x6b, 0x21, 0x6e, 0x8b, 0x63, 0x31, 0xe5,
	0xe6, 0x33, 0x9e, 0xc2, 0x21, 0xdd, 0xe8, 0x16, 0x25, 0xca, 0x1f, 0x90, 0xd8, 0xa7, 0xef, 0xda,
	0x90, 0xfe, 0x13, 0xa0, 0x29, 0x47, 0xa6, 0x15, 0x9e, 0x59, 0xd4, 0x36, 0x03, 0xf4, 0x14, 0x5a,
	0x86, 0x4f, 0x49, 0x48, 0xcd, 0xb9, 0x49, 0x42, 0x9a, 0xfa, 0xd9, 0x4f, 0xc5, 0x9e, 0xbb, 0x4b,
	0x77, 0x6a, 0xad, 0xe8, 0x8f, 0xc4, 0x78, 0x83, 0x9b, 0x29, 0x91, 0x7f, 0xf9, 0x8f, 0x00, 0xb2,
	0xba, 0x45, 0xbc, 0xf9, 0xca, 0x92, 0xcc, 0x30, 0x66, 0xb2, 0x91, 0x67, 0xe6, 0xb2, 0x95, 0x3b,
	0x64, 0x53, 0x62, 0x26, 0x9b, 0xd5, 0x2d, 0xe2, 0x74, 0x9b, 0x1b, 0x69, 0x66, 0x18, 0xa3, 0x36,
	0xdc, 0x5b, 0x53, 0x3f, 0x60, 0x9f, 0x66, 0xed, 0x48, 0xe8, 0xd6, 0x70, 0x16, 0x32, 0x64, 0x45,
	0x83, 0x80, 0x2c, 0x69, 0x7b, 0x87, 0x57, 0x65, 0xa1, 0xf4, 0x0c, 0x5a, 0xc5, 0x7e, 0x8c, 0x19,
	0x50, 0xc3, 0x75, 0xcc, 0x64, 0x45, 0x2a, 0x38, 0x0b, 0xd9, 0x1f, 0x91, 0x43, 0x1c, 0x37, 0xe0,
	0xe3, 0xd4, 0x70, 0x12, 0x1c, 0x3f, 0x82, 0xdd, 0x5b, 0xeb, 0x81, 0x5a, 0x50, 0x57, 0x2e, 0x2e,
	0x54, 0x7d, 0xaa, 0x8e, 0xc4, 0xd2, 0xf1, 0x67, 0xb0, 0x77, 0x7b, 0x25, 0xd0, 0x2e, 0x34, 0x26,
	0xca, 0x48, 0x1f, 0x7c, 0xf3, 0xf4, 0xfc, 0x2b, 0xb1, 0x84, 0xea, 0x50, 0x65, 0x67, 0x51, 0x38,
	0xfe, 0xb5, 0x0c, 0x0d, 0x9d, 0xf8, 0x61, 0x22, 0xf3, 0x09, 0x20, 0x5d, 0xc6, 0xd3, 0x57, 0xf3,
	0xe9, 0x2b, 0x5d, 0x99, 0xcf, 0xb4, 0x73, 0x6d, 0xfc, 0x52, 0x13, 0x4b, 0xe8, 0x3e, 0x1c, 0x16,
	0xf2, 0x63, 0xac, 0x3e, 0x57, 0x35, 0x79, 0x3a, 0xc6, 0xa2, 0x80, 0x3e, 0x85, 0xfd, 0x02, 0x34,
	0x51, 0xf0, 0xa5, 0x3a, 0x52, 0xb0, 0x58, 0xde, 0x02, 0x54, 0xed, 0x52, 0x99, 0xb0, 0x8a, 0x0a,
	0x6a, 0xc3, 0x41, 0x01, 0x18, 0xcd, 0x26, 0xd3, 0xf1, 0xa9, 0x2a, 0x6b, 0x62, 0x15, 0x1d, 0x80,
	0x58, 0x6c, 0xf3, 0x52, 0x53, 0xb0, 0x58, 0xdb, 0xe2, 0xcb, 0x67, 0x67, 0xea, 0x85, 0x2a, 0x4f,
	0x15, 0x71, 0x67, 0xcb, 0xee, 0xf8, 0x85, 0xa6, 0x0e, 0x67, 0x13, 0xf1, 0xde, 0x96, 0x5d, 0x1d,
	0x8f, 0x2f, 0x15, 0x4d, 0xd6, 0x46, 0x8a, 0x58, 0x47, 0x87, 0xf0, 0x71, 0x01, 0x7a, 0x21, 0xe3,
	0x73, 0x05, 0x8b, 0x8d, 0xe1, 0xcf, 0x7f, 0x5f, 0x77, 0x84, 0xb7, 0xd7, 0x1d, 0xe1, 0xdf, 0xeb,
	0x8e, 0xf0, 0xfb, 0x4d, 0xa7, 0xf4, 0xf6, 0xa6, 0x53, 0xfa, 0xe7, 0xa6, 0x53, 0x82, 0xfb, 0x96,
	0xdb, 0xcb, 0x1f, 0xa1, 0x5e, 0xf6, 0x08, 0xf5, 0xd6, 0x27, 0xba, 0xf0, 0xd3, 0x77, 0x4b, 0x2b,
	0xbc, 0x8a, 0x16, 0x3d, 0xc3, 0x5d, 0xf5, 0x73, 0xd2, 0x97, 0x96, 0x5b, 0x88, 0xfa, 0xbf, 0xe4,
	0x2f, 0x97, 0x4d, 0x97, 0xc4, 0x88, 0xfb, 0xeb, 0x93, 0x27, 0xdf, 0x2e, 0x76, 0xf8, 0xeb, 0xf5,
	0xe4, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xaa, 0x37, 0x01, 0x13, 0xe3, 0x06, 0x00, 0x00,
}

func (m *Date) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Date) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Date) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BooleanResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BooleanResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BooleanResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value {
		i--
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Fact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataLocation != nil {
		{
			size, err := m.DataLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvenanceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvenanceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvenanceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupUuid != nil {
		{
			size, err := m.GroupUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ScopeUuid != nil {
		{
			size, err := m.ScopeUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Algo) > 0 {
		i -= len(m.Algo)
		copy(dAtA[i:], m.Algo)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Algo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Curve != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Curve))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicKeyBytes) > 0 {
		i -= len(m.PublicKeyBytes)
		copy(dAtA[i:], m.PublicKeyBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningAndEncryptionPublicKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningAndEncryptionPublicKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningAndEncryptionPublicKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptionPublicKey != nil {
		{
			size, err := m.EncryptionPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SigningPublicKey != nil {
		{
			size, err := m.SigningPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditFields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditFields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x32
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x22
	}
	if m.UpdatedDate != nil {
		{
			size, err := m.UpdatedDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if m.CreatedDate != nil {
		{
			size, err := m.CreatedDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GogoTimeHack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GogoTimeHack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GogoTimeHack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Date) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BooleanResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value {
		n += 2
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Fact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DataLocation != nil {
		l = m.DataLocation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ProvenanceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopeUuid != nil {
		l = m.ScopeUuid.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GroupUuid != nil {
		l = m.GroupUuid.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SignatureSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKeyBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Curve != 0 {
		n += 1 + sovTypes(uint64(m.Curve))
	}
	return n
}

func (m *SigningAndEncryptionPublicKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningPublicKey != nil {
		l = m.SigningPublicKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EncryptionPublicKey != nil {
		l = m.EncryptionPublicKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuditFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatedDate != nil {
		l = m.CreatedDate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UpdatedDate != nil {
		l = m.UpdatedDate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GogoTimeHack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovTypes(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovTypes(uint64(m.Nanos))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Date) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Date: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Date: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BooleanResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BooleanResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BooleanResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ProvenanceReference{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataLocation == nil {
				m.DataLocation = &Location{}
			}
			if err := m.DataLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvenanceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvenanceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvenanceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeUuid == nil {
				m.ScopeUuid = &UUID{}
			}
			if err := m.ScopeUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupUuid == nil {
				m.GroupUuid = &UUID{}
			}
			if err := m.GroupUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBytes = append(m.PublicKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyBytes == nil {
				m.PublicKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PublicKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			m.Curve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curve |= PublicKeyCurve(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningAndEncryptionPublicKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningPublicKey == nil {
				m.SigningPublicKey = &PublicKey{}
			}
			if err := m.SigningPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionPublicKey == nil {
				m.EncryptionPublicKey = &PublicKey{}
			}
			if err := m.EncryptionPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedDate == nil {
				m.CreatedDate = &GogoTimeHack{}
			}
			if err := m.CreatedDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedDate == nil {
				m.UpdatedDate = &GogoTimeHack{}
			}
			if err := m.UpdatedDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GogoTimeHack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GogoTimeHack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GogoTimeHack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
