// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v0/scope.proto

package v039

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/protobuf/types/descriptorpb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RecordInputType indicates if an input is data on or off chain.
type RecordInputType int32

const (
	// invalid status
	RecordInputType_RECORD_INPUT_TYPE_UNKNOWN RecordInputType = 0
	// input is proposed data for recording to the blockchain
	RecordInputType_RECORD_INPUT_TYPE_PROPOSED RecordInputType = 1
	// input is a data element referencing an existing scope/record on chain
	RecordInputType_RECORD_INPUT_TYPE_FACT RecordInputType = 2
)

var RecordInputType_name = map[int32]string{
	0: "RECORD_INPUT_TYPE_UNKNOWN",
	1: "RECORD_INPUT_TYPE_PROPOSED",
	2: "RECORD_INPUT_TYPE_FACT",
}

var RecordInputType_value = map[string]int32{
	"RECORD_INPUT_TYPE_UNKNOWN":  0,
	"RECORD_INPUT_TYPE_PROPOSED": 1,
	"RECORD_INPUT_TYPE_FACT":     2,
}

func (x RecordInputType) String() string {
	return proto.EnumName(RecordInputType_name, int32(x))
}

func (RecordInputType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{0}
}

// Event references in relation to scope
type Event struct {
	GroupUuid     *UUID `protobuf:"bytes,1,opt,name=group_uuid,json=groupUuid,proto3" json:"group_uuid,omitempty"`
	ExecutionUuid *UUID `protobuf:"bytes,2,opt,name=execution_uuid,json=executionUuid,proto3" json:"execution_uuid,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{0}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetGroupUuid() *UUID {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *Event) GetExecutionUuid() *UUID {
	if m != nil {
		return m.ExecutionUuid
	}
	return nil
}

// A ContractScope is a context that binds multiple p8e working together to create a set of facts managed a defined
// set of affiliates.
type Scope struct {
	// Unique ID for building up ProvenanceReferences
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Required parties on this scope.  These are union with any contract specific recital requirements
	Parties []*Recital `protobuf:"bytes,2,rep,name=parties,proto3" json:"parties,omitempty"`
	// Each contract memorialized in this scope is stored in this list of contract_group.  The list of groups is keyed
	// as a hashmap based on the contract_spec_ref as a unique key.
	RecordGroup []*RecordGroup `protobuf:"bytes,3,rep,name=record_group,json=recordGroup,proto3" json:"record_group,omitempty"`
	// Last event that resulted in scope changes.
	LastEvent *Event `protobuf:"bytes,4,opt,name=last_event,json=lastEvent,proto3" json:"last_event,omitempty"`
}

func (m *Scope) Reset()         { *m = Scope{} }
func (m *Scope) String() string { return proto.CompactTextString(m) }
func (*Scope) ProtoMessage()    {}
func (*Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{1}
}
func (m *Scope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Scope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Scope.Merge(m, src)
}
func (m *Scope) XXX_Size() int {
	return m.Size()
}
func (m *Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_Scope.DiscardUnknown(m)
}

var xxx_messageInfo_Scope proto.InternalMessageInfo

func (m *Scope) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Scope) GetParties() []*Recital {
	if m != nil {
		return m.Parties
	}
	return nil
}

func (m *Scope) GetRecordGroup() []*RecordGroup {
	if m != nil {
		return m.RecordGroup
	}
	return nil
}

func (m *Scope) GetLastEvent() *Event {
	if m != nil {
		return m.LastEvent
	}
	return nil
}

// A collection wrapper around scopes
type ScopeCollection struct {
	Scopes []*Scope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes,omitempty"`
}

func (m *ScopeCollection) Reset()         { *m = ScopeCollection{} }
func (m *ScopeCollection) String() string { return proto.CompactTextString(m) }
func (*ScopeCollection) ProtoMessage()    {}
func (*ScopeCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{2}
}
func (m *ScopeCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeCollection.Merge(m, src)
}
func (m *ScopeCollection) XXX_Size() int {
	return m.Size()
}
func (m *ScopeCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeCollection.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeCollection proto.InternalMessageInfo

func (m *ScopeCollection) GetScopes() []*Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

// An record group is created for each contract memorialized against a scope.  This tracks who controls each record for
// future use.
type RecordGroup struct {
	// contract.spec.data_location.hash -- the specific contract specification that was used to create this group.
	Specification string `protobuf:"bytes,1,opt,name=specification,proto3" json:"specification,omitempty"`
	// Unique ID for building up ProvenanceReferences.  Set to the value on of group_uuid on the incoming contract ref.
	GroupUuid *UUID `protobuf:"bytes,2,opt,name=group_uuid,json=groupUuid,proto3" json:"group_uuid,omitempty"`
	// Identity that is memorializing this contract
	Executor *SigningAndEncryptionPublicKeys `protobuf:"bytes,3,opt,name=executor,proto3" json:"executor,omitempty"`
	// Set of identities that signed this contract
	Parties []*Recital `protobuf:"bytes,4,rep,name=parties,proto3" json:"parties,omitempty"`
	// Accumulated records (of fact) resulting from Considerations
	Records []*Record `protobuf:"bytes,5,rep,name=records,proto3" json:"records,omitempty"`
	// name of the class associated with this record group specification
	Classname string `protobuf:"bytes,6,opt,name=classname,proto3" json:"classname,omitempty"`
	// Created by, updated by, timestamps, version number, and related info.
	Audit *AuditFields `protobuf:"bytes,99,opt,name=audit,proto3" json:"audit,omitempty"`
}

func (m *RecordGroup) Reset()         { *m = RecordGroup{} }
func (m *RecordGroup) String() string { return proto.CompactTextString(m) }
func (*RecordGroup) ProtoMessage()    {}
func (*RecordGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{3}
}
func (m *RecordGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordGroup.Merge(m, src)
}
func (m *RecordGroup) XXX_Size() int {
	return m.Size()
}
func (m *RecordGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RecordGroup proto.InternalMessageInfo

func (m *RecordGroup) GetSpecification() string {
	if m != nil {
		return m.Specification
	}
	return ""
}

func (m *RecordGroup) GetGroupUuid() *UUID {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *RecordGroup) GetExecutor() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *RecordGroup) GetParties() []*Recital {
	if m != nil {
		return m.Parties
	}
	return nil
}

func (m *RecordGroup) GetRecords() []*Record {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *RecordGroup) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

func (m *RecordGroup) GetAudit() *AuditFields {
	if m != nil {
		return m.Audit
	}
	return nil
}

// A record (of fact) is attached to an group or each consideration output from a contract.
type Record struct {
	// ConsiderationSpec.func_name <--> ConsiderationProto.consideration_name (method on the classname below that
	// generated this)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ConsiderationSpec.outputSpec.spec.resourceLocation.ref.hash (this is the hash of the consideration which generated
	// the record, see also result_hash)
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// ContractSpec.definition.resourceLocation.classname (class that contains the method 'name' as given above)
	Classname string `protobuf:"bytes,3,opt,name=classname,proto3" json:"classname,omitempty"`
	// ConsiderationProto.inputs for reference with ConsiderationSpec.input_spec for type
	Inputs []*RecordInput `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// ConsiderationProto.result.result      (indicates SKIP [not allowed], PASS, or FAIL result)
	Result ExecutionResultType `protobuf:"varint,5,opt,name=result,proto3,enum=contract.ExecutionResultType" json:"result,omitempty"`
	// ConsiderationProto.result.output.name
	ResultName string `protobuf:"bytes,6,opt,name=result_name,json=resultName,proto3" json:"result_name,omitempty"`
	// ConsiderationProto.result.output.hash (the hash of the data output from the consideration)
	ResultHash string `protobuf:"bytes,7,opt,name=result_hash,json=resultHash,proto3" json:"result_hash,omitempty"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{4}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Record) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Record) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

func (m *Record) GetInputs() []*RecordInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Record) GetResult() ExecutionResultType {
	if m != nil {
		return m.Result
	}
	return ExecutionResultType_RESULT_TYPE_UNKNOWN
}

func (m *Record) GetResultName() string {
	if m != nil {
		return m.ResultName
	}
	return ""
}

func (m *Record) GetResultHash() string {
	if m != nil {
		return m.ResultHash
	}
	return ""
}

// Tracks the inputs used with a Consideration to establish the output record.
// FACT references must have come from the input fact list.
// For proposed we will only have the hash
type RecordInput struct {
	// Name value included to link back to the definition spec.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// For proposed facts we only have the hash ... for facts this hash maps to something in the input list.
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// from proposed fact structure to unmarshal
	Classname string `protobuf:"bytes,3,opt,name=classname,proto3" json:"classname,omitempty"`
	// Indicates if this input was a recorded fact on chain or just a given hashed input
	Type RecordInputType `protobuf:"varint,4,opt,name=type,proto3,enum=scope.RecordInputType" json:"type,omitempty"`
}

func (m *RecordInput) Reset()         { *m = RecordInput{} }
func (m *RecordInput) String() string { return proto.CompactTextString(m) }
func (*RecordInput) ProtoMessage()    {}
func (*RecordInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_430f1e4495b31692, []int{5}
}
func (m *RecordInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordInput.Merge(m, src)
}
func (m *RecordInput) XXX_Size() int {
	return m.Size()
}
func (m *RecordInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordInput.DiscardUnknown(m)
}

var xxx_messageInfo_RecordInput proto.InternalMessageInfo

func (m *RecordInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecordInput) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *RecordInput) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

func (m *RecordInput) GetType() RecordInputType {
	if m != nil {
		return m.Type
	}
	return RecordInputType_RECORD_INPUT_TYPE_UNKNOWN
}

func init() {
	proto.RegisterEnum("scope.RecordInputType", RecordInputType_name, RecordInputType_value)
	proto.RegisterType((*Event)(nil), "scope.Event")
	proto.RegisterType((*Scope)(nil), "scope.Scope")
	proto.RegisterType((*ScopeCollection)(nil), "scope.ScopeCollection")
	proto.RegisterType((*RecordGroup)(nil), "scope.RecordGroup")
	proto.RegisterType((*Record)(nil), "scope.Record")
	proto.RegisterType((*RecordInput)(nil), "scope.RecordInput")
}

func init() {
	proto.RegisterFile("provenance/metadata/v0/scope.proto", fileDescriptor_430f1e4495b31692)
}

var fileDescriptor_430f1e4495b31692 = []byte{
	// 705 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xcf, 0x4e, 0xdb, 0x4a,
	0x14, 0xc6, 0xe3, 0xfc, 0xe3, 0xe6, 0x84, 0x7f, 0x77, 0x16, 0xc8, 0x44, 0x97, 0x10, 0x45, 0xa0,
	0x1b, 0x81, 0xae, 0x8d, 0x82, 0xd0, 0x55, 0xbb, 0x4b, 0x21, 0xb4, 0x08, 0x29, 0x89, 0x86, 0x44,
	0x55, 0xbb, 0x89, 0x9c, 0xf1, 0xe0, 0x8c, 0x64, 0x3c, 0xae, 0x3d, 0x8e, 0xc8, 0xaa, 0xaf, 0xd0,
	0xd7, 0xe9, 0xae, 0xcb, 0x2e, 0x59, 0x76, 0x59, 0xc1, 0x23, 0xf4, 0x05, 0x2a, 0x1f, 0x27, 0x24,
	0x21, 0xa2, 0xdd, 0x74, 0x37, 0x33, 0xdf, 0x6f, 0xce, 0x9c, 0xef, 0x9b, 0xd1, 0x40, 0xd5, 0x0f,
	0xe4, 0x88, 0x7b, 0x96, 0xc7, 0xb8, 0x79, 0xc3, 0x95, 0x65, 0x5b, 0xca, 0x32, 0x47, 0x47, 0x66,
	0xc8, 0xa4, 0xcf, 0x0d, 0x3f, 0x90, 0x4a, 0x92, 0x1c, 0x4e, 0x4a, 0xfb, 0xcf, 0xa0, 0x4c, 0x7a,
	0x2a, 0xb0, 0x98, 0x4a, 0xe8, 0xd2, 0x73, 0x15, 0xd5, 0xd8, 0xe7, 0xe1, 0x84, 0xa9, 0x38, 0x52,
	0x3a, 0x2e, 0x37, 0x71, 0x36, 0x88, 0xae, 0x4d, 0x9b, 0x87, 0x2c, 0x10, 0xbe, 0x92, 0x41, 0x42,
	0x54, 0x1d, 0xc8, 0x35, 0x47, 0xdc, 0x53, 0xe4, 0x00, 0xc0, 0x09, 0x64, 0xe4, 0xf7, 0xa3, 0x48,
	0xd8, 0xba, 0x56, 0xd1, 0x6a, 0xc5, 0x7a, 0xd1, 0x48, 0x8a, 0xf5, 0x7a, 0x17, 0x67, 0xb4, 0x80,
	0x72, 0x2f, 0x12, 0x36, 0xa9, 0xc3, 0x3a, 0xbf, 0xe5, 0x2c, 0x52, 0x42, 0x7a, 0x09, 0x9f, 0x5e,
	0xe6, 0xd7, 0x1e, 0x91, 0x78, 0x4f, 0xf5, 0xb3, 0x06, 0xb9, 0xab, 0xd8, 0x1f, 0xd9, 0x85, 0xec,
	0x73, 0x67, 0xa0, 0x40, 0x0e, 0x61, 0xc5, 0xb7, 0x02, 0x25, 0x78, 0xa8, 0xa7, 0x2b, 0x99, 0x5a,
	0xb1, 0xfe, 0xb7, 0xf1, 0xe8, 0x9d, 0x72, 0x26, 0x94, 0xe5, 0xd2, 0x29, 0x41, 0x4e, 0x60, 0x35,
	0xe0, 0x4c, 0x06, 0x76, 0x1f, 0xfb, 0xd3, 0x33, 0xb8, 0x83, 0x18, 0x49, 0xb0, 0x14, 0xa5, 0xd7,
	0xb1, 0x42, 0x8b, 0xc1, 0x6c, 0x42, 0x0e, 0x01, 0x5c, 0x2b, 0x54, 0x7d, 0x1e, 0x9b, 0xd7, 0xb3,
	0xd8, 0xca, 0xea, 0x64, 0x13, 0x06, 0x42, 0x0b, 0xb1, 0x8e, 0xc3, 0xea, 0xff, 0xb0, 0x81, 0xad,
	0x9f, 0x4a, 0xd7, 0xe5, 0x2c, 0xb6, 0x44, 0xf6, 0x20, 0x8f, 0x70, 0xa8, 0x6b, 0x78, 0xe0, 0x74,
	0x2f, 0x72, 0x74, 0xa2, 0x55, 0xbf, 0xa4, 0xa1, 0x38, 0xd7, 0x02, 0xd9, 0x83, 0xb5, 0xd0, 0xe7,
	0x4c, 0x5c, 0x0b, 0x66, 0xc5, 0x65, 0x30, 0x83, 0x02, 0x5d, 0x5c, 0x7c, 0x72, 0x15, 0xe9, 0x5f,
	0x5e, 0x45, 0x03, 0xfe, 0x4a, 0x72, 0x96, 0x81, 0x9e, 0x41, 0x72, 0x7f, 0x42, 0x5e, 0x09, 0xc7,
	0x13, 0x9e, 0xd3, 0xf0, 0xec, 0xa6, 0xc7, 0x82, 0xb1, 0x1f, 0x97, 0xee, 0x44, 0x03, 0x57, 0xb0,
	0x4b, 0x3e, 0x0e, 0xe9, 0xe3, 0xb6, 0xf9, 0xb8, 0xb3, 0xbf, 0x8d, 0xfb, 0x5f, 0x58, 0x49, 0x62,
	0x0c, 0xf5, 0x1c, 0xc2, 0x6b, 0x0b, 0x49, 0xd3, 0xa9, 0x4a, 0xfe, 0x81, 0x02, 0x73, 0xad, 0x30,
	0xf4, 0xac, 0x1b, 0xae, 0xe7, 0xd1, 0xe6, 0x6c, 0x81, 0xd4, 0x20, 0x67, 0x45, 0xb6, 0x50, 0x3a,
	0xc3, 0x9e, 0xc9, 0xa4, 0xe7, 0x46, 0xbc, 0x76, 0x2e, 0xb8, 0x6b, 0x87, 0x34, 0x01, 0xaa, 0x3f,
	0x34, 0xc8, 0x27, 0xb5, 0x09, 0x81, 0x2c, 0x56, 0x4b, 0x42, 0xc3, 0x71, 0xbc, 0x36, 0xb4, 0xc2,
	0x21, 0xa6, 0x54, 0xa0, 0x38, 0x5e, 0x3c, 0x3a, 0xf3, 0xf4, 0xe8, 0x03, 0xc8, 0x0b, 0xcf, 0x8f,
	0xd4, 0xd4, 0xed, 0xe2, 0x53, 0xb9, 0x88, 0x25, 0x3a, 0x21, 0xc8, 0x09, 0xe4, 0x03, 0x1e, 0x46,
	0xae, 0xd2, 0x73, 0x15, 0xad, 0xb6, 0x5e, 0xdf, 0x99, 0x25, 0xd3, 0x9c, 0xbe, 0x6e, 0x8a, 0x40,
	0x77, 0x1c, 0x5f, 0x7b, 0x02, 0x93, 0x5d, 0x28, 0x26, 0xa3, 0xfe, 0x9c, 0x7b, 0x48, 0x96, 0x5a,
	0x71, 0x0f, 0x33, 0x00, 0x9b, 0x5f, 0x99, 0x07, 0xde, 0x58, 0xe1, 0xb0, 0xfa, 0x71, 0xfa, 0x6e,
	0xb0, 0x9f, 0x3f, 0xe6, 0x3c, 0x1b, 0xc7, 0x8c, 0xaf, 0x7d, 0xbd, 0xbe, 0xb5, 0xec, 0x1b, 0x4d,
	0x20, 0x73, 0xe0, 0xc2, 0xc6, 0x13, 0x81, 0xec, 0xc0, 0x36, 0x6d, 0x9e, 0xb6, 0xe9, 0x59, 0xff,
	0xa2, 0xd5, 0xe9, 0x75, 0xfb, 0xdd, 0x77, 0x9d, 0x66, 0xbf, 0xd7, 0xba, 0x6c, 0xb5, 0xdf, 0xb6,
	0x36, 0x53, 0xa4, 0x0c, 0xa5, 0x65, 0xb9, 0x43, 0xdb, 0x9d, 0xf6, 0x55, 0xf3, 0x6c, 0x53, 0x23,
	0x25, 0xd8, 0x5a, 0xd6, 0xcf, 0x1b, 0xa7, 0xdd, 0xcd, 0xf4, 0xab, 0x0f, 0x5f, 0xef, 0xcb, 0xda,
	0xdd, 0x7d, 0x59, 0xfb, 0x7e, 0x5f, 0xd6, 0x3e, 0x3d, 0x94, 0x53, 0x77, 0x0f, 0xe5, 0xd4, 0xb7,
	0x87, 0x72, 0x0a, 0xb6, 0x85, 0x34, 0x66, 0x1f, 0x9d, 0x31, 0xfd, 0xe8, 0x8c, 0xd1, 0x51, 0x47,
	0x7b, 0xff, 0xd2, 0x11, 0x6a, 0x18, 0x0d, 0x0c, 0x26, 0x6f, 0xcc, 0x19, 0xf4, 0x9f, 0x90, 0x73,
	0x33, 0xf3, 0x76, 0xf6, 0x3b, 0xba, 0xdc, 0xb1, 0xd8, 0xd8, 0x1c, 0x1d, 0x1d, 0xbf, 0x18, 0xe4,
	0xf1, 0xff, 0x3b, 0xfe, 0x19, 0x00, 0x00, 0xff, 0xff, 0x22, 0xdf, 0xac, 0x60, 0x99, 0x05, 0x00,
	0x00,
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutionUuid != nil {
		{
			size, err := m.ExecutionUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupUuid != nil {
		{
			size, err := m.GroupUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Scope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Scope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Scope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastEvent != nil {
		{
			size, err := m.LastEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.RecordGroup) > 0 {
		for iNdEx := len(m.RecordGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecordGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Parties) > 0 {
		for iNdEx := len(m.Parties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Uuid != nil {
		{
			size, err := m.Uuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopeCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecordGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Audit != nil {
		{
			size, err := m.Audit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Parties) > 0 {
		for iNdEx := len(m.Parties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Executor != nil {
		{
			size, err := m.Executor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupUuid != nil {
		{
			size, err := m.GroupUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Specification) > 0 {
		i -= len(m.Specification)
		copy(dAtA[i:], m.Specification)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Specification)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResultHash) > 0 {
		i -= len(m.ResultHash)
		copy(dAtA[i:], m.ResultHash)
		i = encodeVarintScope(dAtA, i, uint64(len(m.ResultHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ResultName) > 0 {
		i -= len(m.ResultName)
		copy(dAtA[i:], m.ResultName)
		i = encodeVarintScope(dAtA, i, uint64(len(m.ResultName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Result != 0 {
		i = encodeVarintScope(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecordInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintScope(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintScope(dAtA []byte, offset int, v uint64) int {
	offset -= sovScope(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupUuid != nil {
		l = m.GroupUuid.Size()
		n += 1 + l + sovScope(uint64(l))
	}
	if m.ExecutionUuid != nil {
		l = m.ExecutionUuid.Size()
		n += 1 + l + sovScope(uint64(l))
	}
	return n
}

func (m *Scope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uuid != nil {
		l = m.Uuid.Size()
		n += 1 + l + sovScope(uint64(l))
	}
	if len(m.Parties) > 0 {
		for _, e := range m.Parties {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	if len(m.RecordGroup) > 0 {
		for _, e := range m.RecordGroup {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	if m.LastEvent != nil {
		l = m.LastEvent.Size()
		n += 1 + l + sovScope(uint64(l))
	}
	return n
}

func (m *ScopeCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	return n
}

func (m *RecordGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Specification)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.GroupUuid != nil {
		l = m.GroupUuid.Size()
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Executor != nil {
		l = m.Executor.Size()
		n += 1 + l + sovScope(uint64(l))
	}
	if len(m.Parties) > 0 {
		for _, e := range m.Parties {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Audit != nil {
		l = m.Audit.Size()
		n += 2 + l + sovScope(uint64(l))
	}
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	if m.Result != 0 {
		n += 1 + sovScope(uint64(m.Result))
	}
	l = len(m.ResultName)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.ResultHash)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	return n
}

func (m *RecordInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovScope(uint64(m.Type))
	}
	return n
}

func sovScope(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScope(x uint64) (n int) {
	return sovScope(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupUuid == nil {
				m.GroupUuid = &UUID{}
			}
			if err := m.GroupUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutionUuid == nil {
				m.ExecutionUuid = &UUID{}
			}
			if err := m.ExecutionUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Scope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uuid == nil {
				m.Uuid = &UUID{}
			}
			if err := m.Uuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parties = append(m.Parties, &Recital{})
			if err := m.Parties[len(m.Parties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordGroup = append(m.RecordGroup, &RecordGroup{})
			if err := m.RecordGroup[len(m.RecordGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvent == nil {
				m.LastEvent = &Event{}
			}
			if err := m.LastEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, &Scope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Specification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupUuid == nil {
				m.GroupUuid = &UUID{}
			}
			if err := m.GroupUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Executor == nil {
				m.Executor = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Executor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parties = append(m.Parties, &Recital{})
			if err := m.Parties[len(m.Parties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &Record{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audit == nil {
				m.Audit = &AuditFields{}
			}
			if err := m.Audit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &RecordInput{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ExecutionResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RecordInputType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScope(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScope
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScope
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScope
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScope
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScope
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScope
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScope        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScope          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScope = fmt.Errorf("proto: unexpected end of group")
)
