package types

import (
	"errors"
	"fmt"
	"net/url"
	"strings"

	"github.com/google/uuid"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

// Message type URLs are generated by running unit test in msg_test.go => TestPrintMessageTypeStrings
const (
	TypeURLMsgWriteScopeRequest                      = "/provenance.metadata.v1.MsgWriteScopeRequest"
	TypeURLMsgDeleteScopeRequest                     = "/provenance.metadata.v1.MsgDeleteScopeRequest"
	TypeURLMsgAddScopeDataAccessRequest              = "/provenance.metadata.v1.MsgAddScopeDataAccessRequest"
	TypeURLMsgDeleteScopeDataAccessRequest           = "/provenance.metadata.v1.MsgDeleteScopeDataAccessRequest"
	TypeURLMsgAddScopeOwnerRequest                   = "/provenance.metadata.v1.MsgAddScopeOwnerRequest"
	TypeURLMsgDeleteScopeOwnerRequest                = "/provenance.metadata.v1.MsgDeleteScopeOwnerRequest"
	TypeURLMsgWriteSessionRequest                    = "/provenance.metadata.v1.MsgWriteSessionRequest"
	TypeURLMsgWriteRecordRequest                     = "/provenance.metadata.v1.MsgWriteRecordRequest"
	TypeURLMsgDeleteRecordRequest                    = "/provenance.metadata.v1.MsgDeleteRecordRequest"
	TypeURLMsgWriteScopeSpecificationRequest         = "/provenance.metadata.v1.MsgWriteScopeSpecificationRequest"
	TypeURLMsgDeleteScopeSpecificationRequest        = "/provenance.metadata.v1.MsgDeleteScopeSpecificationRequest"
	TypeURLMsgWriteContractSpecificationRequest      = "/provenance.metadata.v1.MsgWriteContractSpecificationRequest"
	TypeURLMsgDeleteContractSpecificationRequest     = "/provenance.metadata.v1.MsgDeleteContractSpecificationRequest"
	TypeURLMsgAddContractSpecToScopeSpecRequest      = "/provenance.metadata.v1.MsgAddContractSpecToScopeSpecRequest"
	TypeURLMsgDeleteContractSpecFromScopeSpecRequest = "/provenance.metadata.v1.MsgDeleteContractSpecFromScopeSpecRequest"
	TypeURLMsgWriteRecordSpecificationRequest        = "/provenance.metadata.v1.MsgWriteRecordSpecificationRequest"
	TypeURLMsgDeleteRecordSpecificationRequest       = "/provenance.metadata.v1.MsgDeleteRecordSpecificationRequest"
	TypeURLMsgBindOSLocatorRequest                   = "/provenance.metadata.v1.MsgBindOSLocatorRequest"
	TypeURLMsgDeleteOSLocatorRequest                 = "/provenance.metadata.v1.MsgDeleteOSLocatorRequest"
	TypeURLMsgModifyOSLocatorRequest                 = "/provenance.metadata.v1.MsgModifyOSLocatorRequest"
)

// MetadataMsg extends the sdk.Msg interface with functions common to x/metadata messages.
type MetadataMsg interface {
	sdk.Msg

	// GetSignersStr returns the bech32 address(es) that signed.
	GetSignersStr() []string
}

// Compile time interface checks.
var (
	_ MetadataMsg = (*MsgWriteScopeRequest)(nil)
	_ MetadataMsg = (*MsgDeleteScopeRequest)(nil)
	_ MetadataMsg = (*MsgAddScopeDataAccessRequest)(nil)
	_ MetadataMsg = (*MsgDeleteScopeDataAccessRequest)(nil)
	_ MetadataMsg = (*MsgAddScopeOwnerRequest)(nil)
	_ MetadataMsg = (*MsgDeleteScopeOwnerRequest)(nil)
	_ MetadataMsg = (*MsgWriteSessionRequest)(nil)
	_ MetadataMsg = (*MsgWriteRecordRequest)(nil)
	_ MetadataMsg = (*MsgDeleteRecordRequest)(nil)
	_ MetadataMsg = (*MsgWriteScopeSpecificationRequest)(nil)
	_ MetadataMsg = (*MsgDeleteScopeSpecificationRequest)(nil)
	_ MetadataMsg = (*MsgWriteContractSpecificationRequest)(nil)
	_ MetadataMsg = (*MsgDeleteContractSpecificationRequest)(nil)
	_ MetadataMsg = (*MsgAddContractSpecToScopeSpecRequest)(nil)
	_ MetadataMsg = (*MsgDeleteContractSpecFromScopeSpecRequest)(nil)
	_ MetadataMsg = (*MsgWriteRecordSpecificationRequest)(nil)
	_ MetadataMsg = (*MsgDeleteRecordSpecificationRequest)(nil)
	_ MetadataMsg = (*MsgBindOSLocatorRequest)(nil)
	_ MetadataMsg = (*MsgDeleteOSLocatorRequest)(nil)
	_ MetadataMsg = (*MsgModifyOSLocatorRequest)(nil)

	_ MetadataSpecAddressable = (*MsgWriteScopeRequest)(nil)
	_ MetadataAddressable     = (*MsgDeleteScopeRequest)(nil)
	_ MetadataAddressable     = (*MsgAddScopeDataAccessRequest)(nil)
	_ MetadataAddressable     = (*MsgDeleteScopeDataAccessRequest)(nil)
	_ MetadataAddressable     = (*MsgAddScopeOwnerRequest)(nil)
	_ MetadataAddressable     = (*MsgDeleteScopeOwnerRequest)(nil)
	_ MetadataSpecAddressable = (*MsgWriteSessionRequest)(nil)
	_ MetadataSpecAddressable = (*MsgWriteRecordRequest)(nil)
	_ MetadataAddressable     = (*MsgDeleteRecordRequest)(nil)
	_ MetadataSpecAddressable = (*MsgWriteScopeSpecificationRequest)(nil)
	_ MetadataSpecAddressable = (*MsgDeleteScopeSpecificationRequest)(nil)
	_ MetadataSpecAddressable = (*MsgWriteContractSpecificationRequest)(nil)
	_ MetadataSpecAddressable = (*MsgDeleteContractSpecificationRequest)(nil)
	_ MetadataSpecAddressable = (*MsgAddContractSpecToScopeSpecRequest)(nil)
	_ MetadataSpecAddressable = (*MsgDeleteContractSpecFromScopeSpecRequest)(nil)
	_ MetadataSpecAddressable = (*MsgWriteRecordSpecificationRequest)(nil)
	_ MetadataSpecAddressable = (*MsgDeleteRecordSpecificationRequest)(nil)
)

// stringsToAccAddresses converts an array of strings into an array of Acc Addresses.
// Panics if it can't convert one.
func stringsToAccAddresses(strings []string) []sdk.AccAddress {
	retval := make([]sdk.AccAddress, len(strings))

	for i, str := range strings {
		retval[i] = sdk.MustAccAddressFromBech32(str)
	}

	return retval
}

// ------------------  MsgWriteScopeRequest  ------------------

// NewMsgWriteScopeRequest creates a new msg instance
func NewMsgWriteScopeRequest(scope Scope, signers []string) *MsgWriteScopeRequest {
	return &MsgWriteScopeRequest{
		Scope:   scope,
		Signers: signers,
	}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgWriteScopeRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgWriteScopeRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgWriteScopeRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if err := msg.ConvertOptionalFields(); err != nil {
		return err
	}
	return msg.Scope.ValidateBasic()
}

// ConvertOptionalFields will look at the ScopeUuid and SpecUuid fields in the message.
// For each, if present, it will be converted to a MetadataAddress and set in the Scope appropriately.
// Once used, those uuid fields will be set to empty strings so that calling this again has no effect.
func (msg *MsgWriteScopeRequest) ConvertOptionalFields() error {
	if len(msg.ScopeUuid) > 0 {
		scopeAddr, err := msg.getIDFromOptionalUUID()
		if err != nil {
			return err
		}
		if !msg.Scope.ScopeId.Empty() && !msg.Scope.ScopeId.Equals(scopeAddr) {
			return fmt.Errorf("msg.Scope.ScopeId [%s] is different from the one created from msg.ScopeUuid [%s]",
				msg.Scope.ScopeId, msg.ScopeUuid)
		}
		msg.Scope.ScopeId = scopeAddr
		msg.ScopeUuid = ""
	}
	if len(msg.SpecUuid) > 0 {
		specAddr, err := msg.getSpecIDFromOptionalSpecUUID()
		if err != nil {
			return err
		}
		if !msg.Scope.SpecificationId.Empty() && !msg.Scope.SpecificationId.Equals(specAddr) {
			return fmt.Errorf("msg.Scope.SpecificationId [%s] is different from the one created from msg.SpecUuid [%s]",
				msg.Scope.SpecificationId, msg.SpecUuid)
		}
		msg.Scope.SpecificationId = specAddr
		msg.SpecUuid = ""
	}
	return nil
}

// getIDFromOptionalUUID gets the scope metadata address from the optional scope uuid.
// returns nil, nil if this doesn't have an optional scope uuid.
func (msg *MsgWriteScopeRequest) getIDFromOptionalUUID() (MetadataAddress, error) {
	if len(msg.ScopeUuid) > 0 {
		uid, err := uuid.Parse(msg.ScopeUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid scope uuid: %w", err)
		}
		return ScopeMetadataAddress(uid), nil
	}
	return nil, nil
}

// getSpecIDFromOptionalSpecUUID gets the scope spec metadata address from the optional spec uuid.
// returns nil, nil if this doesn't have an optional spec uuid.
func (msg *MsgWriteScopeRequest) getSpecIDFromOptionalSpecUUID() (MetadataAddress, error) {
	if len(msg.SpecUuid) > 0 {
		uid, err := uuid.Parse(msg.SpecUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid spec uuid: %w", err)
		}
		return ScopeSpecMetadataAddress(uid), nil
	}
	return nil, nil
}

// GetID gets the scope's id. Implements MetadataAddressable interface.
func (msg MsgWriteScopeRequest) GetID() MetadataAddress {
	rv := msg.Scope.GetID()
	if len(rv) == 0 {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getIDFromOptionalUUID()
	}
	return rv
}

// GetSpecID gets the scope's spec id. Implements MetadataSpecAddressable interface.
func (msg MsgWriteScopeRequest) GetSpecID() MetadataAddress {
	rv := msg.Scope.GetSpecID()
	if len(rv) == 0 {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getSpecIDFromOptionalSpecUUID()
	}
	return rv
}

// ------------------  NewMsgDeleteScopeRequest  ------------------

// NewMsgDeleteScopeRequest creates a new msg instance
func NewMsgDeleteScopeRequest(scopeID MetadataAddress, signers []string) *MsgDeleteScopeRequest {
	return &MsgDeleteScopeRequest{
		ScopeId: scopeID,
		Signers: signers,
	}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteScopeRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteScopeRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteScopeRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if !msg.ScopeId.IsScopeAddress() {
		return fmt.Errorf("invalid scope address")
	}
	return nil
}

// GetID gets the scope's id. Implements MetadataAddressable interface.
func (msg MsgDeleteScopeRequest) GetID() MetadataAddress {
	return msg.ScopeId
}

// ------------------  MsgAddScopeDataAccessRequest  ------------------

// NewMsgAddScopeDataAccessRequest creates a new msg instance
func NewMsgAddScopeDataAccessRequest(scopeID MetadataAddress, dataAccessAddrs []string, signers []string) *MsgAddScopeDataAccessRequest {
	return &MsgAddScopeDataAccessRequest{
		ScopeId:    scopeID,
		DataAccess: dataAccessAddrs,
		Signers:    signers,
	}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgAddScopeDataAccessRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgAddScopeDataAccessRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgAddScopeDataAccessRequest) ValidateBasic() error {
	if !msg.ScopeId.IsScopeAddress() {
		return fmt.Errorf("address is not a scope id: %v", msg.ScopeId.String())
	}
	if len(msg.DataAccess) < 1 {
		return fmt.Errorf("at least one data access address is required")
	}
	for _, da := range msg.DataAccess {
		_, err := sdk.AccAddressFromBech32(da)
		if err != nil {
			return fmt.Errorf("data access address is invalid: %s", da)
		}
	}
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope's id. Implements MetadataAddressable interface.
func (msg MsgAddScopeDataAccessRequest) GetID() MetadataAddress {
	return msg.ScopeId
}

// ------------------  MsgDeleteScopeDataAccessRequest  ------------------

// NewMsgDeleteScopeDataAccessRequest creates a new msg instance
func NewMsgDeleteScopeDataAccessRequest(scopeID MetadataAddress, dataAccessAddrs []string, signers []string) *MsgDeleteScopeDataAccessRequest {
	return &MsgDeleteScopeDataAccessRequest{
		ScopeId:    scopeID,
		DataAccess: dataAccessAddrs,
		Signers:    signers,
	}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteScopeDataAccessRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteScopeDataAccessRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteScopeDataAccessRequest) ValidateBasic() error {
	if !msg.ScopeId.IsScopeAddress() {
		return fmt.Errorf("address is not a scope id: %v", msg.ScopeId.String())
	}
	if len(msg.DataAccess) < 1 {
		return fmt.Errorf("at least one data access address is required")
	}
	for _, da := range msg.DataAccess {
		_, err := sdk.AccAddressFromBech32(da)
		if err != nil {
			return fmt.Errorf("data access address is invalid: %s", da)
		}
	}
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope's id. Implements MetadataAddressable interface.
func (msg MsgDeleteScopeDataAccessRequest) GetID() MetadataAddress {
	return msg.ScopeId
}

// ------------------  MsgAddScopeOwnerRequest  ------------------

// NewMsgAddScopeOwnerRequest creates a new msg instance
func NewMsgAddScopeOwnerRequest(scopeID MetadataAddress, owners []Party, signers []string) *MsgAddScopeOwnerRequest {
	return &MsgAddScopeOwnerRequest{
		ScopeId: scopeID,
		Owners:  owners,
		Signers: signers,
	}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgAddScopeOwnerRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgAddScopeOwnerRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgAddScopeOwnerRequest) ValidateBasic() error {
	if !msg.ScopeId.IsScopeAddress() {
		return fmt.Errorf("address is not a scope id: %v", msg.ScopeId.String())
	}
	if err := ValidatePartiesBasic(msg.Owners); err != nil {
		return fmt.Errorf("invalid owners: %w", err)
	}
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope's id. Implements MetadataAddressable interface.
func (msg MsgAddScopeOwnerRequest) GetID() MetadataAddress {
	return msg.ScopeId
}

// ------------------  MsgDeleteScopeOwnerRequest  ------------------

// NewMsgDeleteScopeOwnerRequest creates a new msg instance
func NewMsgDeleteScopeOwnerRequest(scopeID MetadataAddress, owners []string, signers []string) *MsgDeleteScopeOwnerRequest {
	return &MsgDeleteScopeOwnerRequest{
		ScopeId: scopeID,
		Owners:  owners,
		Signers: signers,
	}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteScopeOwnerRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteScopeOwnerRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteScopeOwnerRequest) ValidateBasic() error {
	if !msg.ScopeId.IsScopeAddress() {
		return fmt.Errorf("address is not a scope id: %v", msg.ScopeId.String())
	}
	if len(msg.Owners) < 1 {
		return fmt.Errorf("at least one owner address is required")
	}
	for _, owner := range msg.Owners {
		_, err := sdk.AccAddressFromBech32(owner)
		if err != nil {
			return fmt.Errorf("owner address is invalid: %s", owner)
		}
	}
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope's id. Implements MetadataAddressable interface.
func (msg MsgDeleteScopeOwnerRequest) GetID() MetadataAddress {
	return msg.ScopeId
}

// ------------------  MsgWriteSessionRequest  ------------------

// NewMsgWriteSessionRequest creates a new msg instance
func NewMsgWriteSessionRequest(session Session, signers []string) *MsgWriteSessionRequest {
	return &MsgWriteSessionRequest{Session: session, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgWriteSessionRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgWriteSessionRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgWriteSessionRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if err := msg.ConvertOptionalFields(); err != nil {
		return err
	}
	return msg.Session.ValidateBasic()
}

// ConvertOptionalFields will look at the SessionIdComponents and SpecUuid fields in the message.
// For each, if present, it will be converted to a MetadataAddress and set in the Session appropriately.
// Once used, those fields will be emptied so that calling this again has no effect.
func (msg *MsgWriteSessionRequest) ConvertOptionalFields() error {
	if msg.SessionIdComponents != nil {
		sessionAddr, err := msg.SessionIdComponents.GetSessionAddr()
		if err != nil {
			return fmt.Errorf("invalid session id components: %w", err)
		}
		if sessionAddr != nil {
			if !msg.Session.SessionId.Empty() && !msg.Session.SessionId.Equals(sessionAddr) {
				return fmt.Errorf("msg.Session.SessionId [%s] is different from the one created from msg.SessionIdComponents %v",
					msg.Session.SessionId, msg.SessionIdComponents)
			}
			msg.Session.SessionId = sessionAddr
		}
		msg.SessionIdComponents = nil
	}
	if len(msg.SpecUuid) > 0 {
		specAddr, err := msg.getSpecIDFromOptionalSpecUUID()
		if err != nil {
			return err
		}
		if !msg.Session.SpecificationId.Empty() && !msg.Session.SpecificationId.Equals(specAddr) {
			return fmt.Errorf("msg.Session.SpecificationId [%s] is different from the one created from msg.SpecUuid [%s]",
				msg.Session.SpecificationId, msg.SpecUuid)
		}
		msg.Session.SpecificationId = specAddr
		msg.SpecUuid = ""
	}
	return nil
}

// getSpecIDFromOptionalSpecUUID gets the contract spec metadata address from the optional spec uuid.
// returns nil, nil if this doesn't have an optional spec uuid.
func (msg MsgWriteSessionRequest) getSpecIDFromOptionalSpecUUID() (MetadataAddress, error) {
	if len(msg.SpecUuid) > 0 {
		uid, err := uuid.Parse(msg.SpecUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid spec uuid: %w", err)
		}
		return ContractSpecMetadataAddress(uid), nil
	}
	return nil, nil
}

// GetID gets the session's id. Implements MetadataAddressable interface.
func (msg MsgWriteSessionRequest) GetID() MetadataAddress {
	rv := msg.Session.GetID()
	if len(rv) == 0 && msg.SessionIdComponents != nil {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.SessionIdComponents.GetSessionAddr()
	}
	return rv
}

// GetSpecID gets the session's contract spec id. Implements MetadataSpecAddressable interface.
func (msg MsgWriteSessionRequest) GetSpecID() MetadataAddress {
	rv := msg.Session.GetSpecID()
	if len(rv) == 0 {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getSpecIDFromOptionalSpecUUID()
	}
	return rv
}

// ------------------  MsgWriteRecordRequest  ------------------

// NewMsgWriteRecordRequest creates a new msg instance
func NewMsgWriteRecordRequest(record Record, sessionIDComponents *SessionIdComponents, contractSpecUUID string, signers []string, parties []Party) *MsgWriteRecordRequest {
	return &MsgWriteRecordRequest{Record: record, Parties: parties, Signers: signers, SessionIdComponents: sessionIDComponents, ContractSpecUuid: contractSpecUUID}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgWriteRecordRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgWriteRecordRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgWriteRecordRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if err := msg.ConvertOptionalFields(); err != nil {
		return err
	}
	return msg.Record.ValidateBasic()
}

// ConvertOptionalFields will look at the SessionIdComponents and ContractSpecUuid fields in the message.
// For each, if present, it will be converted to a MetadataAddress and set in the Record appropriately.
// Once used, those fields will be emptied so that calling this again has no effect.
func (msg *MsgWriteRecordRequest) ConvertOptionalFields() error {
	if msg.SessionIdComponents != nil {
		sessionAddr, err := msg.SessionIdComponents.GetSessionAddr()
		if err != nil {
			return fmt.Errorf("invalid session id components: %w", err)
		}
		if sessionAddr != nil {
			if !msg.Record.SessionId.Empty() && !msg.Record.SessionId.Equals(sessionAddr) {
				return fmt.Errorf("msg.Record.SessionId [%s] is different from the one created from msg.SessionIdComponents %v",
					msg.Record.SessionId, msg.SessionIdComponents)
			}
			msg.Record.SessionId = sessionAddr
			msg.SessionIdComponents = nil
		}
	}
	if len(msg.ContractSpecUuid) > 0 {
		specAddr, err := msg.getSpecIDFromOptionalSpecUUID()
		if err != nil {
			return err
		}
		if !msg.Record.SpecificationId.Empty() && !msg.Record.SpecificationId.Equals(specAddr) {
			return fmt.Errorf("msg.Record.SpecificationId [%s] is different from the one created from msg.ContractSpecUuid [%s] and msg.Record.Name [%s]",
				msg.Record.SpecificationId, msg.ContractSpecUuid, msg.Record.Name)
		}
		msg.Record.SpecificationId = specAddr
		msg.ContractSpecUuid = ""
	}
	return nil
}

// getSpecIDFromOptionalSpecUUID gets the record spec metadata address from the optional contract spec uuid and record name.
// returns nil, nil if this doesn't have an optional contract spec uuid.
func (msg MsgWriteRecordRequest) getSpecIDFromOptionalSpecUUID() (MetadataAddress, error) {
	if len(msg.ContractSpecUuid) > 0 {
		uid, err := uuid.Parse(msg.ContractSpecUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid contract spec uuid: %w", err)
		}
		if len(strings.TrimSpace(msg.Record.Name)) == 0 {
			return nil, errors.New("empty record name")
		}
		return RecordSpecMetadataAddress(uid, msg.Record.Name), nil
	}
	return nil, nil
}

// GetID gets the record's id. Implements MetadataAddressable interface.
func (msg MsgWriteRecordRequest) GetID() MetadataAddress {
	rv := msg.Record.GetID()
	if len(rv) == 0 && msg.SessionIdComponents != nil {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		sessionAddr, _ := msg.SessionIdComponents.GetSessionAddr()
		if len(sessionAddr) > 0 && len(strings.TrimSpace(msg.Record.Name)) > 0 {
			rv, _ = sessionAddr.AsRecordAddress(msg.Record.Name)
		}
	}
	return rv
}

// GetSpecID gets the record's spec id. Implements MetadataSpecAddressable interface.
func (msg MsgWriteRecordRequest) GetSpecID() MetadataAddress {
	rv := msg.Record.GetSpecID()
	if len(rv) == 0 {
		// No spec id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getSpecIDFromOptionalSpecUUID()
	}
	return rv
}

// ------------------  MsgDeleteRecordRequest  ------------------

// NewMsgDeleteRecordRequest creates a new msg instance
func NewMsgDeleteRecordRequest(recordID MetadataAddress, signers []string) *MsgDeleteRecordRequest {
	return &MsgDeleteRecordRequest{RecordId: recordID, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteRecordRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteRecordRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteRecordRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the record's id. Implements MetadataAddressable interface.
func (msg MsgDeleteRecordRequest) GetID() MetadataAddress {
	return msg.RecordId
}

// ------------------  MsgWriteScopeSpecificationRequest  ------------------

// NewMsgWriteScopeSpecificationRequest creates a new msg instance
func NewMsgWriteScopeSpecificationRequest(specification ScopeSpecification, signers []string) *MsgWriteScopeSpecificationRequest {
	return &MsgWriteScopeSpecificationRequest{Specification: specification, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgWriteScopeSpecificationRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgWriteScopeSpecificationRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgWriteScopeSpecificationRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if err := msg.ConvertOptionalFields(); err != nil {
		return err
	}
	return msg.Specification.ValidateBasic()
}

// ConvertOptionalFields will look at the SpecUuid field in the message.
// If present, it will be converted to a MetadataAddress and set in the Specification appropriately.
// Once used, it will be emptied so that calling this again has no effect.
func (msg *MsgWriteScopeSpecificationRequest) ConvertOptionalFields() error {
	if len(msg.SpecUuid) > 0 {
		specAddr, err := msg.getSpecIDFromOptionalSpecUUID()
		if err != nil {
			return err
		}
		if !msg.Specification.SpecificationId.Empty() && !msg.Specification.SpecificationId.Equals(specAddr) {
			return fmt.Errorf("msg.Specification.SpecificationId [%s] is different from the one created from msg.SpecUuid [%s]",
				msg.Specification.SpecificationId, msg.SpecUuid)
		}
		msg.Specification.SpecificationId = specAddr
		msg.SpecUuid = ""
	}
	return nil
}

// getSpecIDFromOptionalSpecUUID gets the scope spec metadata address from the optional spec uuid.
// returns nil, nil if this doesn't have an optional spec uuid.
func (msg MsgWriteScopeSpecificationRequest) getSpecIDFromOptionalSpecUUID() (MetadataAddress, error) {
	if len(msg.SpecUuid) > 0 {
		uid, err := uuid.Parse(msg.SpecUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid spec uuid: %w", err)
		}
		return ScopeSpecMetadataAddress(uid), nil
	}
	return nil, nil
}

// GetID gets the scope spec's id. Implements MetadataAddressable interface.
func (msg MsgWriteScopeSpecificationRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the scope spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgWriteScopeSpecificationRequest) GetSpecID() MetadataAddress {
	rv := msg.Specification.GetID()
	if len(rv) == 0 {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getSpecIDFromOptionalSpecUUID()
	}
	return rv
}

// ------------------  MsgDeleteScopeSpecificationRequest  ------------------

// NewMsgDeleteScopeSpecificationRequest creates a new msg instance
func NewMsgDeleteScopeSpecificationRequest(specificationID MetadataAddress, signers []string) *MsgDeleteScopeSpecificationRequest {
	return &MsgDeleteScopeSpecificationRequest{SpecificationId: specificationID, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteScopeSpecificationRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteScopeSpecificationRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteScopeSpecificationRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope spec's id. Implements MetadataAddressable interface.
func (msg MsgDeleteScopeSpecificationRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the scope spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgDeleteScopeSpecificationRequest) GetSpecID() MetadataAddress {
	return msg.SpecificationId
}

// ------------------  MsgWriteContractSpecificationRequest  ------------------

// NewMsgWriteContractSpecificationRequest creates a new msg instance
func NewMsgWriteContractSpecificationRequest(specification ContractSpecification, signers []string) *MsgWriteContractSpecificationRequest {
	return &MsgWriteContractSpecificationRequest{Specification: specification, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgWriteContractSpecificationRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgWriteContractSpecificationRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgWriteContractSpecificationRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if err := msg.ConvertOptionalFields(); err != nil {
		return err
	}
	return msg.Specification.ValidateBasic()
}

// ConvertOptionalFields will look at the SpecUuid field in the message.
// If present, it will be converted to a MetadataAddress and set in the Specification appropriately.
// Once used, it will be emptied so that calling this again has no effect.
func (msg *MsgWriteContractSpecificationRequest) ConvertOptionalFields() error {
	if len(msg.SpecUuid) > 0 {
		specAddr, err := msg.getSpecIDFromOptionalSpecUUID()
		if err != nil {
			return err
		}
		if !msg.Specification.SpecificationId.Empty() && !msg.Specification.SpecificationId.Equals(specAddr) {
			return fmt.Errorf("msg.Specification.SpecificationId [%s] is different from the one created from msg.SpecUuid [%s]",
				msg.Specification.SpecificationId, msg.SpecUuid)
		}
		msg.Specification.SpecificationId = specAddr
		msg.SpecUuid = ""
	}
	return nil
}

// getSpecIDFromOptionalSpecUUID gets the contract spec metadata address from the optional spec uuid.
// returns nil, nil if this doesn't have an optional spec uuid.
func (msg MsgWriteContractSpecificationRequest) getSpecIDFromOptionalSpecUUID() (MetadataAddress, error) {
	if len(msg.SpecUuid) > 0 {
		uid, err := uuid.Parse(msg.SpecUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid spec uuid: %w", err)
		}
		return ContractSpecMetadataAddress(uid), nil
	}
	return nil, nil
}

// GetID gets the contract spec's id. Implements MetadataAddressable interface.
func (msg MsgWriteContractSpecificationRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the contract spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgWriteContractSpecificationRequest) GetSpecID() MetadataAddress {
	rv := msg.Specification.GetID()
	if len(rv) == 0 {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getSpecIDFromOptionalSpecUUID()
	}
	return rv
}

// ------------------  MsgDeleteContractSpecificationRequest  ------------------

// NewMsgDeleteContractSpecificationRequest creates a new msg instance
func NewMsgDeleteContractSpecificationRequest(specificationID MetadataAddress, signers []string) *MsgDeleteContractSpecificationRequest {
	return &MsgDeleteContractSpecificationRequest{SpecificationId: specificationID, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteContractSpecificationRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteContractSpecificationRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteContractSpecificationRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the contract spec's id. Implements MetadataAddressable interface.
func (msg MsgDeleteContractSpecificationRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the contract spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgDeleteContractSpecificationRequest) GetSpecID() MetadataAddress {
	return msg.SpecificationId
}

// ------------------  MsgAddContractSpecToScopeSpecRequest  ------------------

// NewMsgAddContractSpecToScopeSpecRequest creates a new msg instance
func NewMsgAddContractSpecToScopeSpecRequest(contractSpecID MetadataAddress, scopeSpecID MetadataAddress, signers []string) *MsgAddContractSpecToScopeSpecRequest {
	return &MsgAddContractSpecToScopeSpecRequest{ContractSpecificationId: contractSpecID, ScopeSpecificationId: scopeSpecID, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgAddContractSpecToScopeSpecRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgAddContractSpecToScopeSpecRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgAddContractSpecToScopeSpecRequest) ValidateBasic() error {
	if !msg.ContractSpecificationId.IsContractSpecificationAddress() {
		return fmt.Errorf("address is not a contract specification id: %s", msg.ContractSpecificationId.String())
	}
	if !msg.ScopeSpecificationId.IsScopeSpecificationAddress() {
		return fmt.Errorf("address is not a scope specification id: %s", msg.ScopeSpecificationId.String())
	}
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope spec's id. Implements MetadataAddressable interface.
func (msg MsgAddContractSpecToScopeSpecRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the scope spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgAddContractSpecToScopeSpecRequest) GetSpecID() MetadataAddress {
	return msg.ScopeSpecificationId
}

// ------------------  MsgDeleteContractSpecFromScopeSpecRequest  ------------------

// NewMsgDeleteContractSpecFromScopeSpecRequest creates a new msg instance
func NewMsgDeleteContractSpecFromScopeSpecRequest(contractSpecID MetadataAddress, scopeSpecID MetadataAddress, signers []string) *MsgDeleteContractSpecFromScopeSpecRequest {
	return &MsgDeleteContractSpecFromScopeSpecRequest{ContractSpecificationId: contractSpecID, ScopeSpecificationId: scopeSpecID, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteContractSpecFromScopeSpecRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteContractSpecFromScopeSpecRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteContractSpecFromScopeSpecRequest) ValidateBasic() error {
	if !msg.ContractSpecificationId.IsContractSpecificationAddress() {
		return fmt.Errorf("address is not a contract specification id: %s", msg.ContractSpecificationId.String())
	}
	if !msg.ScopeSpecificationId.IsScopeSpecificationAddress() {
		return fmt.Errorf("address is not a scope specification id: %s", msg.ScopeSpecificationId.String())
	}
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the scope spec's id. Implements MetadataAddressable interface.
func (msg MsgDeleteContractSpecFromScopeSpecRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the scope spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgDeleteContractSpecFromScopeSpecRequest) GetSpecID() MetadataAddress {
	return msg.ScopeSpecificationId
}

// ------------------  MsgWriteRecordSpecificationRequest  ------------------

// NewMsgWriteRecordSpecificationRequest creates a new msg instance
func NewMsgWriteRecordSpecificationRequest(recordSpecification RecordSpecification, signers []string) *MsgWriteRecordSpecificationRequest {
	return &MsgWriteRecordSpecificationRequest{Specification: recordSpecification, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgWriteRecordSpecificationRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgWriteRecordSpecificationRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgWriteRecordSpecificationRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	if err := msg.ConvertOptionalFields(); err != nil {
		return err
	}
	return msg.Specification.ValidateBasic()
}

// ConvertOptionalFields will look at the ContractSpecUuid field in the message.
// If present, it will be converted to a MetadataAddress and set in the Specification appropriately.
// Once used, it will be emptied so that calling this again has no effect.
func (msg *MsgWriteRecordSpecificationRequest) ConvertOptionalFields() error {
	if len(msg.ContractSpecUuid) > 0 {
		specAddr, err := msg.getSpecIDFromOptionalSpecUUID()
		if err != nil {
			return err
		}
		if !msg.Specification.SpecificationId.Empty() && !msg.Specification.SpecificationId.Equals(specAddr) {
			return fmt.Errorf("msg.Specification.SpecificationId [%s] is different from the one created from msg.ContractSpecUuid [%s] and msg.Specification.Name [%s]",
				msg.Specification.SpecificationId, msg.ContractSpecUuid, msg.Specification.Name)
		}
		msg.Specification.SpecificationId = specAddr
		msg.ContractSpecUuid = ""
	}
	return nil
}

// getSpecIDFromOptionalSpecUUID gets the record spec metadata address from the optional contract spec uuid and record name.
// returns nil, nil if this doesn't have an optional contract spec uuid.
func (msg MsgWriteRecordSpecificationRequest) getSpecIDFromOptionalSpecUUID() (MetadataAddress, error) {
	if len(msg.ContractSpecUuid) > 0 {
		uid, err := uuid.Parse(msg.ContractSpecUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid spec uuid: %w", err)
		}
		if len(strings.TrimSpace(msg.Specification.Name)) == 0 {
			return nil, errors.New("empty specification name")
		}
		return RecordSpecMetadataAddress(uid, msg.Specification.Name), nil
	}
	return nil, nil
}

// GetID gets the record spec's id. Implements MetadataAddressable interface.
func (msg MsgWriteRecordSpecificationRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the record spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgWriteRecordSpecificationRequest) GetSpecID() MetadataAddress {
	rv := msg.Specification.GetID()
	if len(rv) == 0 {
		// No id yet, try to get it from the uuid.
		// If it errors, we don't care in here, just return the empty address.
		rv, _ = msg.getSpecIDFromOptionalSpecUUID()
	}
	return rv
}

// ------------------  MsgDeleteRecordSpecificationRequest  ------------------

// NewMsgDeleteRecordSpecificationRequest creates a new msg instance
func NewMsgDeleteRecordSpecificationRequest(specificationID MetadataAddress, signers []string) *MsgDeleteRecordSpecificationRequest {
	return &MsgDeleteRecordSpecificationRequest{SpecificationId: specificationID, Signers: signers}
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteRecordSpecificationRequest) GetSigners() []sdk.AccAddress {
	return stringsToAccAddresses(msg.Signers)
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteRecordSpecificationRequest) GetSignersStr() []string {
	return msg.Signers
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteRecordSpecificationRequest) ValidateBasic() error {
	if len(msg.Signers) < 1 {
		return fmt.Errorf("at least one signer is required")
	}
	return nil
}

// GetID gets the record spec's id. Implements MetadataAddressable interface.
func (msg MsgDeleteRecordSpecificationRequest) GetID() MetadataAddress {
	return msg.GetSpecID()
}

// GetSpecID gets the record spec's id. Implements MetadataSpecAddressable interface.
func (msg MsgDeleteRecordSpecificationRequest) GetSpecID() MetadataAddress {
	return msg.SpecificationId
}

// ------------------  MsgBindOSLocatorRequest  ------------------

// NewMsgBindOSLocatorRequest creates a new msg instance
func NewMsgBindOSLocatorRequest(obj ObjectStoreLocator) *MsgBindOSLocatorRequest {
	return &MsgBindOSLocatorRequest{
		Locator: obj,
	}
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgBindOSLocatorRequest) ValidateBasic() error {
	err := ValidateOSLocatorObj(msg.Locator.Owner, msg.Locator.EncryptionKey, msg.Locator.LocatorUri)
	if err != nil {
		return err
	}
	return nil
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgBindOSLocatorRequest) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{sdk.MustAccAddressFromBech32(msg.Locator.Owner)}
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgBindOSLocatorRequest) GetSignersStr() []string {
	return []string{msg.Locator.Owner}
}

// ------------------  MsgDeleteOSLocatorRequest  ------------------

func NewMsgDeleteOSLocatorRequest(obj ObjectStoreLocator) *MsgDeleteOSLocatorRequest {
	return &MsgDeleteOSLocatorRequest{
		Locator: obj,
	}
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgDeleteOSLocatorRequest) ValidateBasic() error {
	err := ValidateOSLocatorObj(msg.Locator.Owner, msg.Locator.EncryptionKey, msg.Locator.LocatorUri)
	if err != nil {
		return err
	}

	return nil
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgDeleteOSLocatorRequest) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{sdk.MustAccAddressFromBech32(msg.Locator.Owner)}
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgDeleteOSLocatorRequest) GetSignersStr() []string {
	return []string{msg.Locator.Owner}
}

// ValidateOSLocatorObj Validates OSLocatorObj data
func ValidateOSLocatorObj(ownerAddr, encryptionKey string, uri string) error {
	if strings.TrimSpace(ownerAddr) == "" {
		return fmt.Errorf("owner address cannot be empty")
	}

	if _, err := sdk.AccAddressFromBech32(ownerAddr); err != nil {
		return fmt.Errorf("failed to add locator for a given owner address,"+
			" invalid address: %s", ownerAddr)
	}

	if strings.TrimSpace(uri) == "" {
		return fmt.Errorf("uri cannot be empty")
	}

	if _, err := url.Parse(uri); err != nil {
		return fmt.Errorf("failed to add locator for a given"+
			" owner address, invalid uri: %s", uri)
	}

	if strings.TrimSpace(encryptionKey) != "" {
		if _, err := sdk.AccAddressFromBech32(encryptionKey); err != nil {
			return fmt.Errorf("failed to add locator for a given owner address: %s,"+
				" invalid encryption key address: %s", ownerAddr, encryptionKey)
		}
	}
	return nil
}

// ------------------  MsgModifyOSLocatorRequest  ------------------

func NewMsgModifyOSLocatorRequest(obj ObjectStoreLocator) *MsgModifyOSLocatorRequest {
	return &MsgModifyOSLocatorRequest{
		Locator: obj,
	}
}

// ValidateBasic performs as much validation as possible without outside info. Implements sdk.Msg interface.
func (msg MsgModifyOSLocatorRequest) ValidateBasic() error {
	err := ValidateOSLocatorObj(msg.Locator.Owner, msg.Locator.EncryptionKey, msg.Locator.LocatorUri)
	if err != nil {
		return err
	}

	return nil
}

// GetSigners returns the address(es) that signed. Implements sdk.Msg interface.
func (msg MsgModifyOSLocatorRequest) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{sdk.MustAccAddressFromBech32(msg.Locator.Owner)}
}

// GetSignersStr returns the bech32 address(es) that signed. Implements MetadataMsg interface.
func (msg MsgModifyOSLocatorRequest) GetSignersStr() []string {
	return []string{msg.Locator.Owner}
}

// ------------------  SessionIdComponents  ------------------

func (msg *SessionIdComponents) GetSessionAddr() (MetadataAddress, error) {
	var scopeUUID, sessionUUID *uuid.UUID
	if len(msg.SessionUuid) > 0 {
		uid, err := uuid.Parse(msg.SessionUuid)
		if err != nil {
			return nil, fmt.Errorf("invalid session uuid: %w", err)
		}
		sessionUUID = &uid
	}
	if msgScopeUUID := msg.GetScopeUuid(); len(msgScopeUUID) > 0 {
		uid, err := uuid.Parse(msgScopeUUID)
		if err != nil {
			return nil, fmt.Errorf("invalid scope uuid: %w", err)
		}
		scopeUUID = &uid
	} else if msgScopeAddr := msg.GetScopeAddr(); len(msgScopeAddr) > 0 {
		addr, addrErr := MetadataAddressFromBech32(msgScopeAddr)
		if addrErr != nil {
			return nil, fmt.Errorf("invalid scope addr: %w", addrErr)
		}
		uid, err := addr.ScopeUUID()
		if err != nil {
			return nil, fmt.Errorf("invalid scope addr: %w", err)
		}
		scopeUUID = &uid
	}

	if scopeUUID == nil && sessionUUID == nil {
		return nil, nil
	}
	if scopeUUID == nil {
		return nil, errors.New("session uuid provided but missing scope uuid or addr")
	}
	if sessionUUID == nil {
		return nil, errors.New("scope uuid or addr provided but missing session uuid")
	}
	ma := SessionMetadataAddress(*scopeUUID, *sessionUUID)
	return ma, nil
}

// ------------------  Response Message Constructors  ------------------

func NewMsgWriteScopeResponse(scopeID MetadataAddress) *MsgWriteScopeResponse {
	return &MsgWriteScopeResponse{
		ScopeIdInfo: GetScopeIDInfo(scopeID),
	}
}

func NewMsgDeleteScopeResponse() *MsgDeleteScopeResponse {
	return &MsgDeleteScopeResponse{}
}

func NewMsgAddScopeDataAccessResponse() *MsgAddScopeDataAccessResponse {
	return &MsgAddScopeDataAccessResponse{}
}

func NewMsgDeleteScopeDataAccessResponse() *MsgDeleteScopeDataAccessResponse {
	return &MsgDeleteScopeDataAccessResponse{}
}

func NewMsgAddScopeOwnerResponse() *MsgAddScopeOwnerResponse {
	return &MsgAddScopeOwnerResponse{}
}

func NewMsgDeleteScopeOwnerResponse() *MsgDeleteScopeOwnerResponse {
	return &MsgDeleteScopeOwnerResponse{}
}

func NewMsgWriteSessionResponse(sessionID MetadataAddress) *MsgWriteSessionResponse {
	return &MsgWriteSessionResponse{
		SessionIdInfo: GetSessionIDInfo(sessionID),
	}
}

func NewMsgWriteRecordResponse(recordID MetadataAddress) *MsgWriteRecordResponse {
	return &MsgWriteRecordResponse{
		RecordIdInfo: GetRecordIDInfo(recordID),
	}
}

func NewMsgDeleteRecordResponse() *MsgDeleteRecordResponse {
	return &MsgDeleteRecordResponse{}
}

func NewMsgWriteScopeSpecificationResponse(scopeSpecID MetadataAddress) *MsgWriteScopeSpecificationResponse {
	return &MsgWriteScopeSpecificationResponse{
		ScopeSpecIdInfo: GetScopeSpecIDInfo(scopeSpecID),
	}
}

func NewMsgDeleteScopeSpecificationResponse() *MsgDeleteScopeSpecificationResponse {
	return &MsgDeleteScopeSpecificationResponse{}
}

func NewMsgWriteContractSpecificationResponse(contractSpecID MetadataAddress) *MsgWriteContractSpecificationResponse {
	return &MsgWriteContractSpecificationResponse{
		ContractSpecIdInfo: GetContractSpecIDInfo(contractSpecID),
	}
}

func NewMsgDeleteContractSpecificationResponse() *MsgDeleteContractSpecificationResponse {
	return &MsgDeleteContractSpecificationResponse{}
}

func NewMsgAddContractSpecToScopeSpecResponse() *MsgAddContractSpecToScopeSpecResponse {
	return &MsgAddContractSpecToScopeSpecResponse{}
}

func NewMsgDeleteContractSpecFromScopeSpecResponse() *MsgDeleteContractSpecFromScopeSpecResponse {
	return &MsgDeleteContractSpecFromScopeSpecResponse{}
}

func NewMsgWriteRecordSpecificationResponse(recordSpecID MetadataAddress) *MsgWriteRecordSpecificationResponse {
	return &MsgWriteRecordSpecificationResponse{
		RecordSpecIdInfo: GetRecordSpecIDInfo(recordSpecID),
	}
}

func NewMsgDeleteRecordSpecificationResponse() *MsgDeleteRecordSpecificationResponse {
	return &MsgDeleteRecordSpecificationResponse{}
}

func NewMsgBindOSLocatorResponse(objectStoreLocator ObjectStoreLocator) *MsgBindOSLocatorResponse {
	return &MsgBindOSLocatorResponse{
		Locator: objectStoreLocator,
	}
}

func NewMsgDeleteOSLocatorResponse(objectStoreLocator ObjectStoreLocator) *MsgDeleteOSLocatorResponse {
	return &MsgDeleteOSLocatorResponse{
		Locator: objectStoreLocator,
	}
}

func NewMsgModifyOSLocatorResponse(objectStoreLocator ObjectStoreLocator) *MsgModifyOSLocatorResponse {
	return &MsgModifyOSLocatorResponse{
		Locator: objectStoreLocator,
	}
}
