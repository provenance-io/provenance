// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/metadata.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the set of params for the metadata module.
type Params struct {
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

// ScopeIdInfo contains various info regarding a scope id.
type ScopeIdInfo struct {
	// scope_id is the raw bytes of the scope address.
	ScopeId MetadataAddress `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3,customtype=MetadataAddress" json:"scope_id"`
	// scope_id_prefix is the prefix portion of the scope_id.
	ScopeIdPrefix []byte `protobuf:"bytes,2,opt,name=scope_id_prefix,json=scopeIdPrefix,proto3" json:"scope_id_prefix,omitempty"`
	// scope_id_scope_uuid is the scope_uuid portion of the scope_id.
	ScopeIdScopeUuid []byte `protobuf:"bytes,3,opt,name=scope_id_scope_uuid,json=scopeIdScopeUuid,proto3" json:"scope_id_scope_uuid,omitempty"`
	// scope_addr is the bech32 string version of the scope_id.
	ScopeAddr string `protobuf:"bytes,4,opt,name=scope_addr,json=scopeAddr,proto3" json:"scope_addr,omitempty"`
	// scope_uuid is the uuid hex string of the scope_id_scope_uuid.
	ScopeUuid string `protobuf:"bytes,5,opt,name=scope_uuid,json=scopeUuid,proto3" json:"scope_uuid,omitempty"`
}

func (m *ScopeIdInfo) Reset()         { *m = ScopeIdInfo{} }
func (m *ScopeIdInfo) String() string { return proto.CompactTextString(m) }
func (*ScopeIdInfo) ProtoMessage()    {}
func (*ScopeIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{1}
}
func (m *ScopeIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeIdInfo.Merge(m, src)
}
func (m *ScopeIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScopeIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeIdInfo proto.InternalMessageInfo

func (m *ScopeIdInfo) GetScopeIdPrefix() []byte {
	if m != nil {
		return m.ScopeIdPrefix
	}
	return nil
}

func (m *ScopeIdInfo) GetScopeIdScopeUuid() []byte {
	if m != nil {
		return m.ScopeIdScopeUuid
	}
	return nil
}

func (m *ScopeIdInfo) GetScopeAddr() string {
	if m != nil {
		return m.ScopeAddr
	}
	return ""
}

func (m *ScopeIdInfo) GetScopeUuid() string {
	if m != nil {
		return m.ScopeUuid
	}
	return ""
}

// SessionIdInfo contains various info regarding a session id.
type SessionIdInfo struct {
	// session_id is the raw bytes of the session address.
	SessionId MetadataAddress `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,customtype=MetadataAddress" json:"session_id"`
	// session_id_prefix is the prefix portion of the session_id.
	SessionIdPrefix []byte `protobuf:"bytes,2,opt,name=session_id_prefix,json=sessionIdPrefix,proto3" json:"session_id_prefix,omitempty"`
	// session_id_scope_uuid is the scope_uuid portion of the session_id.
	SessionIdScopeUuid []byte `protobuf:"bytes,3,opt,name=session_id_scope_uuid,json=sessionIdScopeUuid,proto3" json:"session_id_scope_uuid,omitempty"`
	// session_id_session_uuid is the session_uuid portion of the session_id.
	SessionIdSessionUuid []byte `protobuf:"bytes,4,opt,name=session_id_session_uuid,json=sessionIdSessionUuid,proto3" json:"session_id_session_uuid,omitempty"`
	// session_addr is the bech32 string version of the session_id.
	SessionAddr string `protobuf:"bytes,5,opt,name=session_addr,json=sessionAddr,proto3" json:"session_addr,omitempty"`
	// session_uuid is the uuid hex string of the session_id_session_uuid.
	SessionUuid string `protobuf:"bytes,6,opt,name=session_uuid,json=sessionUuid,proto3" json:"session_uuid,omitempty"`
	// scope_id_info is information about the scope id referenced in the session_id.
	ScopeIdInfo *ScopeIdInfo `protobuf:"bytes,7,opt,name=scope_id_info,json=scopeIdInfo,proto3" json:"scope_id_info,omitempty"`
}

func (m *SessionIdInfo) Reset()         { *m = SessionIdInfo{} }
func (m *SessionIdInfo) String() string { return proto.CompactTextString(m) }
func (*SessionIdInfo) ProtoMessage()    {}
func (*SessionIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{2}
}
func (m *SessionIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionIdInfo.Merge(m, src)
}
func (m *SessionIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *SessionIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SessionIdInfo proto.InternalMessageInfo

func (m *SessionIdInfo) GetSessionIdPrefix() []byte {
	if m != nil {
		return m.SessionIdPrefix
	}
	return nil
}

func (m *SessionIdInfo) GetSessionIdScopeUuid() []byte {
	if m != nil {
		return m.SessionIdScopeUuid
	}
	return nil
}

func (m *SessionIdInfo) GetSessionIdSessionUuid() []byte {
	if m != nil {
		return m.SessionIdSessionUuid
	}
	return nil
}

func (m *SessionIdInfo) GetSessionAddr() string {
	if m != nil {
		return m.SessionAddr
	}
	return ""
}

func (m *SessionIdInfo) GetSessionUuid() string {
	if m != nil {
		return m.SessionUuid
	}
	return ""
}

func (m *SessionIdInfo) GetScopeIdInfo() *ScopeIdInfo {
	if m != nil {
		return m.ScopeIdInfo
	}
	return nil
}

// RecordIdInfo contains various info regarding a record id.
type RecordIdInfo struct {
	// record_id is the raw bytes of the record address.
	RecordId MetadataAddress `protobuf:"bytes,1,opt,name=record_id,json=recordId,proto3,customtype=MetadataAddress" json:"record_id"`
	// record_id_prefix is the prefix portion of the record_id.
	RecordIdPrefix []byte `protobuf:"bytes,2,opt,name=record_id_prefix,json=recordIdPrefix,proto3" json:"record_id_prefix,omitempty"`
	// record_id_scope_uuid is the scope_uuid portion of the record_id.
	RecordIdScopeUuid []byte `protobuf:"bytes,3,opt,name=record_id_scope_uuid,json=recordIdScopeUuid,proto3" json:"record_id_scope_uuid,omitempty"`
	// record_id_hashed_name is the hashed name portion of the record_id.
	RecordIdHashedName []byte `protobuf:"bytes,4,opt,name=record_id_hashed_name,json=recordIdHashedName,proto3" json:"record_id_hashed_name,omitempty"`
	// record_addr is the bech32 string version of the record_id.
	RecordAddr string `protobuf:"bytes,5,opt,name=record_addr,json=recordAddr,proto3" json:"record_addr,omitempty"`
	// scope_id_info is information about the scope id referenced in the record_id.
	ScopeIdInfo *ScopeIdInfo `protobuf:"bytes,6,opt,name=scope_id_info,json=scopeIdInfo,proto3" json:"scope_id_info,omitempty"`
}

func (m *RecordIdInfo) Reset()         { *m = RecordIdInfo{} }
func (m *RecordIdInfo) String() string { return proto.CompactTextString(m) }
func (*RecordIdInfo) ProtoMessage()    {}
func (*RecordIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{3}
}
func (m *RecordIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordIdInfo.Merge(m, src)
}
func (m *RecordIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecordIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecordIdInfo proto.InternalMessageInfo

func (m *RecordIdInfo) GetRecordIdPrefix() []byte {
	if m != nil {
		return m.RecordIdPrefix
	}
	return nil
}

func (m *RecordIdInfo) GetRecordIdScopeUuid() []byte {
	if m != nil {
		return m.RecordIdScopeUuid
	}
	return nil
}

func (m *RecordIdInfo) GetRecordIdHashedName() []byte {
	if m != nil {
		return m.RecordIdHashedName
	}
	return nil
}

func (m *RecordIdInfo) GetRecordAddr() string {
	if m != nil {
		return m.RecordAddr
	}
	return ""
}

func (m *RecordIdInfo) GetScopeIdInfo() *ScopeIdInfo {
	if m != nil {
		return m.ScopeIdInfo
	}
	return nil
}

// ScopeSpecIdInfo contains various info regarding a scope specification id.
type ScopeSpecIdInfo struct {
	// scope_spec_id is the raw bytes of the scope specification address.
	ScopeSpecId MetadataAddress `protobuf:"bytes,1,opt,name=scope_spec_id,json=scopeSpecId,proto3,customtype=MetadataAddress" json:"scope_spec_id"`
	// scope_spec_id_prefix is the prefix portion of the scope_spec_id.
	ScopeSpecIdPrefix []byte `protobuf:"bytes,2,opt,name=scope_spec_id_prefix,json=scopeSpecIdPrefix,proto3" json:"scope_spec_id_prefix,omitempty"`
	// scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id.
	ScopeSpecIdScopeSpecUuid []byte `protobuf:"bytes,3,opt,name=scope_spec_id_scope_spec_uuid,json=scopeSpecIdScopeSpecUuid,proto3" json:"scope_spec_id_scope_spec_uuid,omitempty"`
	// scope_spec_addr is the bech32 string version of the scope_spec_id.
	ScopeSpecAddr string `protobuf:"bytes,4,opt,name=scope_spec_addr,json=scopeSpecAddr,proto3" json:"scope_spec_addr,omitempty"`
	// scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid.
	ScopeSpecUuid string `protobuf:"bytes,5,opt,name=scope_spec_uuid,json=scopeSpecUuid,proto3" json:"scope_spec_uuid,omitempty"`
}

func (m *ScopeSpecIdInfo) Reset()         { *m = ScopeSpecIdInfo{} }
func (m *ScopeSpecIdInfo) String() string { return proto.CompactTextString(m) }
func (*ScopeSpecIdInfo) ProtoMessage()    {}
func (*ScopeSpecIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{4}
}
func (m *ScopeSpecIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeSpecIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeSpecIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeSpecIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeSpecIdInfo.Merge(m, src)
}
func (m *ScopeSpecIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScopeSpecIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeSpecIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeSpecIdInfo proto.InternalMessageInfo

func (m *ScopeSpecIdInfo) GetScopeSpecIdPrefix() []byte {
	if m != nil {
		return m.ScopeSpecIdPrefix
	}
	return nil
}

func (m *ScopeSpecIdInfo) GetScopeSpecIdScopeSpecUuid() []byte {
	if m != nil {
		return m.ScopeSpecIdScopeSpecUuid
	}
	return nil
}

func (m *ScopeSpecIdInfo) GetScopeSpecAddr() string {
	if m != nil {
		return m.ScopeSpecAddr
	}
	return ""
}

func (m *ScopeSpecIdInfo) GetScopeSpecUuid() string {
	if m != nil {
		return m.ScopeSpecUuid
	}
	return ""
}

// ContractSpecIdInfo contains various info regarding a contract specification id.
type ContractSpecIdInfo struct {
	// contract_spec_id is the raw bytes of the contract specification address.
	ContractSpecId MetadataAddress `protobuf:"bytes,1,opt,name=contract_spec_id,json=contractSpecId,proto3,customtype=MetadataAddress" json:"contract_spec_id"`
	// contract_spec_id_prefix is the prefix portion of the contract_spec_id.
	ContractSpecIdPrefix []byte `protobuf:"bytes,2,opt,name=contract_spec_id_prefix,json=contractSpecIdPrefix,proto3" json:"contract_spec_id_prefix,omitempty"`
	// contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id.
	ContractSpecIdContractSpecUuid []byte `protobuf:"bytes,3,opt,name=contract_spec_id_contract_spec_uuid,json=contractSpecIdContractSpecUuid,proto3" json:"contract_spec_id_contract_spec_uuid,omitempty"`
	// contract_spec_addr is the bech32 string version of the contract_spec_id.
	ContractSpecAddr string `protobuf:"bytes,4,opt,name=contract_spec_addr,json=contractSpecAddr,proto3" json:"contract_spec_addr,omitempty"`
	// contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid.
	ContractSpecUuid string `protobuf:"bytes,5,opt,name=contract_spec_uuid,json=contractSpecUuid,proto3" json:"contract_spec_uuid,omitempty"`
}

func (m *ContractSpecIdInfo) Reset()         { *m = ContractSpecIdInfo{} }
func (m *ContractSpecIdInfo) String() string { return proto.CompactTextString(m) }
func (*ContractSpecIdInfo) ProtoMessage()    {}
func (*ContractSpecIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{5}
}
func (m *ContractSpecIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractSpecIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractSpecIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractSpecIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractSpecIdInfo.Merge(m, src)
}
func (m *ContractSpecIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContractSpecIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractSpecIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContractSpecIdInfo proto.InternalMessageInfo

func (m *ContractSpecIdInfo) GetContractSpecIdPrefix() []byte {
	if m != nil {
		return m.ContractSpecIdPrefix
	}
	return nil
}

func (m *ContractSpecIdInfo) GetContractSpecIdContractSpecUuid() []byte {
	if m != nil {
		return m.ContractSpecIdContractSpecUuid
	}
	return nil
}

func (m *ContractSpecIdInfo) GetContractSpecAddr() string {
	if m != nil {
		return m.ContractSpecAddr
	}
	return ""
}

func (m *ContractSpecIdInfo) GetContractSpecUuid() string {
	if m != nil {
		return m.ContractSpecUuid
	}
	return ""
}

// RecordSpecIdInfo contains various info regarding a record specification id.
type RecordSpecIdInfo struct {
	// record_spec_id is the raw bytes of the record specification address.
	RecordSpecId MetadataAddress `protobuf:"bytes,1,opt,name=record_spec_id,json=recordSpecId,proto3,customtype=MetadataAddress" json:"record_spec_id"`
	// record_spec_id_prefix is the prefix portion of the record_spec_id.
	RecordSpecIdPrefix []byte `protobuf:"bytes,2,opt,name=record_spec_id_prefix,json=recordSpecIdPrefix,proto3" json:"record_spec_id_prefix,omitempty"`
	// record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id.
	RecordSpecIdContractSpecUuid []byte `protobuf:"bytes,3,opt,name=record_spec_id_contract_spec_uuid,json=recordSpecIdContractSpecUuid,proto3" json:"record_spec_id_contract_spec_uuid,omitempty"`
	// record_spec_id_hashed_name is the hashed name portion of the record_spec_id.
	RecordSpecIdHashedName []byte `protobuf:"bytes,4,opt,name=record_spec_id_hashed_name,json=recordSpecIdHashedName,proto3" json:"record_spec_id_hashed_name,omitempty"`
	// record_spec_addr is the bech32 string version of the record_spec_id.
	RecordSpecAddr string `protobuf:"bytes,5,opt,name=record_spec_addr,json=recordSpecAddr,proto3" json:"record_spec_addr,omitempty"`
	// contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.
	ContractSpecIdInfo *ContractSpecIdInfo `protobuf:"bytes,6,opt,name=contract_spec_id_info,json=contractSpecIdInfo,proto3" json:"contract_spec_id_info,omitempty"`
}

func (m *RecordSpecIdInfo) Reset()         { *m = RecordSpecIdInfo{} }
func (m *RecordSpecIdInfo) String() string { return proto.CompactTextString(m) }
func (*RecordSpecIdInfo) ProtoMessage()    {}
func (*RecordSpecIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_786fb0ab3f663d79, []int{6}
}
func (m *RecordSpecIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordSpecIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordSpecIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordSpecIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordSpecIdInfo.Merge(m, src)
}
func (m *RecordSpecIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecordSpecIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordSpecIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecordSpecIdInfo proto.InternalMessageInfo

func (m *RecordSpecIdInfo) GetRecordSpecIdPrefix() []byte {
	if m != nil {
		return m.RecordSpecIdPrefix
	}
	return nil
}

func (m *RecordSpecIdInfo) GetRecordSpecIdContractSpecUuid() []byte {
	if m != nil {
		return m.RecordSpecIdContractSpecUuid
	}
	return nil
}

func (m *RecordSpecIdInfo) GetRecordSpecIdHashedName() []byte {
	if m != nil {
		return m.RecordSpecIdHashedName
	}
	return nil
}

func (m *RecordSpecIdInfo) GetRecordSpecAddr() string {
	if m != nil {
		return m.RecordSpecAddr
	}
	return ""
}

func (m *RecordSpecIdInfo) GetContractSpecIdInfo() *ContractSpecIdInfo {
	if m != nil {
		return m.ContractSpecIdInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*Params)(nil), "provenance.metadata.v1.Params")
	proto.RegisterType((*ScopeIdInfo)(nil), "provenance.metadata.v1.ScopeIdInfo")
	proto.RegisterType((*SessionIdInfo)(nil), "provenance.metadata.v1.SessionIdInfo")
	proto.RegisterType((*RecordIdInfo)(nil), "provenance.metadata.v1.RecordIdInfo")
	proto.RegisterType((*ScopeSpecIdInfo)(nil), "provenance.metadata.v1.ScopeSpecIdInfo")
	proto.RegisterType((*ContractSpecIdInfo)(nil), "provenance.metadata.v1.ContractSpecIdInfo")
	proto.RegisterType((*RecordSpecIdInfo)(nil), "provenance.metadata.v1.RecordSpecIdInfo")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/metadata.proto", fileDescriptor_786fb0ab3f663d79)
}

var fileDescriptor_786fb0ab3f663d79 = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xcf, 0x4e, 0xdb, 0x4a,
	0x14, 0x87, 0xe3, 0xc0, 0x0d, 0xe4, 0xe4, 0x2f, 0x73, 0x03, 0xe4, 0xa2, 0x8b, 0x03, 0x41, 0xf7,
	0x2a, 0x42, 0x25, 0x51, 0x28, 0xed, 0x82, 0xaa, 0xaa, 0xa0, 0x0b, 0x8a, 0xaa, 0x56, 0x28, 0xa8,
	0x9b, 0x4a, 0x15, 0x32, 0xf6, 0x00, 0x56, 0x15, 0x8f, 0xe5, 0x71, 0x10, 0x7d, 0x0b, 0xd4, 0x27,
	0xe8, 0x5b, 0x74, 0xd3, 0x07, 0x60, 0xc9, 0xaa, 0xaa, 0xba, 0x40, 0x15, 0x6c, 0xba, 0xe8, 0x43,
	0x54, 0x1e, 0x8f, 0x3d, 0x67, 0x30, 0x48, 0x51, 0x77, 0x33, 0x67, 0x7e, 0xdf, 0x91, 0xe7, 0x8b,
	0x8f, 0x01, 0xfe, 0xf3, 0x03, 0x76, 0x4a, 0x3d, 0xcb, 0xb3, 0x69, 0x6f, 0x48, 0x43, 0xcb, 0xb1,
	0x42, 0xab, 0x77, 0xda, 0x4f, 0xd7, 0x5d, 0x3f, 0x60, 0x21, 0x23, 0x73, 0x2a, 0xd6, 0x4d, 0x8f,
	0x4e, 0xfb, 0x0b, 0x8d, 0x63, 0x76, 0xcc, 0x44, 0xa4, 0x17, 0xad, 0xe2, 0x74, 0xbb, 0x0a, 0x85,
	0x3d, 0x2b, 0xb0, 0x86, 0x7c, 0x73, 0xf2, 0xe7, 0xa7, 0x96, 0xd1, 0xfe, 0x6a, 0x40, 0x69, 0xdf,
	0x66, 0x3e, 0xdd, 0x75, 0x76, 0xbd, 0x23, 0x46, 0xd6, 0x61, 0x9a, 0x47, 0xdb, 0x03, 0xd7, 0x69,
	0x1a, 0x4b, 0x46, 0xa7, 0xbc, 0x3d, 0x7f, 0x71, 0xd5, 0xca, 0x7d, 0xbf, 0x6a, 0xd5, 0x5e, 0xc9,
	0xe6, 0x5b, 0x8e, 0x13, 0x50, 0xce, 0x07, 0x53, 0x3c, 0xe6, 0xc8, 0xff, 0x50, 0x4b, 0x98, 0x03,
	0x3f, 0xa0, 0x47, 0xee, 0x59, 0x33, 0x1f, 0xa1, 0x83, 0x8a, 0x4c, 0xec, 0x89, 0x22, 0x59, 0x83,
	0xbf, 0xd3, 0x5c, 0xbc, 0x18, 0x8d, 0x5c, 0xa7, 0x39, 0x21, 0xb2, 0x75, 0x99, 0x15, 0x0f, 0xf3,
	0x66, 0xe4, 0x3a, 0x64, 0x11, 0x20, 0x4e, 0x59, 0x8e, 0x13, 0x34, 0x27, 0x97, 0x8c, 0x4e, 0x71,
	0x50, 0x14, 0x95, 0xe8, 0x09, 0xd4, 0xb1, 0x68, 0xf2, 0x17, 0x3a, 0x8e, 0xe8, 0xf6, 0xaf, 0x3c,
	0x54, 0xf6, 0x29, 0xe7, 0x2e, 0xf3, 0xe4, 0xd5, 0x1e, 0x03, 0xf0, 0xb8, 0x30, 0xc6, 0xe5, 0x8a,
	0x3c, 0x61, 0xc9, 0x2a, 0xcc, 0x28, 0x4e, 0xbf, 0x60, 0x2d, 0x4d, 0xc9, 0x2b, 0xf6, 0x61, 0x16,
	0x65, 0x33, 0x97, 0x24, 0x69, 0x5e, 0x5d, 0xf3, 0x11, 0xcc, 0x63, 0x44, 0x2e, 0x05, 0x34, 0x29,
	0xa0, 0x86, 0x82, 0xe2, 0x85, 0xc0, 0x96, 0xa1, 0x9c, 0x64, 0x85, 0x9f, 0x58, 0x40, 0x49, 0xd6,
	0x84, 0x21, 0x14, 0x11, 0xed, 0x0a, 0x5a, 0x44, 0x74, 0xd9, 0x81, 0x4a, 0xfa, 0x93, 0xb8, 0xde,
	0x11, 0x6b, 0x4e, 0x2d, 0x19, 0x9d, 0xd2, 0xfa, 0x4a, 0xf7, 0xee, 0x97, 0xaa, 0x8b, 0x5e, 0x95,
	0x41, 0x89, 0xab, 0x4d, 0xfb, 0x4b, 0x1e, 0xca, 0x03, 0x6a, 0xb3, 0xc0, 0x91, 0xb6, 0x37, 0xa0,
	0x18, 0x88, 0xfd, 0x18, 0xb2, 0xa7, 0x03, 0x49, 0x92, 0x0e, 0xd4, 0x53, 0x4a, 0x57, 0x5d, 0x4d,
	0x32, 0xd2, 0x74, 0x0f, 0x1a, 0x2a, 0x99, 0x11, 0x3d, 0x93, 0xa4, 0x95, 0xe7, 0x3e, 0xcc, 0x2a,
	0xe0, 0xc4, 0xe2, 0x27, 0xd4, 0x39, 0xf0, 0xac, 0x21, 0x95, 0x96, 0x49, 0x42, 0xbc, 0x10, 0x47,
	0xaf, 0xad, 0x21, 0x25, 0x2d, 0x28, 0x49, 0x04, 0x29, 0x86, 0xb8, 0x24, 0x0c, 0x67, 0xf4, 0x15,
	0xfe, 0x50, 0xdf, 0x79, 0x1e, 0x6a, 0xe2, 0x70, 0xdf, 0xa7, 0xb6, 0x34, 0xf8, 0x24, 0x69, 0xce,
	0x7d, 0x6a, 0x8f, 0x61, 0x31, 0x6e, 0x18, 0x37, 0x88, 0xf4, 0x68, 0xb0, 0x2e, 0x73, 0x06, 0x45,
	0xa5, 0xcf, 0x67, 0xb0, 0xa8, 0x03, 0x68, 0x87, 0xc4, 0x36, 0x11, 0x99, 0x3e, 0xb0, 0xf0, 0x9b,
	0x7e, 0x05, 0x04, 0x82, 0x66, 0xb6, 0x92, 0x22, 0xc2, 0x99, 0x9e, 0x43, 0xc3, 0xab, 0x72, 0x62,
	0x80, 0x3f, 0xe7, 0x81, 0x3c, 0x67, 0x5e, 0x18, 0x58, 0x76, 0x88, 0xac, 0x6c, 0x41, 0xdd, 0x96,
	0xd5, 0x71, 0xc5, 0x54, 0x6d, 0xad, 0x4d, 0x34, 0x71, 0xb7, 0x5b, 0xe8, 0x7a, 0x1a, 0x3a, 0x20,
	0x0d, 0xbd, 0x84, 0x95, 0x0c, 0xa6, 0x17, 0x90, 0x27, 0x53, 0x6f, 0x81, 0x2f, 0x22, 0x6c, 0x3d,
	0x00, 0xa2, 0xb3, 0x48, 0x58, 0x1d, 0xb3, 0xc2, 0x59, 0x26, 0x8d, 0xb4, 0x69, 0x69, 0x61, 0xee,
	0xe3, 0x04, 0xd4, 0xe3, 0x59, 0x44, 0xde, 0x9e, 0x82, 0x9c, 0xa0, 0x71, 0xad, 0x95, 0x03, 0xd4,
	0x02, 0x4d, 0xcf, 0x9d, 0xc6, 0x08, 0x0e, 0x4b, 0x5f, 0x3b, 0xb0, 0x7c, 0x0b, 0xb9, 0xd7, 0xd6,
	0xbf, 0x18, 0xcf, 0xb8, 0xda, 0x84, 0x85, 0x5b, 0x8d, 0xb2, 0xe3, 0x3b, 0x87, 0x3b, 0xa0, 0x11,
	0x56, 0x1f, 0x14, 0x65, 0x39, 0xf6, 0x56, 0x55, 0x84, 0x70, 0xfc, 0x0e, 0x66, 0x33, 0x3f, 0x2f,
	0x9a, 0xe9, 0xd5, 0xfb, 0x66, 0x3a, 0xfb, 0x8e, 0x0e, 0x88, 0x9d, 0xa9, 0x6d, 0xbf, 0xbf, 0xb8,
	0x36, 0x8d, 0xcb, 0x6b, 0xd3, 0xf8, 0x71, 0x6d, 0x1a, 0xe7, 0x37, 0x66, 0xee, 0xf2, 0xc6, 0xcc,
	0x7d, 0xbb, 0x31, 0x73, 0xf0, 0x8f, 0xcb, 0xee, 0xe9, 0xbd, 0x67, 0xbc, 0xdd, 0x38, 0x76, 0xc3,
	0x93, 0xd1, 0x61, 0xd7, 0x66, 0xc3, 0x9e, 0x0a, 0xad, 0xb9, 0x0c, 0xed, 0x7a, 0x67, 0xea, 0xff,
	0x83, 0xf0, 0x83, 0x4f, 0xf9, 0x61, 0x41, 0xfc, 0xb1, 0x7f, 0xf8, 0x3b, 0x00, 0x00, 0xff, 0xff,
	0xea, 0x47, 0x7e, 0x34, 0x43, 0x08, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ScopeIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeIdInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeIdInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScopeUuid) > 0 {
		i -= len(m.ScopeUuid)
		copy(dAtA[i:], m.ScopeUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeUuid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ScopeAddr) > 0 {
		i -= len(m.ScopeAddr)
		copy(dAtA[i:], m.ScopeAddr)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ScopeIdScopeUuid) > 0 {
		i -= len(m.ScopeIdScopeUuid)
		copy(dAtA[i:], m.ScopeIdScopeUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeIdScopeUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScopeIdPrefix) > 0 {
		i -= len(m.ScopeIdPrefix)
		copy(dAtA[i:], m.ScopeIdPrefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeIdPrefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ScopeId.Size()
		i -= size
		if _, err := m.ScopeId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionIdInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionIdInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScopeIdInfo != nil {
		{
			size, err := m.ScopeIdInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SessionUuid) > 0 {
		i -= len(m.SessionUuid)
		copy(dAtA[i:], m.SessionUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SessionUuid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SessionAddr) > 0 {
		i -= len(m.SessionAddr)
		copy(dAtA[i:], m.SessionAddr)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SessionAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SessionIdSessionUuid) > 0 {
		i -= len(m.SessionIdSessionUuid)
		copy(dAtA[i:], m.SessionIdSessionUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SessionIdSessionUuid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SessionIdScopeUuid) > 0 {
		i -= len(m.SessionIdScopeUuid)
		copy(dAtA[i:], m.SessionIdScopeUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SessionIdScopeUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionIdPrefix) > 0 {
		i -= len(m.SessionIdPrefix)
		copy(dAtA[i:], m.SessionIdPrefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SessionIdPrefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.SessionId.Size()
		i -= size
		if _, err := m.SessionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecordIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordIdInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordIdInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScopeIdInfo != nil {
		{
			size, err := m.ScopeIdInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RecordAddr) > 0 {
		i -= len(m.RecordAddr)
		copy(dAtA[i:], m.RecordAddr)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RecordIdHashedName) > 0 {
		i -= len(m.RecordIdHashedName)
		copy(dAtA[i:], m.RecordIdHashedName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordIdHashedName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RecordIdScopeUuid) > 0 {
		i -= len(m.RecordIdScopeUuid)
		copy(dAtA[i:], m.RecordIdScopeUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordIdScopeUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RecordIdPrefix) > 0 {
		i -= len(m.RecordIdPrefix)
		copy(dAtA[i:], m.RecordIdPrefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordIdPrefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.RecordId.Size()
		i -= size
		if _, err := m.RecordId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ScopeSpecIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeSpecIdInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeSpecIdInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScopeSpecUuid) > 0 {
		i -= len(m.ScopeSpecUuid)
		copy(dAtA[i:], m.ScopeSpecUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeSpecUuid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ScopeSpecAddr) > 0 {
		i -= len(m.ScopeSpecAddr)
		copy(dAtA[i:], m.ScopeSpecAddr)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeSpecAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ScopeSpecIdScopeSpecUuid) > 0 {
		i -= len(m.ScopeSpecIdScopeSpecUuid)
		copy(dAtA[i:], m.ScopeSpecIdScopeSpecUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeSpecIdScopeSpecUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScopeSpecIdPrefix) > 0 {
		i -= len(m.ScopeSpecIdPrefix)
		copy(dAtA[i:], m.ScopeSpecIdPrefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ScopeSpecIdPrefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ScopeSpecId.Size()
		i -= size
		if _, err := m.ScopeSpecId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ContractSpecIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractSpecIdInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractSpecIdInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractSpecUuid) > 0 {
		i -= len(m.ContractSpecUuid)
		copy(dAtA[i:], m.ContractSpecUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ContractSpecUuid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractSpecAddr) > 0 {
		i -= len(m.ContractSpecAddr)
		copy(dAtA[i:], m.ContractSpecAddr)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ContractSpecAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContractSpecIdContractSpecUuid) > 0 {
		i -= len(m.ContractSpecIdContractSpecUuid)
		copy(dAtA[i:], m.ContractSpecIdContractSpecUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ContractSpecIdContractSpecUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContractSpecIdPrefix) > 0 {
		i -= len(m.ContractSpecIdPrefix)
		copy(dAtA[i:], m.ContractSpecIdPrefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ContractSpecIdPrefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ContractSpecId.Size()
		i -= size
		if _, err := m.ContractSpecId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecordSpecIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordSpecIdInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordSpecIdInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContractSpecIdInfo != nil {
		{
			size, err := m.ContractSpecIdInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RecordSpecAddr) > 0 {
		i -= len(m.RecordSpecAddr)
		copy(dAtA[i:], m.RecordSpecAddr)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordSpecAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RecordSpecIdHashedName) > 0 {
		i -= len(m.RecordSpecIdHashedName)
		copy(dAtA[i:], m.RecordSpecIdHashedName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordSpecIdHashedName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RecordSpecIdContractSpecUuid) > 0 {
		i -= len(m.RecordSpecIdContractSpecUuid)
		copy(dAtA[i:], m.RecordSpecIdContractSpecUuid)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordSpecIdContractSpecUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RecordSpecIdPrefix) > 0 {
		i -= len(m.RecordSpecIdPrefix)
		copy(dAtA[i:], m.RecordSpecIdPrefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.RecordSpecIdPrefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.RecordSpecId.Size()
		i -= size
		if _, err := m.RecordSpecId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ScopeIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ScopeId.Size()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.ScopeIdPrefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ScopeIdScopeUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ScopeAddr)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ScopeUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *SessionIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionId.Size()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.SessionIdPrefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.SessionIdScopeUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.SessionIdSessionUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.SessionAddr)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.SessionUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.ScopeIdInfo != nil {
		l = m.ScopeIdInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *RecordIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RecordId.Size()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.RecordIdPrefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.RecordIdScopeUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.RecordIdHashedName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.RecordAddr)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.ScopeIdInfo != nil {
		l = m.ScopeIdInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *ScopeSpecIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ScopeSpecId.Size()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.ScopeSpecIdPrefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ScopeSpecIdScopeSpecUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ScopeSpecAddr)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ScopeSpecUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *ContractSpecIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ContractSpecId.Size()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.ContractSpecIdPrefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ContractSpecIdContractSpecUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ContractSpecAddr)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ContractSpecUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *RecordSpecIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RecordSpecId.Size()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.RecordSpecIdPrefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.RecordSpecIdContractSpecUuid)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.RecordSpecIdHashedName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.RecordSpecAddr)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.ContractSpecIdInfo != nil {
		l = m.ContractSpecIdInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ScopeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeIdPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeIdPrefix = append(m.ScopeIdPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.ScopeIdPrefix == nil {
				m.ScopeIdPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeIdScopeUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeIdScopeUuid = append(m.ScopeIdScopeUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.ScopeIdScopeUuid == nil {
				m.ScopeIdScopeUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionIdPrefix = append(m.SessionIdPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionIdPrefix == nil {
				m.SessionIdPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdScopeUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionIdScopeUuid = append(m.SessionIdScopeUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionIdScopeUuid == nil {
				m.SessionIdScopeUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdSessionUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionIdSessionUuid = append(m.SessionIdSessionUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionIdSessionUuid == nil {
				m.SessionIdSessionUuid = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeIdInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeIdInfo == nil {
				m.ScopeIdInfo = &ScopeIdInfo{}
			}
			if err := m.ScopeIdInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordIdPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordIdPrefix = append(m.RecordIdPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.RecordIdPrefix == nil {
				m.RecordIdPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordIdScopeUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordIdScopeUuid = append(m.RecordIdScopeUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.RecordIdScopeUuid == nil {
				m.RecordIdScopeUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordIdHashedName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordIdHashedName = append(m.RecordIdHashedName[:0], dAtA[iNdEx:postIndex]...)
			if m.RecordIdHashedName == nil {
				m.RecordIdHashedName = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeIdInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeIdInfo == nil {
				m.ScopeIdInfo = &ScopeIdInfo{}
			}
			if err := m.ScopeIdInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeSpecIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeSpecIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeSpecIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeSpecId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ScopeSpecId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeSpecIdPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeSpecIdPrefix = append(m.ScopeSpecIdPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.ScopeSpecIdPrefix == nil {
				m.ScopeSpecIdPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeSpecIdScopeSpecUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeSpecIdScopeSpecUuid = append(m.ScopeSpecIdScopeSpecUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.ScopeSpecIdScopeSpecUuid == nil {
				m.ScopeSpecIdScopeSpecUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeSpecAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeSpecAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeSpecUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeSpecUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractSpecIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractSpecIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractSpecIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSpecId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractSpecId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSpecIdPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractSpecIdPrefix = append(m.ContractSpecIdPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.ContractSpecIdPrefix == nil {
				m.ContractSpecIdPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSpecIdContractSpecUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractSpecIdContractSpecUuid = append(m.ContractSpecIdContractSpecUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.ContractSpecIdContractSpecUuid == nil {
				m.ContractSpecIdContractSpecUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSpecAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractSpecAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSpecUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractSpecUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordSpecIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordSpecIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordSpecIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSpecId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordSpecId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSpecIdPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordSpecIdPrefix = append(m.RecordSpecIdPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.RecordSpecIdPrefix == nil {
				m.RecordSpecIdPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSpecIdContractSpecUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordSpecIdContractSpecUuid = append(m.RecordSpecIdContractSpecUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.RecordSpecIdContractSpecUuid == nil {
				m.RecordSpecIdContractSpecUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSpecIdHashedName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordSpecIdHashedName = append(m.RecordSpecIdHashedName[:0], dAtA[iNdEx:postIndex]...)
			if m.RecordSpecIdHashedName == nil {
				m.RecordSpecIdHashedName = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSpecAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordSpecAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSpecIdInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractSpecIdInfo == nil {
				m.ContractSpecIdInfo = &ContractSpecIdInfo{}
			}
			if err := m.ContractSpecIdInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetadata = fmt.Errorf("proto: unexpected end of group")
)
