// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/queryobjectstore.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OSLocationRequest is used for requesting a Objectstore location by name
type OSLocatorRequest struct {
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *OSLocatorRequest) Reset()         { *m = OSLocatorRequest{} }
func (m *OSLocatorRequest) String() string { return proto.CompactTextString(m) }
func (*OSLocatorRequest) ProtoMessage()    {}
func (*OSLocatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_36c7a4f74dbb6060, []int{0}
}
func (m *OSLocatorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSLocatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSLocatorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSLocatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSLocatorRequest.Merge(m, src)
}
func (m *OSLocatorRequest) XXX_Size() int {
	return m.Size()
}
func (m *OSLocatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OSLocatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OSLocatorRequest proto.InternalMessageInfo

func (m *OSLocatorRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// ScopeResponse is the response to a scope request.
type OSLocatorResponse struct {
	Locator *ObjectStoreLocator `protobuf:"bytes,1,opt,name=locator,proto3" json:"locator,omitempty"`
}

func (m *OSLocatorResponse) Reset()         { *m = OSLocatorResponse{} }
func (m *OSLocatorResponse) String() string { return proto.CompactTextString(m) }
func (*OSLocatorResponse) ProtoMessage()    {}
func (*OSLocatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_36c7a4f74dbb6060, []int{1}
}
func (m *OSLocatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSLocatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSLocatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSLocatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSLocatorResponse.Merge(m, src)
}
func (m *OSLocatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *OSLocatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OSLocatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OSLocatorResponse proto.InternalMessageInfo

func (m *OSLocatorResponse) GetLocator() *ObjectStoreLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

// QueryParamsRequest is the request type for the Query/Params RPC method.
type OSLocatorQueryParamsRequest struct {
}

func (m *OSLocatorQueryParamsRequest) Reset()         { *m = OSLocatorQueryParamsRequest{} }
func (m *OSLocatorQueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*OSLocatorQueryParamsRequest) ProtoMessage()    {}
func (*OSLocatorQueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_36c7a4f74dbb6060, []int{2}
}
func (m *OSLocatorQueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSLocatorQueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSLocatorQueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSLocatorQueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSLocatorQueryParamsRequest.Merge(m, src)
}
func (m *OSLocatorQueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *OSLocatorQueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OSLocatorQueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OSLocatorQueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is the response type for the Query/Params RPC method.
type OSLocatorQueryParamsResponse struct {
	// params defines the parameters of the module.
	Params OSLocatorParams `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *OSLocatorQueryParamsResponse) Reset()         { *m = OSLocatorQueryParamsResponse{} }
func (m *OSLocatorQueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*OSLocatorQueryParamsResponse) ProtoMessage()    {}
func (*OSLocatorQueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_36c7a4f74dbb6060, []int{3}
}
func (m *OSLocatorQueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSLocatorQueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSLocatorQueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSLocatorQueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSLocatorQueryParamsResponse.Merge(m, src)
}
func (m *OSLocatorQueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *OSLocatorQueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OSLocatorQueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OSLocatorQueryParamsResponse proto.InternalMessageInfo

func (m *OSLocatorQueryParamsResponse) GetParams() OSLocatorParams {
	if m != nil {
		return m.Params
	}
	return OSLocatorParams{}
}

// Params defines the parameters for the auth module.
type OSLocatorParams struct {
	MaxUriCharacters uint64 `protobuf:"varint,1,opt,name=max_uri_characters,json=maxUriCharacters,proto3,customtype=uint64" json:"max_uri_characters" yaml:"max_uri_characters"`
}

func (m *OSLocatorParams) Reset()         { *m = OSLocatorParams{} }
func (m *OSLocatorParams) String() string { return proto.CompactTextString(m) }
func (*OSLocatorParams) ProtoMessage()    {}
func (*OSLocatorParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_36c7a4f74dbb6060, []int{4}
}
func (m *OSLocatorParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSLocatorParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSLocatorParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSLocatorParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSLocatorParams.Merge(m, src)
}
func (m *OSLocatorParams) XXX_Size() int {
	return m.Size()
}
func (m *OSLocatorParams) XXX_DiscardUnknown() {
	xxx_messageInfo_OSLocatorParams.DiscardUnknown(m)
}

var xxx_messageInfo_OSLocatorParams proto.InternalMessageInfo

func init() {
	proto.RegisterType((*OSLocatorRequest)(nil), "provenance.metadata.v1.OSLocatorRequest")
	proto.RegisterType((*OSLocatorResponse)(nil), "provenance.metadata.v1.OSLocatorResponse")
	proto.RegisterType((*OSLocatorQueryParamsRequest)(nil), "provenance.metadata.v1.OSLocatorQueryParamsRequest")
	proto.RegisterType((*OSLocatorQueryParamsResponse)(nil), "provenance.metadata.v1.OSLocatorQueryParamsResponse")
	proto.RegisterType((*OSLocatorParams)(nil), "provenance.metadata.v1.OSLocatorParams")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/queryobjectstore.proto", fileDescriptor_36c7a4f74dbb6060)
}

var fileDescriptor_36c7a4f74dbb6060 = []byte{
	// 469 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xbf, 0x6e, 0x13, 0x31,
	0x1c, 0xc7, 0x73, 0x55, 0x49, 0x85, 0x19, 0x28, 0x56, 0x85, 0x68, 0x28, 0x17, 0xe4, 0x81, 0x5e,
	0x41, 0x3d, 0xab, 0x6d, 0xc4, 0xc0, 0x18, 0x60, 0x43, 0x4a, 0x49, 0xc4, 0x50, 0x96, 0xca, 0x39,
	0xac, 0xab, 0x21, 0xe7, 0xdf, 0xd5, 0xe7, 0x0b, 0x89, 0x10, 0x0b, 0x4f, 0x80, 0xe0, 0x11, 0x78,
	0x15, 0x86, 0x8e, 0x95, 0x58, 0x10, 0x43, 0x84, 0x12, 0x9e, 0x80, 0x27, 0x40, 0xb1, 0x7d, 0x6d,
	0x44, 0x72, 0x0a, 0x6c, 0xce, 0x2f, 0xdf, 0x3f, 0x1f, 0xff, 0xe2, 0xa0, 0xdd, 0x54, 0x41, 0x9f,
	0x4b, 0x26, 0x23, 0x4e, 0x13, 0xae, 0xd9, 0x2b, 0xa6, 0x19, 0xed, 0xef, 0xd1, 0xd3, 0x9c, 0xab,
	0x21, 0x74, 0x5f, 0xf3, 0x48, 0x67, 0x1a, 0x14, 0x0f, 0x53, 0x05, 0x1a, 0xf0, 0xcd, 0x4b, 0x79,
	0x58, 0xc8, 0xc3, 0xfe, 0x5e, 0x6d, 0x2b, 0x06, 0x88, 0x7b, 0x9c, 0xb2, 0x54, 0x50, 0x26, 0x25,
	0x68, 0xa6, 0x05, 0xc8, 0xcc, 0xba, 0x6a, 0x41, 0x49, 0xc9, 0x5c, 0x7e, 0x6d, 0x23, 0x86, 0x18,
	0xcc, 0x91, 0x4e, 0x4f, 0x76, 0x4a, 0x02, 0xb4, 0xde, 0xea, 0x3c, 0x83, 0x88, 0x69, 0x50, 0x6d,
	0x7e, 0x9a, 0xf3, 0x4c, 0xe3, 0x0d, 0x74, 0x05, 0xde, 0x4a, 0xae, 0x6e, 0x79, 0x77, 0xbd, 0xe0,
	0x6a, 0xdb, 0x7e, 0x20, 0x47, 0xe8, 0xc6, 0x8c, 0x32, 0x4b, 0x41, 0x66, 0x1c, 0x3f, 0x41, 0x6b,
	0x3d, 0x3b, 0x32, 0xe2, 0x6b, 0xfb, 0xf7, 0xc3, 0xc5, 0xd7, 0x08, 0x5b, 0x06, 0xa8, 0x33, 0x05,
	0x2a, 0x42, 0x0a, 0x2b, 0xb9, 0x83, 0x6e, 0x5f, 0x44, 0x3f, 0x9f, 0x6e, 0xe7, 0x90, 0x29, 0x96,
	0x64, 0x8e, 0x87, 0x70, 0xb4, 0xb5, 0xf8, 0x6b, 0x07, 0xf1, 0x14, 0x55, 0x53, 0x33, 0x71, 0x0c,
	0xdb, 0xa5, 0x0c, 0x45, 0x8a, 0x0d, 0x68, 0xae, 0x9e, 0x8d, 0xea, 0x95, 0xb6, 0x33, 0x93, 0x1e,
	0xba, 0xfe, 0x97, 0x00, 0x1f, 0x21, 0x9c, 0xb0, 0xc1, 0x71, 0xae, 0xc4, 0x71, 0x74, 0xc2, 0x14,
	0x8b, 0x34, 0x57, 0xb6, 0x65, 0xb5, 0xf9, 0x60, 0x6a, 0xfe, 0x31, 0xaa, 0x57, 0x73, 0x21, 0xf5,
	0xc3, 0xc6, 0xef, 0x51, 0x7d, 0x73, 0xc8, 0x92, 0xde, 0x23, 0x32, 0xef, 0x20, 0xed, 0xf5, 0x84,
	0x0d, 0x5e, 0x28, 0xf1, 0xf8, 0x62, 0xb4, 0xff, 0x75, 0x05, 0xad, 0x99, 0xcb, 0xb4, 0x3a, 0xf8,
	0x8b, 0x87, 0xaa, 0xae, 0xf1, 0x60, 0x29, 0xfb, 0xfc, 0x82, 0x6a, 0x8d, 0xff, 0x33, 0xd9, 0xb5,
	0x91, 0xf0, 0xc3, 0xb7, 0x5f, 0x9f, 0x57, 0x02, 0x7c, 0x8f, 0x96, 0xbc, 0x21, 0xf7, 0xf3, 0x50,
	0xbb, 0x1f, 0xfc, 0xc9, 0x43, 0xc8, 0x05, 0x0a, 0x90, 0x38, 0x58, 0x5a, 0x5a, 0xe0, 0xed, 0xfc,
	0x83, 0xd2, 0x31, 0x51, 0xc3, 0xb4, 0x83, 0xb7, 0x97, 0x31, 0xbd, 0x33, 0x8f, 0xf2, 0x7d, 0xf3,
	0xcd, 0xd9, 0xd8, 0xf7, 0xce, 0xc7, 0xbe, 0xf7, 0x73, 0xec, 0x7b, 0x1f, 0x27, 0x7e, 0xe5, 0x7c,
	0xe2, 0x57, 0xbe, 0x4f, 0xfc, 0x0a, 0xda, 0x14, 0x50, 0xd2, 0x7b, 0xe8, 0xbd, 0x6c, 0xc4, 0x42,
	0x9f, 0xe4, 0xdd, 0x30, 0x82, 0x64, 0xa6, 0x69, 0x57, 0xc0, 0x6c, 0xef, 0xe0, 0xb2, 0x59, 0x0f,
	0x53, 0x9e, 0x75, 0xab, 0xe6, 0x3f, 0x73, 0xf0, 0x27, 0x00, 0x00, 0xff, 0xff, 0x56, 0xa4, 0xc0,
	0xb0, 0xda, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryOSClient is the client API for QueryOS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryOSClient interface {
	// Params queries all parameters.
	Params(ctx context.Context, in *OSLocatorQueryParamsRequest, opts ...grpc.CallOption) (*OSLocatorQueryParamsResponse, error)
	// Scope returns a specific scope by id
	OSLocation(ctx context.Context, in *OSLocatorRequest, opts ...grpc.CallOption) (*OSLocatorResponse, error)
}

type queryOSClient struct {
	cc grpc1.ClientConn
}

func NewQueryOSClient(cc grpc1.ClientConn) QueryOSClient {
	return &queryOSClient{cc}
}

func (c *queryOSClient) Params(ctx context.Context, in *OSLocatorQueryParamsRequest, opts ...grpc.CallOption) (*OSLocatorQueryParamsResponse, error) {
	out := new(OSLocatorQueryParamsResponse)
	err := c.cc.Invoke(ctx, "/provenance.metadata.v1.QueryOS/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryOSClient) OSLocation(ctx context.Context, in *OSLocatorRequest, opts ...grpc.CallOption) (*OSLocatorResponse, error) {
	out := new(OSLocatorResponse)
	err := c.cc.Invoke(ctx, "/provenance.metadata.v1.QueryOS/OSLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryOSServer is the server API for QueryOS service.
type QueryOSServer interface {
	// Params queries all parameters.
	Params(context.Context, *OSLocatorQueryParamsRequest) (*OSLocatorQueryParamsResponse, error)
	// Scope returns a specific scope by id
	OSLocation(context.Context, *OSLocatorRequest) (*OSLocatorResponse, error)
}

// UnimplementedQueryOSServer can be embedded to have forward compatible implementations.
type UnimplementedQueryOSServer struct {
}

func (*UnimplementedQueryOSServer) Params(ctx context.Context, req *OSLocatorQueryParamsRequest) (*OSLocatorQueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryOSServer) OSLocation(ctx context.Context, req *OSLocatorRequest) (*OSLocatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OSLocation not implemented")
}

func RegisterQueryOSServer(s grpc1.Server, srv QueryOSServer) {
	s.RegisterService(&_QueryOS_serviceDesc, srv)
}

func _QueryOS_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OSLocatorQueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryOSServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/provenance.metadata.v1.QueryOS/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryOSServer).Params(ctx, req.(*OSLocatorQueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryOS_OSLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OSLocatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryOSServer).OSLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/provenance.metadata.v1.QueryOS/OSLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryOSServer).OSLocation(ctx, req.(*OSLocatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "provenance.metadata.v1.QueryOS",
	HandlerType: (*QueryOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _QueryOS_Params_Handler,
		},
		{
			MethodName: "OSLocation",
			Handler:    _QueryOS_OSLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "provenance/metadata/v1/queryobjectstore.proto",
}

func (m *OSLocatorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSLocatorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSLocatorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintQueryobjectstore(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSLocatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSLocatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSLocatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Locator != nil {
		{
			size, err := m.Locator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQueryobjectstore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSLocatorQueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSLocatorQueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSLocatorQueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OSLocatorQueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSLocatorQueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSLocatorQueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQueryobjectstore(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OSLocatorParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSLocatorParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSLocatorParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxUriCharacters != 0 {
		i = encodeVarintQueryobjectstore(dAtA, i, uint64(m.MaxUriCharacters))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQueryobjectstore(dAtA []byte, offset int, v uint64) int {
	offset -= sovQueryobjectstore(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OSLocatorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovQueryobjectstore(uint64(l))
	}
	return n
}

func (m *OSLocatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Locator != nil {
		l = m.Locator.Size()
		n += 1 + l + sovQueryobjectstore(uint64(l))
	}
	return n
}

func (m *OSLocatorQueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OSLocatorQueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQueryobjectstore(uint64(l))
	return n
}

func (m *OSLocatorParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxUriCharacters != 0 {
		n += 1 + sovQueryobjectstore(uint64(m.MaxUriCharacters))
	}
	return n
}

func sovQueryobjectstore(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQueryobjectstore(x uint64) (n int) {
	return sovQueryobjectstore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OSLocatorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryobjectstore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSLocatorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSLocatorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryobjectstore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryobjectstore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSLocatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryobjectstore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSLocatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSLocatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryobjectstore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locator == nil {
				m.Locator = &ObjectStoreLocator{}
			}
			if err := m.Locator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryobjectstore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSLocatorQueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryobjectstore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSLocatorQueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSLocatorQueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQueryobjectstore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSLocatorQueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryobjectstore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSLocatorQueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSLocatorQueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryobjectstore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryobjectstore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSLocatorParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryobjectstore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSLocatorParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSLocatorParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUriCharacters", wireType)
			}
			m.MaxUriCharacters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryobjectstore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUriCharacters |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQueryobjectstore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQueryobjectstore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQueryobjectstore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQueryobjectstore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryobjectstore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryobjectstore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQueryobjectstore
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQueryobjectstore
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQueryobjectstore
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQueryobjectstore        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQueryobjectstore          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQueryobjectstore = fmt.Errorf("proto: unexpected end of group")
)
