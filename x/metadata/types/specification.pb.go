// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/specification.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DefinitionType indicates the required definition type for this value
type DefinitionType int32

const (
	// DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value
	DefinitionType_DEFINITION_TYPE_UNSPECIFIED DefinitionType = 0
	// DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)
	DefinitionType_DEFINITION_TYPE_PROPOSED DefinitionType = 1
	// DEFINITION_TYPE_FACT indicates the value must be a reference to a record on chain
	DefinitionType_DEFINITION_TYPE_FACT DefinitionType = 2
	// DEFINITION_TYPE_FACT_LIST indicates the value maybe a reference to a colleciton of values on chain having
	// the same name
	DefinitionType_DEFINITION_TYPE_FACT_LIST DefinitionType = 3
)

var DefinitionType_name = map[int32]string{
	0: "DEFINITION_TYPE_UNSPECIFIED",
	1: "DEFINITION_TYPE_PROPOSED",
	2: "DEFINITION_TYPE_FACT",
	3: "DEFINITION_TYPE_FACT_LIST",
}

var DefinitionType_value = map[string]int32{
	"DEFINITION_TYPE_UNSPECIFIED": 0,
	"DEFINITION_TYPE_PROPOSED":    1,
	"DEFINITION_TYPE_FACT":        2,
	"DEFINITION_TYPE_FACT_LIST":   3,
}

func (x DefinitionType) String() string {
	return proto.EnumName(DefinitionType_name, int32(x))
}

func (DefinitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{0}
}

// PartyType are the different roles parties on a contract may use
type PartyType int32

const (
	// PARTY_TYPE_UNSPECIFIED is an error condition
	PartyType_PARTY_TYPE_UNSPECIFIED PartyType = 0
	// PARTY_TYPE_ORIGINATOR is an asset originator
	PartyType_PARTY_TYPE_ORIGINATOR PartyType = 1
	// PARTY_TYPE_SERVICER provides debt servicing functions
	PartyType_PARTY_TYPE_SERVICER PartyType = 2
	// PARTY_TYPE_INVESTOR is a generic investor
	PartyType_PARTY_TYPE_INVESTOR PartyType = 3
	// PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets
	PartyType_PARTY_TYPE_CUSTODIAN PartyType = 4
	// PARTY_TYPE_OWNER indicates this party is an owner of the item
	PartyType_PARTY_TYPE_OWNER PartyType = 5
	// PARTY_TYPE_AFFILIATE is a party with an affiliate agreement
	PartyType_PARTY_TYPE_AFFILIATE PartyType = 6
	// PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account
	PartyType_PARTY_TYPE_OMNIBUS PartyType = 7
	// PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action
	PartyType_PARTY_TYPE_PROVENANCE PartyType = 8
)

var PartyType_name = map[int32]string{
	0: "PARTY_TYPE_UNSPECIFIED",
	1: "PARTY_TYPE_ORIGINATOR",
	2: "PARTY_TYPE_SERVICER",
	3: "PARTY_TYPE_INVESTOR",
	4: "PARTY_TYPE_CUSTODIAN",
	5: "PARTY_TYPE_OWNER",
	6: "PARTY_TYPE_AFFILIATE",
	7: "PARTY_TYPE_OMNIBUS",
	8: "PARTY_TYPE_PROVENANCE",
}

var PartyType_value = map[string]int32{
	"PARTY_TYPE_UNSPECIFIED": 0,
	"PARTY_TYPE_ORIGINATOR":  1,
	"PARTY_TYPE_SERVICER":    2,
	"PARTY_TYPE_INVESTOR":    3,
	"PARTY_TYPE_CUSTODIAN":   4,
	"PARTY_TYPE_OWNER":       5,
	"PARTY_TYPE_AFFILIATE":   6,
	"PARTY_TYPE_OMNIBUS":     7,
	"PARTY_TYPE_PROVENANCE":  8,
}

func (x PartyType) String() string {
	return proto.EnumName(PartyType_name, int32(x))
}

func (PartyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{1}
}

// ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract
type ScopeSpecification struct {
	// unique identifier for this specification on chain
	SpecificationId MetadataAddress `protobuf:"bytes,1,opt,name=specification_id,json=specificationId,proto3,customtype=MetadataAddress" json:"specification_id" yaml:"specification_id"`
	// General information about this scope specification.
	Description *Description `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Addresses of the owners of this scope specification.
	OwnerAddresses []string `protobuf:"bytes,3,rep,name=owner_addresses,json=ownerAddresses,proto3" json:"owner_addresses,omitempty" yaml:"owner_address"`
	// A list of parties that must be present on a scope (and their associated roles)
	PartiesInvolved []PartyType `protobuf:"varint,4,rep,packed,name=parties_involved,json=partiesInvolved,proto3,enum=provenance.metadata.v1.PartyType" json:"parties_involved,omitempty" yaml:"parties_involved"`
	// A list of group specification ids allowed for a scope based on this specification.
	GroupSpecIds []MetadataAddress `protobuf:"bytes,5,rep,name=group_spec_ids,json=groupSpecIds,proto3,customtype=MetadataAddress" json:"group_spec_ids" yaml:"group_spec_ids"`
}

func (m *ScopeSpecification) Reset()         { *m = ScopeSpecification{} }
func (m *ScopeSpecification) String() string { return proto.CompactTextString(m) }
func (*ScopeSpecification) ProtoMessage()    {}
func (*ScopeSpecification) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{0}
}
func (m *ScopeSpecification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeSpecification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeSpecification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeSpecification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeSpecification.Merge(m, src)
}
func (m *ScopeSpecification) XXX_Size() int {
	return m.Size()
}
func (m *ScopeSpecification) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeSpecification.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeSpecification proto.InternalMessageInfo

func (m *ScopeSpecification) GetDescription() *Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *ScopeSpecification) GetOwnerAddresses() []string {
	if m != nil {
		return m.OwnerAddresses
	}
	return nil
}

func (m *ScopeSpecification) GetPartiesInvolved() []PartyType {
	if m != nil {
		return m.PartiesInvolved
	}
	return nil
}

// GroupSpecification defines the required parties, resources, conditions, and consideration outputs for a contract
type GroupSpecification struct {
	// unique identifier for this specification on chain
	SpecificationId MetadataAddress `protobuf:"bytes,1,opt,name=specification_id,json=specificationId,proto3,customtype=MetadataAddress" json:"specification_id" yaml:"specification_id"`
	// The definition points to a resource that defines the instance of code that will process this group
	Definition *Definition `protobuf:"bytes,2,opt,name=definition,proto3" json:"definition,omitempty"`
	// input specifications indicating proposed (off chain data values) and facts (on chain qualified references)
	InputSpecs []*Definition `protobuf:"bytes,3,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	// a list of parties that must sign a transaction using a given role
	PartiesInvolved []PartyType `protobuf:"varint,4,rep,packed,name=parties_involved,json=partiesInvolved,proto3,enum=provenance.metadata.v1.PartyType" json:"parties_involved,omitempty"`
	// a colleciton of checks that must be satisfied against a scope prior to allowing a record to be added under this
	// specification
	ConditionSpecs []*ConditionSpec `protobuf:"bytes,5,rep,name=condition_specs,json=conditionSpecs,proto3" json:"condition_specs,omitempty"`
	// a colleciton of method/process specifications that when performed and documented by responsible parties listed
	// above, result in adding a new record to the scope as defined in the output_spec
	ConsiderationSpecs []*ConsiderationSpec `protobuf:"bytes,6,rep,name=consideration_specs,json=considerationSpecs,proto3" json:"consideration_specs,omitempty"`
}

func (m *GroupSpecification) Reset()         { *m = GroupSpecification{} }
func (m *GroupSpecification) String() string { return proto.CompactTextString(m) }
func (*GroupSpecification) ProtoMessage()    {}
func (*GroupSpecification) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{1}
}
func (m *GroupSpecification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupSpecification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupSpecification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupSpecification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupSpecification.Merge(m, src)
}
func (m *GroupSpecification) XXX_Size() int {
	return m.Size()
}
func (m *GroupSpecification) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupSpecification.DiscardUnknown(m)
}

var xxx_messageInfo_GroupSpecification proto.InternalMessageInfo

func (m *GroupSpecification) GetDefinition() *Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *GroupSpecification) GetInputSpecs() []*Definition {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *GroupSpecification) GetPartiesInvolved() []PartyType {
	if m != nil {
		return m.PartiesInvolved
	}
	return nil
}

func (m *GroupSpecification) GetConditionSpecs() []*ConditionSpec {
	if m != nil {
		return m.ConditionSpecs
	}
	return nil
}

func (m *GroupSpecification) GetConsiderationSpecs() []*ConsiderationSpec {
	if m != nil {
		return m.ConsiderationSpecs
	}
	return nil
}

// RecordSpecification defines the specification for a Record including allowed/required inputs/outputs
type RecordSpecification struct {
}

func (m *RecordSpecification) Reset()         { *m = RecordSpecification{} }
func (m *RecordSpecification) String() string { return proto.CompactTextString(m) }
func (*RecordSpecification) ProtoMessage()    {}
func (*RecordSpecification) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{2}
}
func (m *RecordSpecification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordSpecification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordSpecification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordSpecification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordSpecification.Merge(m, src)
}
func (m *RecordSpecification) XXX_Size() int {
	return m.Size()
}
func (m *RecordSpecification) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordSpecification.DiscardUnknown(m)
}

var xxx_messageInfo_RecordSpecification proto.InternalMessageInfo

// A Contract Specification (used to create a GroupSpecification for the Contract Execution Environment)
type ContractSpec struct {
	// The definition points to a resource that defines the instance of code that will process this group
	Definition *Definition `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
	// input specifications indicating proposed (off chain data values) and facts (on chain qualified references)
	InputSpecs []*Definition `protobuf:"bytes,2,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	// a list of parties that must sign a transaction using a given role
	PartiesInvolved []PartyType `protobuf:"varint,3,rep,packed,name=parties_involved,json=partiesInvolved,proto3,enum=provenance.metadata.v1.PartyType" json:"parties_involved,omitempty"`
	// a colleciton of checks that must be satisfied against a scope prior to allowing a record to be added under this
	// specification
	ConditionSpecs []*ConditionSpec `protobuf:"bytes,4,rep,name=condition_specs,json=conditionSpecs,proto3" json:"condition_specs,omitempty"`
	// a colleciton of method/process specifications that when performed and documented by responsible parties listed
	// above, result in adding a new record to the scope as defined in the output_spec
	ConsiderationSpecs []*ConsiderationSpec `protobuf:"bytes,5,rep,name=consideration_specs,json=considerationSpecs,proto3" json:"consideration_specs,omitempty"`
}

func (m *ContractSpec) Reset()         { *m = ContractSpec{} }
func (m *ContractSpec) String() string { return proto.CompactTextString(m) }
func (*ContractSpec) ProtoMessage()    {}
func (*ContractSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{3}
}
func (m *ContractSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractSpec.Merge(m, src)
}
func (m *ContractSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContractSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContractSpec proto.InternalMessageInfo

func (m *ContractSpec) GetDefinition() *Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *ContractSpec) GetInputSpecs() []*Definition {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ContractSpec) GetPartiesInvolved() []PartyType {
	if m != nil {
		return m.PartiesInvolved
	}
	return nil
}

func (m *ContractSpec) GetConditionSpecs() []*ConditionSpec {
	if m != nil {
		return m.ConditionSpecs
	}
	return nil
}

func (m *ContractSpec) GetConsiderationSpecs() []*ConsiderationSpec {
	if m != nil {
		return m.ConsiderationSpecs
	}
	return nil
}

// Description holds general information that is handy to associate with a structure.
type Description struct {
	// A Name for this thing.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A description of this thing.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// URL to find even more info.
	WebsiteUrl string `protobuf:"bytes,4,opt,name=website_url,json=websiteUrl,proto3" json:"website_url,omitempty" yaml:"website_url"`
	// URL of an icon.
	IconUrl string `protobuf:"bytes,5,opt,name=icon_url,json=iconUrl,proto3" json:"icon_url,omitempty" yaml:"icon_url"`
}

func (m *Description) Reset()         { *m = Description{} }
func (m *Description) String() string { return proto.CompactTextString(m) }
func (*Description) ProtoMessage()    {}
func (*Description) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{4}
}
func (m *Description) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Description) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Description.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Description) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Description.Merge(m, src)
}
func (m *Description) XXX_Size() int {
	return m.Size()
}
func (m *Description) XXX_DiscardUnknown() {
	xxx_messageInfo_Description.DiscardUnknown(m)
}

var xxx_messageInfo_Description proto.InternalMessageInfo

func (m *Description) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Description) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Description) GetWebsiteUrl() string {
	if m != nil {
		return m.WebsiteUrl
	}
	return ""
}

func (m *Description) GetIconUrl() string {
	if m != nil {
		return m.IconUrl
	}
	return ""
}

// Definition encapsulates the information required to uniquely associate a resource with a type and location
type Definition struct {
	// a common name given to this definition.  The name is used to match up with references to this part of the spec
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// location of the resource on chain
	ResourceLocation *Reference `protobuf:"bytes,2,opt,name=resource_location,json=resourceLocation,proto3" json:"resource_location,omitempty"`
	// address of the account that created this definition
	CreatorAddress string `protobuf:"bytes,3,opt,name=creator_address,json=creatorAddress,proto3" json:"creator_address,omitempty"`
	// The type of data definition (proposed, fact/recorded, list)
	DefinitionType DefinitionType `protobuf:"varint,4,opt,name=definition_type,json=definitionType,proto3,enum=provenance.metadata.v1.DefinitionType" json:"definition_type,omitempty"`
}

func (m *Definition) Reset()         { *m = Definition{} }
func (m *Definition) String() string { return proto.CompactTextString(m) }
func (*Definition) ProtoMessage()    {}
func (*Definition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{5}
}
func (m *Definition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Definition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Definition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Definition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Definition.Merge(m, src)
}
func (m *Definition) XXX_Size() int {
	return m.Size()
}
func (m *Definition) XXX_DiscardUnknown() {
	xxx_messageInfo_Definition.DiscardUnknown(m)
}

var xxx_messageInfo_Definition proto.InternalMessageInfo

func (m *Definition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Definition) GetResourceLocation() *Reference {
	if m != nil {
		return m.ResourceLocation
	}
	return nil
}

func (m *Definition) GetCreatorAddress() string {
	if m != nil {
		return m.CreatorAddress
	}
	return ""
}

func (m *Definition) GetDefinitionType() DefinitionType {
	if m != nil {
		return m.DefinitionType
	}
	return DefinitionType_DEFINITION_TYPE_UNSPECIFIED
}

// Reference is a multipart structure that defines a reference to a piece of data recorded within a scope
type Reference struct {
	// unique identifer for the scope being referenced
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id,omitempty"`
	// require record to be within a specific group (optional)
	GroupId string `protobuf:"bytes,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// specify a specific record inside a scope (and group) by result-hash (optional)
	Hash string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	// specify a result-name of a record within a scope (optional)
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// type/classname of the target data (optional)
	TypeName string `protobuf:"bytes,6,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
}

func (m *Reference) Reset()         { *m = Reference{} }
func (m *Reference) String() string { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()    {}
func (*Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{6}
}
func (m *Reference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reference.Merge(m, src)
}
func (m *Reference) XXX_Size() int {
	return m.Size()
}
func (m *Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_Reference proto.InternalMessageInfo

func (m *Reference) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *Reference) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *Reference) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Reference) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

// ConditionSpec defines a collection of outputs and process information listed as preconditions that must be met
// before a contract execution is valid
type ConditionSpec struct {
	// common name for this condition
	Name       string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	InputSpecs []*Definition `protobuf:"bytes,2,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	OutputSpec *Definition   `protobuf:"bytes,3,opt,name=output_spec,json=outputSpec,proto3" json:"output_spec,omitempty"`
}

func (m *ConditionSpec) Reset()         { *m = ConditionSpec{} }
func (m *ConditionSpec) String() string { return proto.CompactTextString(m) }
func (*ConditionSpec) ProtoMessage()    {}
func (*ConditionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{7}
}
func (m *ConditionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionSpec.Merge(m, src)
}
func (m *ConditionSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConditionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionSpec proto.InternalMessageInfo

func (m *ConditionSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConditionSpec) GetInputSpecs() []*Definition {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ConditionSpec) GetOutputSpec() *Definition {
	if m != nil {
		return m.OutputSpec
	}
	return nil
}

// ConsiderationSpec defines a unit of process execution that should be performed by responsible parties in order
// to record a set of outputs within a scope
type ConsiderationSpec struct {
	// common name for this consideration
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Invoking party must be functioning in this role
	ResponsibleParty PartyType `protobuf:"varint,2,opt,name=responsible_party,json=responsibleParty,proto3,enum=provenance.metadata.v1.PartyType" json:"responsible_party,omitempty"`
	// A repeated set of input specifications that must be listed and matched correctly in order to add a record listed
	// in output_spec to the scope
	InputSpecs []*Definition `protobuf:"bytes,3,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	// The specification for the record that will be added to a scope if this consideration is satisfied
	OutputSpec *Definition `protobuf:"bytes,4,opt,name=output_spec,json=outputSpec,proto3" json:"output_spec,omitempty"`
}

func (m *ConsiderationSpec) Reset()         { *m = ConsiderationSpec{} }
func (m *ConsiderationSpec) String() string { return proto.CompactTextString(m) }
func (*ConsiderationSpec) ProtoMessage()    {}
func (*ConsiderationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2d1042057ea889, []int{8}
}
func (m *ConsiderationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsiderationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsiderationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsiderationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsiderationSpec.Merge(m, src)
}
func (m *ConsiderationSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConsiderationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsiderationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConsiderationSpec proto.InternalMessageInfo

func (m *ConsiderationSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConsiderationSpec) GetResponsibleParty() PartyType {
	if m != nil {
		return m.ResponsibleParty
	}
	return PartyType_PARTY_TYPE_UNSPECIFIED
}

func (m *ConsiderationSpec) GetInputSpecs() []*Definition {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ConsiderationSpec) GetOutputSpec() *Definition {
	if m != nil {
		return m.OutputSpec
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.metadata.v1.DefinitionType", DefinitionType_name, DefinitionType_value)
	proto.RegisterEnum("provenance.metadata.v1.PartyType", PartyType_name, PartyType_value)
	proto.RegisterType((*ScopeSpecification)(nil), "provenance.metadata.v1.ScopeSpecification")
	proto.RegisterType((*GroupSpecification)(nil), "provenance.metadata.v1.GroupSpecification")
	proto.RegisterType((*RecordSpecification)(nil), "provenance.metadata.v1.RecordSpecification")
	proto.RegisterType((*ContractSpec)(nil), "provenance.metadata.v1.ContractSpec")
	proto.RegisterType((*Description)(nil), "provenance.metadata.v1.Description")
	proto.RegisterType((*Definition)(nil), "provenance.metadata.v1.Definition")
	proto.RegisterType((*Reference)(nil), "provenance.metadata.v1.Reference")
	proto.RegisterType((*ConditionSpec)(nil), "provenance.metadata.v1.ConditionSpec")
	proto.RegisterType((*ConsiderationSpec)(nil), "provenance.metadata.v1.ConsiderationSpec")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/specification.proto", fileDescriptor_1e2d1042057ea889)
}

var fileDescriptor_1e2d1042057ea889 = []byte{
	// 1033 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcf, 0x6f, 0xe3, 0xd4,
	0x13, 0xaf, 0xeb, 0xa4, 0x6d, 0x26, 0xfd, 0x26, 0xde, 0xd7, 0x1f, 0x9b, 0x6e, 0xbf, 0x24, 0xc1,
	0x08, 0x28, 0x95, 0x48, 0xd8, 0x82, 0x84, 0xc4, 0xcd, 0x49, 0xdd, 0x95, 0xa5, 0xae, 0x13, 0xbd,
	0x24, 0x45, 0xbb, 0x12, 0xb2, 0x5c, 0xfb, 0xb5, 0xb5, 0x48, 0xfc, 0x2c, 0xdb, 0xc9, 0x92, 0x23,
	0x17, 0xc4, 0x11, 0xfe, 0x0f, 0xf8, 0x1f, 0x38, 0xee, 0x71, 0x8f, 0x88, 0x43, 0x84, 0xda, 0x1b,
	0x37, 0x7a, 0xe0, 0x8c, 0xfc, 0xec, 0x34, 0xb6, 0x37, 0x59, 0x2a, 0x08, 0xdc, 0xde, 0xcc, 0x7c,
	0x66, 0xf2, 0x79, 0xf3, 0x99, 0x37, 0x31, 0x1c, 0x3a, 0x2e, 0x1d, 0x11, 0x5b, 0xb7, 0x0d, 0x52,
	0x1f, 0x10, 0x5f, 0x37, 0x75, 0x5f, 0xaf, 0x8f, 0x1e, 0xd7, 0x3d, 0x87, 0x18, 0xd6, 0x85, 0x65,
	0xe8, 0xbe, 0x45, 0xed, 0x9a, 0xe3, 0x52, 0x9f, 0xa2, 0xdd, 0x19, 0xb6, 0x36, 0xc5, 0xd6, 0x46,
	0x8f, 0x1f, 0x6d, 0x5f, 0xd2, 0x4b, 0xca, 0x20, 0xf5, 0xe0, 0x14, 0xa2, 0xc5, 0x9f, 0x78, 0x40,
	0x1d, 0x83, 0x3a, 0xa4, 0x13, 0x2f, 0x85, 0xbe, 0x00, 0x21, 0x51, 0x5b, 0xb3, 0xcc, 0x12, 0x57,
	0xe5, 0x0e, 0x36, 0x1b, 0x47, 0x2f, 0x27, 0x95, 0x95, 0x5f, 0x26, 0x95, 0xe2, 0xd3, 0xa8, 0xb6,
	0x64, 0x9a, 0x2e, 0xf1, 0xbc, 0xdb, 0x49, 0xe5, 0xe1, 0x58, 0x1f, 0xf4, 0x3f, 0x13, 0xd3, 0x89,
	0x22, 0x2e, 0x26, 0x5c, 0x8a, 0x89, 0x64, 0xc8, 0x9b, 0xc4, 0x33, 0x5c, 0xcb, 0x09, 0x1c, 0xa5,
	0xd5, 0x2a, 0x77, 0x90, 0x3f, 0x7a, 0xa7, 0x36, 0x9f, 0x79, 0xed, 0x78, 0x06, 0xc5, 0xf1, 0x3c,
	0x24, 0x41, 0x91, 0xbe, 0xb0, 0x89, 0xab, 0xe9, 0x21, 0x07, 0xe2, 0x95, 0xf8, 0x2a, 0x7f, 0x90,
	0x6b, 0x94, 0x6e, 0x27, 0x95, 0xed, 0x90, 0x4d, 0x02, 0x20, 0xe2, 0x02, 0xb3, 0xa5, 0x29, 0x1e,
	0x59, 0x20, 0x38, 0xba, 0xeb, 0x5b, 0xc4, 0xd3, 0x2c, 0x7b, 0x44, 0xfb, 0x23, 0x62, 0x96, 0x32,
	0x55, 0xfe, 0xa0, 0x70, 0xf4, 0xf6, 0x22, 0x3a, 0x6d, 0xdd, 0xf5, 0xc7, 0xdd, 0xb1, 0x43, 0x1a,
	0xfb, 0xb3, 0x4b, 0xa7, 0x8b, 0x88, 0xb8, 0x18, 0xb9, 0x94, 0xc8, 0x83, 0xce, 0xa0, 0x70, 0xe9,
	0xd2, 0xa1, 0xa3, 0x05, 0xdd, 0xd0, 0x2c, 0xd3, 0x2b, 0x65, 0xab, 0xfc, 0xc1, 0x66, 0xe3, 0xa3,
	0xc5, 0x1d, 0xdd, 0x09, 0x8b, 0x27, 0xd3, 0x44, 0xbc, 0xc9, 0x1c, 0x81, 0x62, 0x8a, 0xe9, 0x89,
	0x7f, 0xf0, 0x80, 0x9e, 0x4c, 0x1d, 0xff, 0x99, 0x84, 0x0d, 0x00, 0x93, 0x5c, 0x58, 0xb6, 0x15,
	0x53, 0x50, 0x5c, 0xac, 0xe0, 0x14, 0x89, 0x63, 0x59, 0xa8, 0x09, 0x79, 0xcb, 0x76, 0x86, 0x3e,
	0xbb, 0x5a, 0xa8, 0xdd, 0x3d, 0x8b, 0xb0, 0xb4, 0xe0, 0xbe, 0x1e, 0x3a, 0xfd, 0x07, 0x0a, 0xbe,
	0x2e, 0x92, 0x0a, 0x45, 0x83, 0xda, 0x26, 0xfb, 0x99, 0x88, 0x56, 0x96, 0xd1, 0x7a, 0x77, 0x51,
	0xb1, 0xe6, 0x14, 0x1e, 0xd0, 0xc1, 0x05, 0x23, 0x6e, 0x7a, 0xe8, 0x39, 0x6c, 0x19, 0xd4, 0xf6,
	0x2c, 0x93, 0xb8, 0x7a, 0xac, 0xe6, 0x1a, 0xab, 0xf9, 0xc1, 0x1b, 0x6a, 0xce, 0x52, 0x58, 0x5d,
	0x64, 0xa4, 0x5d, 0x9e, 0xb8, 0x03, 0x5b, 0x98, 0x18, 0xd4, 0x35, 0x13, 0xc2, 0x8b, 0xdf, 0xf3,
	0xb0, 0xd9, 0xa4, 0xb6, 0xef, 0xea, 0x06, 0x6b, 0x51, 0x4a, 0x2a, 0x6e, 0x19, 0x52, 0xad, 0x2e,
	0x4d, 0x2a, 0x7e, 0x99, 0x52, 0x65, 0xfe, 0x05, 0xa9, 0xb2, 0xcb, 0x90, 0xea, 0x07, 0x0e, 0xf2,
	0xb1, 0x35, 0x86, 0x10, 0x64, 0x6c, 0x7d, 0x40, 0x98, 0x18, 0x39, 0xcc, 0xce, 0xa8, 0x9a, 0x5c,
	0x8a, 0x3c, 0x0b, 0x25, 0xf6, 0xdd, 0xa7, 0x90, 0x7f, 0x41, 0xce, 0x3d, 0xcb, 0x27, 0xda, 0xd0,
	0xed, 0x97, 0x32, 0x01, 0xa2, 0xb1, 0x7b, 0x3b, 0xa9, 0xa0, 0xf0, 0xd9, 0xc6, 0x82, 0x22, 0x86,
	0xc8, 0xea, 0xb9, 0x7d, 0x54, 0x83, 0x0d, 0xcb, 0xa0, 0x36, 0xcb, 0xca, 0xb2, 0xac, 0xad, 0xdb,
	0x49, 0xa5, 0x18, 0x66, 0x4d, 0x23, 0x22, 0x5e, 0x0f, 0x8e, 0x3d, 0xb7, 0x2f, 0xfe, 0xc6, 0x01,
	0xcc, 0x34, 0x9c, 0xcb, 0x56, 0x85, 0x07, 0x2e, 0xf1, 0xe8, 0xd0, 0x35, 0x88, 0xd6, 0xa7, 0xe1,
	0xe8, 0x45, 0x6b, 0x60, 0xa1, 0x98, 0x98, 0x5c, 0x10, 0x97, 0xd8, 0x06, 0xc1, 0xc2, 0x34, 0xf7,
	0x34, 0x4a, 0x45, 0xef, 0x43, 0xd1, 0x70, 0x89, 0xee, 0xd3, 0xbb, 0x65, 0x1d, 0x75, 0xa0, 0x10,
	0xb9, 0xa3, 0x25, 0x85, 0x5a, 0x50, 0x9c, 0xcd, 0xa5, 0xe6, 0x8f, 0x1d, 0xc2, 0x1a, 0x51, 0x38,
	0x7a, 0xef, 0xaf, 0xa7, 0x91, 0x0d, 0x52, 0xc1, 0x4c, 0xd8, 0xe2, 0x37, 0x1c, 0xe4, 0xee, 0x98,
	0xa1, 0x3d, 0xd8, 0xf0, 0x82, 0xff, 0xc3, 0xe9, 0xba, 0xcc, 0xe1, 0x75, 0x66, 0x2b, 0x66, 0x10,
	0x0a, 0x37, 0xb1, 0x65, 0x46, 0xdc, 0xd6, 0x99, 0xad, 0x98, 0x41, 0x87, 0xae, 0x74, 0xef, 0x2a,
	0x94, 0x04, 0xb3, 0xf3, 0x5d, 0xd7, 0xb2, 0xb1, 0xae, 0xed, 0x43, 0x2e, 0x60, 0xac, 0xb1, 0xc0,
	0x1a, 0x0b, 0x6c, 0x04, 0x0e, 0x55, 0x1f, 0x10, 0xf1, 0x47, 0x0e, 0xfe, 0x97, 0x18, 0xd1, 0xb9,
	0x8d, 0x5f, 0xca, 0x4b, 0x6c, 0x42, 0x9e, 0x0e, 0xfd, 0x69, 0x15, 0x76, 0x9b, 0x7b, 0x16, 0x09,
	0xd3, 0x82, 0x2a, 0xe2, 0xd7, 0xab, 0xf0, 0xe0, 0xb5, 0xf1, 0x7f, 0xc3, 0xb0, 0x38, 0x01, 0xf6,
	0xbc, 0x4f, 0xb4, 0xe0, 0x25, 0x8f, 0xd9, 0xb0, 0xdc, 0xeb, 0xe5, 0x0b, 0xb1, 0x5c, 0xe6, 0x5d,
	0xce, 0x1f, 0x47, 0xaa, 0x07, 0x99, 0xbf, 0xd3, 0x83, 0xc3, 0x6f, 0x39, 0x28, 0x24, 0xe7, 0x0b,
	0x55, 0x60, 0xff, 0x58, 0x3e, 0x51, 0x54, 0xa5, 0xab, 0xb4, 0x54, 0xad, 0xfb, 0xac, 0x2d, 0x6b,
	0x3d, 0xb5, 0xd3, 0x96, 0x9b, 0xca, 0x89, 0x22, 0x1f, 0x0b, 0x2b, 0xe8, 0xff, 0x50, 0x4a, 0x03,
	0xda, 0xb8, 0xd5, 0x6e, 0x75, 0xe4, 0x63, 0x81, 0x43, 0x25, 0xd8, 0x4e, 0x47, 0x4f, 0xa4, 0x66,
	0x57, 0x58, 0x45, 0x6f, 0xc1, 0xde, 0xbc, 0x88, 0x76, 0xaa, 0x74, 0xba, 0x02, 0x7f, 0xf8, 0x3b,
	0x07, 0xb9, 0xbb, 0xa6, 0xa1, 0x47, 0xb0, 0xdb, 0x96, 0x70, 0xf7, 0xd9, 0x3c, 0x02, 0x7b, 0xb0,
	0x13, 0x8b, 0xb5, 0xb0, 0xf2, 0x44, 0x51, 0xa5, 0x6e, 0x0b, 0x0b, 0x1c, 0x7a, 0x08, 0x5b, 0xb1,
	0x50, 0x47, 0xc6, 0x67, 0x4a, 0x53, 0xc6, 0xc2, 0x6a, 0x2a, 0xa0, 0xa8, 0x67, 0x72, 0x27, 0xc8,
	0xe0, 0x03, 0xbe, 0xb1, 0x40, 0xb3, 0xd7, 0xe9, 0xb6, 0x8e, 0x15, 0x49, 0x15, 0x32, 0x68, 0x1b,
	0x84, 0xf8, 0xcf, 0x7c, 0xae, 0xca, 0x58, 0xc8, 0xa6, 0xf0, 0xd2, 0xc9, 0x89, 0x72, 0xaa, 0x48,
	0x5d, 0x59, 0x58, 0x43, 0xbb, 0x80, 0xe2, 0xf8, 0xa7, 0xaa, 0xd2, 0xe8, 0x75, 0x84, 0xf5, 0x14,
	0xdd, 0x36, 0x6e, 0x9d, 0xc9, 0xaa, 0xa4, 0x36, 0x65, 0x61, 0xa3, 0xf1, 0xe5, 0xcb, 0xeb, 0x32,
	0xf7, 0xea, 0xba, 0xcc, 0xfd, 0x7a, 0x5d, 0xe6, 0xbe, 0xbb, 0x29, 0xaf, 0xbc, 0xba, 0x29, 0xaf,
	0xfc, 0x7c, 0x53, 0x5e, 0x81, 0x3d, 0x8b, 0x2e, 0x90, 0xb2, 0xcd, 0x3d, 0xff, 0xe4, 0xd2, 0xf2,
	0xaf, 0x86, 0xe7, 0x35, 0x83, 0x0e, 0xea, 0x33, 0xd0, 0x87, 0x16, 0x8d, 0x59, 0xf5, 0xaf, 0x66,
	0x9f, 0xda, 0xc1, 0x13, 0xf5, 0xce, 0xd7, 0xd8, 0x27, 0xf3, 0xc7, 0x7f, 0x06, 0x00, 0x00, 0xff,
	0xff, 0xc2, 0x37, 0xe0, 0x2a, 0x8e, 0x0b, 0x00, 0x00,
}

func (m *ScopeSpecification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeSpecification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeSpecification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupSpecIds) > 0 {
		for iNdEx := len(m.GroupSpecIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.GroupSpecIds[iNdEx].Size()
				i -= size
				if _, err := m.GroupSpecIds[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PartiesInvolved) > 0 {
		dAtA2 := make([]byte, len(m.PartiesInvolved)*10)
		var j1 int
		for _, num := range m.PartiesInvolved {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintSpecification(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OwnerAddresses) > 0 {
		for iNdEx := len(m.OwnerAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OwnerAddresses[iNdEx])
			copy(dAtA[i:], m.OwnerAddresses[iNdEx])
			i = encodeVarintSpecification(dAtA, i, uint64(len(m.OwnerAddresses[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.SpecificationId.Size()
		i -= size
		if _, err := m.SpecificationId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSpecification(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GroupSpecification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupSpecification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupSpecification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsiderationSpecs) > 0 {
		for iNdEx := len(m.ConsiderationSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsiderationSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ConditionSpecs) > 0 {
		for iNdEx := len(m.ConditionSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConditionSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PartiesInvolved) > 0 {
		dAtA5 := make([]byte, len(m.PartiesInvolved)*10)
		var j4 int
		for _, num := range m.PartiesInvolved {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintSpecification(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.SpecificationId.Size()
		i -= size
		if _, err := m.SpecificationId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSpecification(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecordSpecification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordSpecification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordSpecification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ContractSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsiderationSpecs) > 0 {
		for iNdEx := len(m.ConsiderationSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsiderationSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ConditionSpecs) > 0 {
		for iNdEx := len(m.ConditionSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConditionSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PartiesInvolved) > 0 {
		dAtA8 := make([]byte, len(m.PartiesInvolved)*10)
		var j7 int
		for _, num := range m.PartiesInvolved {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintSpecification(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Description) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Description) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Description) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IconUrl) > 0 {
		i -= len(m.IconUrl)
		copy(dAtA[i:], m.IconUrl)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.IconUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.WebsiteUrl) > 0 {
		i -= len(m.WebsiteUrl)
		copy(dAtA[i:], m.WebsiteUrl)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.WebsiteUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Definition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Definition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Definition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefinitionType != 0 {
		i = encodeVarintSpecification(dAtA, i, uint64(m.DefinitionType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CreatorAddress) > 0 {
		i -= len(m.CreatorAddress)
		copy(dAtA[i:], m.CreatorAddress)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.CreatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ResourceLocation != nil {
		{
			size, err := m.ResourceLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSpec != nil {
		{
			size, err := m.OutputSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsiderationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsiderationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsiderationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSpec != nil {
		{
			size, err := m.OutputSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpecification(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ResponsibleParty != 0 {
		i = encodeVarintSpecification(dAtA, i, uint64(m.ResponsibleParty))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpecification(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpecification(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpecification(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ScopeSpecification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SpecificationId.Size()
	n += 1 + l + sovSpecification(uint64(l))
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovSpecification(uint64(l))
	}
	if len(m.OwnerAddresses) > 0 {
		for _, s := range m.OwnerAddresses {
			l = len(s)
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if len(m.PartiesInvolved) > 0 {
		l = 0
		for _, e := range m.PartiesInvolved {
			l += sovSpecification(uint64(e))
		}
		n += 1 + sovSpecification(uint64(l)) + l
	}
	if len(m.GroupSpecIds) > 0 {
		for _, e := range m.GroupSpecIds {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	return n
}

func (m *GroupSpecification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SpecificationId.Size()
	n += 1 + l + sovSpecification(uint64(l))
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovSpecification(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if len(m.PartiesInvolved) > 0 {
		l = 0
		for _, e := range m.PartiesInvolved {
			l += sovSpecification(uint64(e))
		}
		n += 1 + sovSpecification(uint64(l)) + l
	}
	if len(m.ConditionSpecs) > 0 {
		for _, e := range m.ConditionSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if len(m.ConsiderationSpecs) > 0 {
		for _, e := range m.ConsiderationSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	return n
}

func (m *RecordSpecification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ContractSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovSpecification(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if len(m.PartiesInvolved) > 0 {
		l = 0
		for _, e := range m.PartiesInvolved {
			l += sovSpecification(uint64(e))
		}
		n += 1 + sovSpecification(uint64(l)) + l
	}
	if len(m.ConditionSpecs) > 0 {
		for _, e := range m.ConditionSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if len(m.ConsiderationSpecs) > 0 {
		for _, e := range m.ConsiderationSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	return n
}

func (m *Description) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.WebsiteUrl)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.IconUrl)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	return n
}

func (m *Definition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	if m.ResourceLocation != nil {
		l = m.ResourceLocation.Size()
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.CreatorAddress)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	if m.DefinitionType != 0 {
		n += 1 + sovSpecification(uint64(m.DefinitionType))
	}
	return n
}

func (m *Reference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	return n
}

func (m *ConditionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if m.OutputSpec != nil {
		l = m.OutputSpec.Size()
		n += 1 + l + sovSpecification(uint64(l))
	}
	return n
}

func (m *ConsiderationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpecification(uint64(l))
	}
	if m.ResponsibleParty != 0 {
		n += 1 + sovSpecification(uint64(m.ResponsibleParty))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovSpecification(uint64(l))
		}
	}
	if m.OutputSpec != nil {
		l = m.OutputSpec.Size()
		n += 1 + l + sovSpecification(uint64(l))
	}
	return n
}

func sovSpecification(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpecification(x uint64) (n int) {
	return sovSpecification(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ScopeSpecification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeSpecification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeSpecification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpecificationId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &Description{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAddresses = append(m.OwnerAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v PartyType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecification
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PartyType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartiesInvolved = append(m.PartiesInvolved, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecification
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpecification
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSpecification
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PartiesInvolved) == 0 {
					m.PartiesInvolved = make([]PartyType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PartyType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecification
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PartyType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartiesInvolved = append(m.PartiesInvolved, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiesInvolved", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSpecIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v MetadataAddress
			m.GroupSpecIds = append(m.GroupSpecIds, v)
			if err := m.GroupSpecIds[len(m.GroupSpecIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupSpecification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupSpecification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupSpecification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpecificationId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &Definition{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &Definition{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v PartyType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecification
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PartyType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartiesInvolved = append(m.PartiesInvolved, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecification
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpecification
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSpecification
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PartiesInvolved) == 0 {
					m.PartiesInvolved = make([]PartyType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PartyType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecification
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PartyType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartiesInvolved = append(m.PartiesInvolved, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiesInvolved", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionSpecs = append(m.ConditionSpecs, &ConditionSpec{})
			if err := m.ConditionSpecs[len(m.ConditionSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationSpecs = append(m.ConsiderationSpecs, &ConsiderationSpec{})
			if err := m.ConsiderationSpecs[len(m.ConsiderationSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordSpecification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordSpecification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordSpecification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &Definition{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &Definition{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v PartyType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecification
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PartyType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartiesInvolved = append(m.PartiesInvolved, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecification
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpecification
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSpecification
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PartiesInvolved) == 0 {
					m.PartiesInvolved = make([]PartyType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PartyType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecification
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PartyType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartiesInvolved = append(m.PartiesInvolved, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiesInvolved", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionSpecs = append(m.ConditionSpecs, &ConditionSpec{})
			if err := m.ConditionSpecs[len(m.ConditionSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationSpecs = append(m.ConsiderationSpecs, &ConsiderationSpec{})
			if err := m.ConsiderationSpecs[len(m.ConsiderationSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Description) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Description: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Description: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebsiteUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebsiteUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Definition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Definition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Definition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLocation == nil {
				m.ResourceLocation = &Reference{}
			}
			if err := m.ResourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionType", wireType)
			}
			m.DefinitionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefinitionType |= DefinitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &Definition{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSpec == nil {
				m.OutputSpec = &Definition{}
			}
			if err := m.OutputSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsiderationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsiderationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsiderationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsibleParty", wireType)
			}
			m.ResponsibleParty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponsibleParty |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &Definition{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSpec == nil {
				m.OutputSpec = &Definition{}
			}
			if err := m.OutputSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpecification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpecification(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpecification
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpecification
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpecification
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpecification
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpecification
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpecification        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpecification          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpecification = fmt.Errorf("proto: unexpected end of group")
)
