// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/scope.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/descriptorpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A set of types for inputs on a record (of fact)
type RecordInputStatus int32

const (
	// RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type
	RecordInputStatus_Unknown RecordInputStatus = 0
	// RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed
	RecordInputStatus_Proposed RecordInputStatus = 1
	// RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain
	RecordInputStatus_Record RecordInputStatus = 2
)

var RecordInputStatus_name = map[int32]string{
	0: "RECORD_INPUT_STATUS_UNSPECIFIED",
	1: "RECORD_INPUT_STATUS_PROPOSED",
	2: "RECORD_INPUT_STATUS_RECORD",
}

var RecordInputStatus_value = map[string]int32{
	"RECORD_INPUT_STATUS_UNSPECIFIED": 0,
	"RECORD_INPUT_STATUS_PROPOSED":    1,
	"RECORD_INPUT_STATUS_RECORD":      2,
}

func (x RecordInputStatus) String() string {
	return proto.EnumName(RecordInputStatus_name, int32(x))
}

func (RecordInputStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{0}
}

// ResultStatus indicates the various states of execution of a record
type ResultStatus int32

const (
	// RESULT_STATUS_UNSPECIFIED indicates an unset condition
	ResultStatus_RESULT_STATUS_UNSPECIFIED ResultStatus = 0
	// RESULT_STATUS_PASS indicates the execution was successful
	ResultStatus_RESULT_STATUS_PASS ResultStatus = 1
	// RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution
	ResultStatus_RESULT_STATUS_SKIP ResultStatus = 2
	// RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed.
	ResultStatus_RESULT_STATUS_FAIL ResultStatus = 3
)

var ResultStatus_name = map[int32]string{
	0: "RESULT_STATUS_UNSPECIFIED",
	1: "RESULT_STATUS_PASS",
	2: "RESULT_STATUS_SKIP",
	3: "RESULT_STATUS_FAIL",
}

var ResultStatus_value = map[string]int32{
	"RESULT_STATUS_UNSPECIFIED": 0,
	"RESULT_STATUS_PASS":        1,
	"RESULT_STATUS_SKIP":        2,
	"RESULT_STATUS_FAIL":        3,
}

func (x ResultStatus) String() string {
	return proto.EnumName(ResultStatus_name, int32(x))
}

func (ResultStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{1}
}

// Scope defines a root reference for a collection of records owned by one or more parties.
type Scope struct {
	// Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos
	ScopeId MetadataAddress `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3,customtype=MetadataAddress" json:"scope_id" yaml:"scope_id"`
	// the scope specification that contains the specifications for data elements allowed within this scope
	SpecificationId MetadataAddress `protobuf:"bytes,2,opt,name=specification_id,json=specificationId,proto3,customtype=MetadataAddress" json:"specification_id" yaml:"specification_id"`
	// These parties represent top level owners of the records within.  These parties must sign any requests that modify
	// the data within the scope.  These addresses are in union with parties listed on the sessions.
	Owners []Party `protobuf:"bytes,3,rep,name=owners,proto3" json:"owners"`
	// Addresses in this list are authorized to receive off-chain data associated with this scope.
	DataAccess []string `protobuf:"bytes,4,rep,name=data_access,json=dataAccess,proto3" json:"data_access,omitempty" yaml:"data_access"`
	// An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts
	// are supported for this value.  This attribute may only be changed by the entity indicated once it is set.
	ValueOwnerAddress string `protobuf:"bytes,5,opt,name=value_owner_address,json=valueOwnerAddress,proto3" json:"value_owner_address,omitempty" yaml:"value_owner_address"`
	// Whether all parties in this scope and its sessions must be present in this scope's owners field.
	// This also enables use of optional=true scope owners and session parties.
	//
	// If true:
	//
	// In order to write or delete this scope:
	//   - All roles required by the scope spec must have a party in the owners.
	//   - If not new, all required=false existing owners must be signers.
	//   - If not new, all roles required by the scope spec must have a signer and
	//     associated party from the existing scope.
	//   - Value owner signer restrictions are applied.
	//
	// In order to write sessions in this scope:
	//   - All proposed session parties must be present in this scope's owners.
	//   - All optional=false scope owners must be signers.
	//   - If new, all roles required by the contract spec must have a signer and
	//     associated party in the proposed session.
	//   - If not new, all roles required by the contract spec must have a signer
	//     and associated party in the existing session.
	//   - If not new, all optional=false existing parties must also be signers.
	//
	// In order to write records in this scope:
	//   - All roles required by the record spec must have a signer and associated party in the session.
	//   - All optional=false scope owners and session parties must be signers.
	//   - If the record is changing sessions, all optional=false previous session parties must be signers.
	//
	// In order to delete a record from this scope:
	//   - All roles required by the record spec must have a signer and associated party in the scope.
	//   - All optional=false scope owners must be signers.
	//
	// If false:
	//
	// In order to write or delete this scope:
	//   - All roles required by the scope spec must have a party in the owners.
	//   - If not new, all existing owners must sign.
	//   - Value owner signer restrictions are applied.
	//
	// In order to write sessions in this scope:
	//   - All roles required by the contract spec must have a party in the session parties.
	//   - All scope owners must sign.
	//
	// In order to write records in this scope:
	//   - All roles required by the record spec must have a party in the session parties.
	//   - All session parties must sign.
	//   - If the record is changing to a new session, all previous session parties must sign.
	//
	// In order to delete a record from this scope:
	//   - All scope owners must sign.
	RequirePartyRollup bool `protobuf:"varint,6,opt,name=require_party_rollup,json=requirePartyRollup,proto3" json:"require_party_rollup,omitempty" yaml:"require_party_rollup"`
}

func (m *Scope) Reset()      { *m = Scope{} }
func (*Scope) ProtoMessage() {}
func (*Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{0}
}
func (m *Scope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Scope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Scope.Merge(m, src)
}
func (m *Scope) XXX_Size() int {
	return m.Size()
}
func (m *Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_Scope.DiscardUnknown(m)
}

var xxx_messageInfo_Scope proto.InternalMessageInfo

func (m *Scope) GetOwners() []Party {
	if m != nil {
		return m.Owners
	}
	return nil
}

func (m *Scope) GetDataAccess() []string {
	if m != nil {
		return m.DataAccess
	}
	return nil
}

func (m *Scope) GetValueOwnerAddress() string {
	if m != nil {
		return m.ValueOwnerAddress
	}
	return ""
}

func (m *Scope) GetRequirePartyRollup() bool {
	if m != nil {
		return m.RequirePartyRollup
	}
	return false
}

//
//A Session is created for an execution context against a specific specification instance
//
//The context will have a specification and set of parties involved.  The Session may be updated several
//times so long as the parties listed are signers on the transaction.  NOTE: When there are no Records within a Scope
//that reference a Session it is removed.
type Session struct {
	SessionId MetadataAddress `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,customtype=MetadataAddress" json:"session_id" yaml:"session_id"`
	// unique id of the contract specification that was used to create this session.
	SpecificationId MetadataAddress `protobuf:"bytes,2,opt,name=specification_id,json=specificationId,proto3,customtype=MetadataAddress" json:"specification_id" yaml:"specification_id"`
	// parties is the set of identities that signed this contract
	Parties []Party `protobuf:"bytes,3,rep,name=parties,proto3" json:"parties"`
	// name to associate with this session execution context, typically classname
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"type" yaml:"type"`
	// context is a field for storing client specific data associated with a session.
	Context []byte `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	// Created by, updated by, timestamps, version number, and related info.
	Audit *AuditFields `protobuf:"bytes,99,opt,name=audit,proto3" json:"audit,omitempty" yaml:"audit,omitempty"`
}

func (m *Session) Reset()      { *m = Session{} }
func (*Session) ProtoMessage() {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{1}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetParties() []Party {
	if m != nil {
		return m.Parties
	}
	return nil
}

func (m *Session) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Session) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Session) GetAudit() *AuditFields {
	if m != nil {
		return m.Audit
	}
	return nil
}

// A record (of fact) is attached to a session or each consideration output from a contract
type Record struct {
	// name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"id" yaml:"id"`
	// id of the session context that was used to create this record (use with filtered kvprefix iterator)
	SessionId MetadataAddress `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3,customtype=MetadataAddress" json:"session_id" yaml:"session_id"`
	// process contain information used to uniquely identify an execution on or off chain that generated this record
	Process Process `protobuf:"bytes,3,opt,name=process,proto3" json:"process"`
	// inputs used with the process to achieve the output on this record
	Inputs []RecordInput `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs"`
	// output(s) is the results of executing the process on the given process indicated in this record
	Outputs []RecordOutput `protobuf:"bytes,5,rep,name=outputs,proto3" json:"outputs"`
	// specification_id is the id of the record specification that was used to create this record.
	SpecificationId MetadataAddress `protobuf:"bytes,6,opt,name=specification_id,json=specificationId,proto3,customtype=MetadataAddress" json:"specification_id" yaml:"specification_id"`
}

func (m *Record) Reset()      { *m = Record{} }
func (*Record) ProtoMessage() {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{2}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Record) GetProcess() Process {
	if m != nil {
		return m.Process
	}
	return Process{}
}

func (m *Record) GetInputs() []RecordInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Record) GetOutputs() []RecordOutput {
	if m != nil {
		return m.Outputs
	}
	return nil
}

// Process contains information used to uniquely identify what was used to generate this record
type Process struct {
	// unique identifier for this process
	//
	// Types that are valid to be assigned to ProcessId:
	//	*Process_Address
	//	*Process_Hash
	ProcessId isProcess_ProcessId `protobuf_oneof:"process_id"`
	// a name associated with the process (type_name, classname or smart contract common name)
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// method is a name or reference to a specific operation (method) within a class/contract that was invoked
	Method string `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
}

func (m *Process) Reset()      { *m = Process{} }
func (*Process) ProtoMessage() {}
func (*Process) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{3}
}
func (m *Process) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Process) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Process.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Process) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Process.Merge(m, src)
}
func (m *Process) XXX_Size() int {
	return m.Size()
}
func (m *Process) XXX_DiscardUnknown() {
	xxx_messageInfo_Process.DiscardUnknown(m)
}

var xxx_messageInfo_Process proto.InternalMessageInfo

type isProcess_ProcessId interface {
	isProcess_ProcessId()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Process_Address struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3,oneof" json:"address,omitempty"`
}
type Process_Hash struct {
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3,oneof" json:"hash,omitempty"`
}

func (*Process_Address) isProcess_ProcessId() {}
func (*Process_Hash) isProcess_ProcessId()    {}

func (m *Process) GetProcessId() isProcess_ProcessId {
	if m != nil {
		return m.ProcessId
	}
	return nil
}

func (m *Process) GetAddress() string {
	if x, ok := m.GetProcessId().(*Process_Address); ok {
		return x.Address
	}
	return ""
}

func (m *Process) GetHash() string {
	if x, ok := m.GetProcessId().(*Process_Hash); ok {
		return x.Hash
	}
	return ""
}

func (m *Process) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Process) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Process) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Process_Address)(nil),
		(*Process_Hash)(nil),
	}
}

// Tracks the inputs used to establish this record
type RecordInput struct {
	// Name value included to link back to the definition spec.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// data source
	//
	// Types that are valid to be assigned to Source:
	//	*RecordInput_RecordId
	//	*RecordInput_Hash
	Source isRecordInput_Source `protobuf_oneof:"source"`
	// from proposed fact structure to unmarshal
	TypeName string `protobuf:"bytes,4,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty" yaml:"type_name"`
	// Indicates if this input was a recorded fact on chain or just a given hashed input
	Status RecordInputStatus `protobuf:"varint,5,opt,name=status,proto3,enum=provenance.metadata.v1.RecordInputStatus" json:"status,omitempty"`
}

func (m *RecordInput) Reset()      { *m = RecordInput{} }
func (*RecordInput) ProtoMessage() {}
func (*RecordInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{4}
}
func (m *RecordInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordInput.Merge(m, src)
}
func (m *RecordInput) XXX_Size() int {
	return m.Size()
}
func (m *RecordInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordInput.DiscardUnknown(m)
}

var xxx_messageInfo_RecordInput proto.InternalMessageInfo

type isRecordInput_Source interface {
	isRecordInput_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RecordInput_RecordId struct {
	RecordId MetadataAddress `protobuf:"bytes,2,opt,name=record_id,json=recordId,proto3,oneof,customtype=MetadataAddress" json:"record_id,omitempty" yaml:"record_id"`
}
type RecordInput_Hash struct {
	Hash string `protobuf:"bytes,3,opt,name=hash,proto3,oneof" json:"hash,omitempty"`
}

func (*RecordInput_RecordId) isRecordInput_Source() {}
func (*RecordInput_Hash) isRecordInput_Source()     {}

func (m *RecordInput) GetSource() isRecordInput_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *RecordInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecordInput) GetHash() string {
	if x, ok := m.GetSource().(*RecordInput_Hash); ok {
		return x.Hash
	}
	return ""
}

func (m *RecordInput) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *RecordInput) GetStatus() RecordInputStatus {
	if m != nil {
		return m.Status
	}
	return RecordInputStatus_Unknown
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RecordInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RecordInput_RecordId)(nil),
		(*RecordInput_Hash)(nil),
	}
}

// RecordOutput encapsulates the output of a process recorded on chain
type RecordOutput struct {
	// Hash of the data output that was output/generated for this record
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// Status of the process execution associated with this output indicating success,failure, or pending
	Status ResultStatus `protobuf:"varint,2,opt,name=status,proto3,enum=provenance.metadata.v1.ResultStatus" json:"status,omitempty"`
}

func (m *RecordOutput) Reset()      { *m = RecordOutput{} }
func (*RecordOutput) ProtoMessage() {}
func (*RecordOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{5}
}
func (m *RecordOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordOutput.Merge(m, src)
}
func (m *RecordOutput) XXX_Size() int {
	return m.Size()
}
func (m *RecordOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordOutput.DiscardUnknown(m)
}

var xxx_messageInfo_RecordOutput proto.InternalMessageInfo

func (m *RecordOutput) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *RecordOutput) GetStatus() ResultStatus {
	if m != nil {
		return m.Status
	}
	return ResultStatus_RESULT_STATUS_UNSPECIFIED
}

// A Party is an address with/in a given role associated with a contract
type Party struct {
	// address of the account (on chain)
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// a role for this account within the context of the processes used
	Role PartyType `protobuf:"varint,2,opt,name=role,proto3,enum=provenance.metadata.v1.PartyType" json:"role,omitempty"`
	// whether this party's signature is optional
	Optional bool `protobuf:"varint,3,opt,name=optional,proto3" json:"optional,omitempty"`
}

func (m *Party) Reset()      { *m = Party{} }
func (*Party) ProtoMessage() {}
func (*Party) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{6}
}
func (m *Party) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Party) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Party.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Party) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Party.Merge(m, src)
}
func (m *Party) XXX_Size() int {
	return m.Size()
}
func (m *Party) XXX_DiscardUnknown() {
	xxx_messageInfo_Party.DiscardUnknown(m)
}

var xxx_messageInfo_Party proto.InternalMessageInfo

func (m *Party) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Party) GetRole() PartyType {
	if m != nil {
		return m.Role
	}
	return PartyType_PARTY_TYPE_UNSPECIFIED
}

func (m *Party) GetOptional() bool {
	if m != nil {
		return m.Optional
	}
	return false
}

// AuditFields capture information about the last account to make modifications and when they were made
type AuditFields struct {
	// the date/time when this entry was created
	CreatedDate time.Time `protobuf:"bytes,1,opt,name=created_date,json=createdDate,proto3,stdtime" json:"created_date,omitempty" yaml:"created_date,omitempty"`
	// the address of the account that created this record
	CreatedBy string `protobuf:"bytes,2,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty" yaml:"created_by,omitempty"`
	// the date/time when this entry was last updated
	UpdatedDate time.Time `protobuf:"bytes,3,opt,name=updated_date,json=updatedDate,proto3,stdtime" json:"updated_date,omitempty" yaml:"updated_date,omitempty"`
	// the address of the account that modified this record
	UpdatedBy string `protobuf:"bytes,4,opt,name=updated_by,json=updatedBy,proto3" json:"updated_by,omitempty" yaml:"updated_by,omitempty"`
	// an optional version number that is incremented with each update
	Version uint32 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty" yaml:"version,omitempty"`
	// an optional message associated with the creation/update event
	Message string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty" yaml:"message,omitempty"`
}

func (m *AuditFields) Reset()         { *m = AuditFields{} }
func (m *AuditFields) String() string { return proto.CompactTextString(m) }
func (*AuditFields) ProtoMessage()    {}
func (*AuditFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_edeea634bfb18aba, []int{7}
}
func (m *AuditFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditFields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditFields.Merge(m, src)
}
func (m *AuditFields) XXX_Size() int {
	return m.Size()
}
func (m *AuditFields) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditFields.DiscardUnknown(m)
}

var xxx_messageInfo_AuditFields proto.InternalMessageInfo

func (m *AuditFields) GetCreatedDate() time.Time {
	if m != nil {
		return m.CreatedDate
	}
	return time.Time{}
}

func (m *AuditFields) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *AuditFields) GetUpdatedDate() time.Time {
	if m != nil {
		return m.UpdatedDate
	}
	return time.Time{}
}

func (m *AuditFields) GetUpdatedBy() string {
	if m != nil {
		return m.UpdatedBy
	}
	return ""
}

func (m *AuditFields) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *AuditFields) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("provenance.metadata.v1.RecordInputStatus", RecordInputStatus_name, RecordInputStatus_value)
	proto.RegisterEnum("provenance.metadata.v1.ResultStatus", ResultStatus_name, ResultStatus_value)
	proto.RegisterType((*Scope)(nil), "provenance.metadata.v1.Scope")
	proto.RegisterType((*Session)(nil), "provenance.metadata.v1.Session")
	proto.RegisterType((*Record)(nil), "provenance.metadata.v1.Record")
	proto.RegisterType((*Process)(nil), "provenance.metadata.v1.Process")
	proto.RegisterType((*RecordInput)(nil), "provenance.metadata.v1.RecordInput")
	proto.RegisterType((*RecordOutput)(nil), "provenance.metadata.v1.RecordOutput")
	proto.RegisterType((*Party)(nil), "provenance.metadata.v1.Party")
	proto.RegisterType((*AuditFields)(nil), "provenance.metadata.v1.AuditFields")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/scope.proto", fileDescriptor_edeea634bfb18aba)
}

var fileDescriptor_edeea634bfb18aba = []byte{
	// 1230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4b, 0x6f, 0xdb, 0xc6,
	0x13, 0x17, 0x25, 0x59, 0x8f, 0x91, 0xff, 0xff, 0x28, 0x1b, 0xc3, 0x51, 0xd4, 0x44, 0x54, 0xd9,
	0x02, 0x71, 0xdd, 0x54, 0x6a, 0xdc, 0x17, 0x90, 0xbe, 0x20, 0xc6, 0x36, 0x22, 0x24, 0xb5, 0xd5,
	0x95, 0x7d, 0x29, 0x50, 0x08, 0x34, 0xb9, 0x91, 0x89, 0x48, 0x5a, 0x96, 0x0f, 0x27, 0x6a, 0x6f,
	0x05, 0x8a, 0x02, 0x39, 0xe5, 0x98, 0x4b, 0x80, 0xf6, 0x03, 0xf4, 0x7b, 0xe4, 0xd0, 0x43, 0x8e,
	0x45, 0x0f, 0x6c, 0x91, 0xdc, 0x72, 0xd4, 0x27, 0x28, 0xf6, 0x41, 0x91, 0x4a, 0x28, 0x23, 0x45,
	0xdb, 0x1b, 0x67, 0xe6, 0x37, 0xb3, 0x33, 0xf3, 0x9b, 0x9d, 0x25, 0x68, 0x8e, 0x4b, 0x4f, 0xc8,
	0xc4, 0x98, 0x98, 0xa4, 0x3d, 0x26, 0xbe, 0x61, 0x19, 0xbe, 0xd1, 0x3e, 0xb9, 0xda, 0xf6, 0x4c,
	0xea, 0x90, 0x96, 0xe3, 0x52, 0x9f, 0xa2, 0xf5, 0x18, 0xd3, 0x8a, 0x30, 0xad, 0x93, 0xab, 0xf5,
	0xb5, 0x21, 0x1d, 0x52, 0x0e, 0x69, 0xb3, 0x2f, 0x81, 0xae, 0xab, 0x43, 0x4a, 0x87, 0x23, 0xd2,
	0xe6, 0xd2, 0x51, 0x70, 0xbb, 0xed, 0xdb, 0x63, 0xe2, 0xf9, 0xc6, 0xd8, 0x91, 0x80, 0xe6, 0x8b,
	0x00, 0x8b, 0x78, 0xa6, 0x6b, 0x3b, 0x3e, 0x75, 0x25, 0x62, 0x73, 0x59, 0x52, 0x0e, 0x31, 0xed,
	0xdb, 0xb6, 0x69, 0xf8, 0x36, 0x9d, 0x08, 0xac, 0xf6, 0x6b, 0x0e, 0x56, 0xfa, 0x2c, 0x59, 0xb4,
	0x03, 0x25, 0x9e, 0xf5, 0xc0, 0xb6, 0x6a, 0x4a, 0x53, 0xd9, 0x58, 0xd5, 0x37, 0x1f, 0x87, 0x6a,
	0xe6, 0xf7, 0x50, 0x3d, 0xf3, 0x85, 0x0c, 0xd2, 0xb1, 0x2c, 0x97, 0x78, 0xde, 0x2c, 0x54, 0xcf,
	0x4c, 0x8d, 0xf1, 0xe8, 0x9a, 0x16, 0x39, 0x68, 0xb8, 0xc8, 0x3f, 0xbb, 0x16, 0xfa, 0x1a, 0xaa,
	0x0b, 0xe7, 0xb0, 0x70, 0x59, 0x1e, 0x6e, 0x6b, 0x79, 0xb8, 0xf3, 0x32, 0xdc, 0x0b, 0x8e, 0x1a,
	0x3e, 0xb3, 0xa0, 0xea, 0x5a, 0xe8, 0x63, 0x28, 0xd0, 0xbb, 0x13, 0xe2, 0x7a, 0xb5, 0x5c, 0x33,
	0xb7, 0x51, 0xd9, 0xba, 0xd4, 0x4a, 0xef, 0x6e, 0xab, 0x67, 0xb8, 0xfe, 0x54, 0xcf, 0xb3, 0x33,
	0xb1, 0x74, 0x41, 0x1f, 0x41, 0x85, 0x99, 0x07, 0x86, 0x69, 0x12, 0xcf, 0xab, 0xe5, 0x9b, 0xb9,
	0x8d, 0xb2, 0xbe, 0x3e, 0x0b, 0x55, 0x24, 0xce, 0x4f, 0x18, 0x35, 0x0c, 0x3c, 0x45, 0x2e, 0xa0,
	0x3d, 0x38, 0x77, 0x62, 0x8c, 0x02, 0x32, 0xe0, 0x81, 0x06, 0x86, 0x48, 0xbc, 0xb6, 0xd2, 0x54,
	0x36, 0xca, 0x7a, 0x63, 0x16, 0xaa, 0x75, 0x11, 0x20, 0x05, 0xa4, 0xe1, 0xb3, 0x5c, 0xbb, 0xcf,
	0x94, 0xb2, 0x62, 0xf4, 0x25, 0xac, 0xb9, 0xe4, 0x9b, 0xc0, 0x76, 0xc9, 0xc0, 0x61, 0x79, 0x0e,
	0x5c, 0x3a, 0x1a, 0x05, 0x4e, 0xad, 0xd0, 0x54, 0x36, 0x4a, 0xba, 0x3a, 0x0b, 0xd5, 0xd7, 0x44,
	0xc0, 0x34, 0x94, 0x86, 0x91, 0x54, 0xf3, 0x1a, 0x31, 0x57, 0x5e, 0xcb, 0x3f, 0xfc, 0x49, 0xcd,
	0x68, 0x0f, 0x73, 0x50, 0xec, 0x13, 0xcf, 0xb3, 0xe9, 0x04, 0xdd, 0x04, 0xf0, 0xc4, 0x67, 0x4c,
	0xe9, 0x95, 0xe5, 0x1c, 0x9c, 0x95, 0x1c, 0xcc, 0x5d, 0x34, 0x5c, 0x96, 0xc2, 0x7f, 0x4f, 0xeb,
	0xa7, 0x50, 0x64, 0x25, 0xda, 0xe4, 0x6f, 0xf1, 0x1a, 0xf9, 0xa0, 0xb7, 0x21, 0x3f, 0x31, 0xc6,
	0xa4, 0x96, 0xe7, 0x84, 0x9c, 0x7f, 0x1e, 0xaa, 0x79, 0x7f, 0xea, 0x90, 0x59, 0xa8, 0x56, 0x44,
	0x0a, 0x4c, 0xd2, 0x30, 0x07, 0xa1, 0x1a, 0x14, 0x4d, 0x3a, 0xf1, 0xc9, 0x3d, 0x9f, 0x13, 0xb8,
	0x8a, 0x23, 0x11, 0x1d, 0xc2, 0x8a, 0x11, 0x58, 0xb6, 0x5f, 0x33, 0x9b, 0xca, 0x46, 0x65, 0xeb,
	0x8d, 0x65, 0x39, 0x74, 0x18, 0x68, 0xd7, 0x26, 0x23, 0xcb, 0xd3, 0xeb, 0xb3, 0x50, 0x5d, 0x17,
	0x87, 0x70, 0xdf, 0x2b, 0x74, 0x6c, 0xfb, 0x64, 0xec, 0xf8, 0x53, 0x0d, 0x8b, 0x68, 0x92, 0x9a,
	0x5f, 0x72, 0x50, 0xc0, 0xc4, 0xa4, 0xae, 0x85, 0x2e, 0xcb, 0x74, 0x15, 0x9e, 0xee, 0xb9, 0xe7,
	0xa1, 0x9a, 0xb5, 0xad, 0x59, 0xa8, 0x96, 0x45, 0x1c, 0xd6, 0x21, 0x91, 0xea, 0x22, 0x85, 0xd9,
	0x7f, 0x46, 0xe1, 0xe7, 0x50, 0x74, 0x5c, 0xca, 0x27, 0x3f, 0xc7, 0xeb, 0x53, 0x97, 0xf6, 0x58,
	0xc0, 0xe6, 0x5d, 0x16, 0x22, 0xea, 0x40, 0xc1, 0x9e, 0x38, 0x81, 0x2f, 0x6e, 0xce, 0x29, 0xfd,
	0x11, 0x65, 0x76, 0x19, 0x36, 0xba, 0x81, 0xc2, 0x11, 0x6d, 0x43, 0x91, 0x06, 0x3e, 0x8f, 0xb1,
	0xc2, 0x63, 0xbc, 0x79, 0x7a, 0x8c, 0x7d, 0x0e, 0x8e, 0x12, 0x91, 0xae, 0xa9, 0xc3, 0x58, 0xf8,
	0xd7, 0x86, 0x51, 0xf2, 0xf5, 0x1d, 0x14, 0x65, 0x1f, 0x50, 0x1d, 0x8a, 0xd1, 0x95, 0xe7, 0x94,
	0xdd, 0xc8, 0xe0, 0x48, 0x81, 0xd6, 0x20, 0x7f, 0x6c, 0x78, 0xc7, 0x9c, 0x1c, 0x66, 0xe0, 0x12,
	0x42, 0x92, 0x61, 0xd6, 0xe8, 0xb2, 0x24, 0x73, 0x1d, 0x0a, 0x63, 0xe2, 0x1f, 0x53, 0x4b, 0x8c,
	0x29, 0x96, 0x92, 0x38, 0x4e, 0x5f, 0x05, 0x90, 0x7d, 0x66, 0x49, 0xfd, 0x90, 0x85, 0x4a, 0xa2,
	0x8b, 0xf3, 0x78, 0x4a, 0x22, 0xde, 0x2e, 0x94, 0x5d, 0x0e, 0x89, 0x67, 0xe3, 0x72, 0x7a, 0xe9,
	0xd5, 0x68, 0x99, 0x48, 0xb4, 0x76, 0x23, 0x83, 0x4b, 0x42, 0xea, 0x5a, 0xf3, 0x0a, 0x72, 0x0b,
	0x15, 0x5c, 0x85, 0x32, 0xbb, 0x34, 0x83, 0xc4, 0xbd, 0x5a, 0x8b, 0x43, 0xcd, 0x4d, 0x1a, 0x2e,
	0xb1, 0xef, 0x3d, 0x96, 0x50, 0x07, 0x0a, 0x9e, 0x6f, 0xf8, 0x81, 0x58, 0x8c, 0xff, 0xdf, 0x7a,
	0xeb, 0x15, 0xe6, 0xa3, 0xcf, 0x1d, 0xb0, 0x74, 0x94, 0xbd, 0x28, 0x41, 0xc1, 0xa3, 0x81, 0x6b,
	0x12, 0xed, 0x36, 0xac, 0x26, 0x07, 0x81, 0xf5, 0x81, 0xe7, 0x2a, 0xfb, 0xc0, 0x33, 0xfd, 0x64,
	0x7e, 0x6c, 0x96, 0x1f, 0x7b, 0xca, 0x48, 0x79, 0xc1, 0x28, 0xf5, 0x44, 0xed, 0x5b, 0x58, 0xe1,
	0x8b, 0x85, 0x2d, 0x87, 0x05, 0xaa, 0x63, 0xa2, 0x3f, 0x80, 0xbc, 0x4b, 0x47, 0x44, 0x1e, 0xf2,
	0xfa, 0xa9, 0xfb, 0xe9, 0x60, 0xea, 0x10, 0xcc, 0xe1, 0xa8, 0x0e, 0x25, 0xea, 0xb0, 0xc1, 0x32,
	0x46, 0xbc, 0xc3, 0x25, 0x3c, 0x97, 0xe5, 0xd9, 0x3f, 0xe6, 0xa1, 0x92, 0xd8, 0x28, 0xe8, 0x7b,
	0x05, 0x56, 0x4d, 0x97, 0x18, 0x3e, 0xb1, 0x06, 0x96, 0xe1, 0x0b, 0xd2, 0x2b, 0x5b, 0xf5, 0x96,
	0x78, 0xf8, 0x5b, 0xd1, 0xc3, 0xdf, 0x3a, 0x88, 0xfe, 0x0c, 0xf4, 0xeb, 0x6c, 0xec, 0x9f, 0x87,
	0xea, 0x7a, 0xd2, 0x2f, 0xde, 0x44, 0xb3, 0x50, 0xbd, 0x24, 0x78, 0x4b, 0xb7, 0x6b, 0x0f, 0xfe,
	0x50, 0x15, 0x5c, 0x91, 0xc6, 0x6d, 0xc3, 0x27, 0xe8, 0x33, 0x80, 0x08, 0x7b, 0x34, 0x15, 0xc3,
	0x9d, 0x7c, 0x97, 0x62, 0x5b, 0x72, 0xdf, 0x95, 0xa5, 0x5a, 0x9f, 0xf2, 0x22, 0x02, 0xc7, 0x8a,
	0x8b, 0xc8, 0xbd, 0x7a, 0x11, 0x49, 0xbf, 0xb4, 0x22, 0xd2, 0xed, 0xb2, 0x08, 0x69, 0x8c, 0x8a,
	0x88, 0xb0, 0x47, 0x53, 0x39, 0xc4, 0x89, 0x22, 0x62, 0xdb, 0x42, 0x11, 0x52, 0xad, 0x4f, 0xd1,
	0x87, 0x50, 0x3c, 0x21, 0x2e, 0x5b, 0x9f, 0x7c, 0xa2, 0xff, 0xa7, 0x5f, 0x9c, 0x85, 0x6a, 0x4d,
	0x3e, 0xf5, 0xc2, 0x90, 0xf4, 0x8c, 0xc0, 0xcc, 0x6f, 0x4c, 0x3c, 0xcf, 0x18, 0x12, 0xbe, 0x96,
	0xca, 0x49, 0x3f, 0x69, 0x58, 0xf0, 0x93, 0xba, 0xcd, 0x9f, 0x15, 0x38, 0xfb, 0xd2, 0xdd, 0x40,
	0xef, 0x82, 0x8a, 0x77, 0xae, 0xef, 0xe3, 0xed, 0x41, 0x77, 0xaf, 0x77, 0x78, 0x30, 0xe8, 0x1f,
	0x74, 0x0e, 0x0e, 0xfb, 0x83, 0xc3, 0xbd, 0x7e, 0x6f, 0xe7, 0x7a, 0x77, 0xb7, 0xbb, 0xb3, 0x5d,
	0xcd, 0xd4, 0x2b, 0xf7, 0x1f, 0x35, 0x8b, 0x87, 0x93, 0x3b, 0x13, 0x7a, 0x77, 0x82, 0x5a, 0x70,
	0x31, 0xcd, 0xa3, 0x87, 0xf7, 0x7b, 0xfb, 0xfd, 0x9d, 0xed, 0xaa, 0x52, 0x5f, 0xbd, 0xff, 0xa8,
	0x59, 0xea, 0xb9, 0xd4, 0xa1, 0x1e, 0xb1, 0xd0, 0x26, 0xd4, 0xd3, 0xf0, 0x42, 0x57, 0xcd, 0xd6,
	0xe1, 0xfe, 0xa3, 0xa6, 0x7c, 0xbb, 0x36, 0x03, 0x76, 0x23, 0xe3, 0x7b, 0x84, 0x2e, 0xc1, 0x05,
	0xbc, 0xd3, 0x3f, 0xbc, 0x95, 0x9e, 0x17, 0x5a, 0x07, 0xb4, 0x68, 0xee, 0x75, 0xfa, 0xfd, 0xaa,
	0xf2, 0xb2, 0xbe, 0x7f, 0xb3, 0xdb, 0xab, 0x66, 0x5f, 0xd6, 0xef, 0x76, 0xba, 0xb7, 0xaa, 0x39,
	0xfd, 0xce, 0xe3, 0xa7, 0x0d, 0xe5, 0xc9, 0xd3, 0x86, 0xf2, 0xe7, 0xd3, 0x86, 0xf2, 0xe0, 0x59,
	0x23, 0xf3, 0xe4, 0x59, 0x23, 0xf3, 0xdb, 0xb3, 0x46, 0x06, 0x2e, 0xd8, 0x74, 0xc9, 0x5d, 0xec,
	0x29, 0x5f, 0xbd, 0x3f, 0xb4, 0xfd, 0xe3, 0xe0, 0xa8, 0x65, 0xd2, 0x71, 0x3b, 0x06, 0xbd, 0x63,
	0xd3, 0x84, 0xd4, 0xbe, 0x17, 0xff, 0x25, 0xb3, 0x5d, 0xe6, 0x1d, 0x15, 0xf8, 0x74, 0xbe, 0xf7,
	0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7d, 0x59, 0x3f, 0x99, 0xde, 0x0b, 0x00, 0x00,
}

func (m *Scope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Scope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Scope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequirePartyRollup {
		i--
		if m.RequirePartyRollup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.ValueOwnerAddress) > 0 {
		i -= len(m.ValueOwnerAddress)
		copy(dAtA[i:], m.ValueOwnerAddress)
		i = encodeVarintScope(dAtA, i, uint64(len(m.ValueOwnerAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DataAccess) > 0 {
		for iNdEx := len(m.DataAccess) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DataAccess[iNdEx])
			copy(dAtA[i:], m.DataAccess[iNdEx])
			i = encodeVarintScope(dAtA, i, uint64(len(m.DataAccess[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Owners) > 0 {
		for iNdEx := len(m.Owners) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Owners[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.SpecificationId.Size()
		i -= size
		if _, err := m.SpecificationId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.ScopeId.Size()
		i -= size
		if _, err := m.ScopeId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Audit != nil {
		{
			size, err := m.Audit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScope(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Parties) > 0 {
		for iNdEx := len(m.Parties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.SpecificationId.Size()
		i -= size
		if _, err := m.SpecificationId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SessionId.Size()
		i -= size
		if _, err := m.SessionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SpecificationId.Size()
		i -= size
		if _, err := m.SpecificationId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScope(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Process.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SessionId.Size()
		i -= size
		if _, err := m.SessionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Process) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Process) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Process) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProcessId != nil {
		{
			size := m.ProcessId.Size()
			i -= size
			if _, err := m.ProcessId.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Process_Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Process_Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Address)
	copy(dAtA[i:], m.Address)
	i = encodeVarintScope(dAtA, i, uint64(len(m.Address)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Process_Hash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Process_Hash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hash)
	copy(dAtA[i:], m.Hash)
	i = encodeVarintScope(dAtA, i, uint64(len(m.Hash)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RecordInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintScope(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintScope(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Source != nil {
		{
			size := m.Source.Size()
			i -= size
			if _, err := m.Source.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecordInput_RecordId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordInput_RecordId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	{
		size := m.RecordId.Size()
		i -= size
		if _, err := m.RecordId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintScope(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RecordInput_Hash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordInput_Hash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hash)
	copy(dAtA[i:], m.Hash)
	i = encodeVarintScope(dAtA, i, uint64(len(m.Hash)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *RecordOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintScope(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Party) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Party) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Party) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Optional {
		i--
		if m.Optional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Role != 0 {
		i = encodeVarintScope(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditFields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditFields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintScope(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x32
	}
	if m.Version != 0 {
		i = encodeVarintScope(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UpdatedBy) > 0 {
		i -= len(m.UpdatedBy)
		copy(dAtA[i:], m.UpdatedBy)
		i = encodeVarintScope(dAtA, i, uint64(len(m.UpdatedBy)))
		i--
		dAtA[i] = 0x22
	}
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedDate):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintScope(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x1a
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintScope(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x12
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedDate):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintScope(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintScope(dAtA []byte, offset int, v uint64) int {
	offset -= sovScope(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Scope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ScopeId.Size()
	n += 1 + l + sovScope(uint64(l))
	l = m.SpecificationId.Size()
	n += 1 + l + sovScope(uint64(l))
	if len(m.Owners) > 0 {
		for _, e := range m.Owners {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	if len(m.DataAccess) > 0 {
		for _, s := range m.DataAccess {
			l = len(s)
			n += 1 + l + sovScope(uint64(l))
		}
	}
	l = len(m.ValueOwnerAddress)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.RequirePartyRollup {
		n += 2
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionId.Size()
	n += 1 + l + sovScope(uint64(l))
	l = m.SpecificationId.Size()
	n += 1 + l + sovScope(uint64(l))
	if len(m.Parties) > 0 {
		for _, e := range m.Parties {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Audit != nil {
		l = m.Audit.Size()
		n += 2 + l + sovScope(uint64(l))
	}
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = m.SessionId.Size()
	n += 1 + l + sovScope(uint64(l))
	l = m.Process.Size()
	n += 1 + l + sovScope(uint64(l))
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovScope(uint64(l))
		}
	}
	l = m.SpecificationId.Size()
	n += 1 + l + sovScope(uint64(l))
	return n
}

func (m *Process) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessId != nil {
		n += m.ProcessId.Size()
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	return n
}

func (m *Process_Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovScope(uint64(l))
	return n
}
func (m *Process_Hash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	n += 1 + l + sovScope(uint64(l))
	return n
}
func (m *RecordInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Source != nil {
		n += m.Source.Size()
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovScope(uint64(m.Status))
	}
	return n
}

func (m *RecordInput_RecordId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RecordId.Size()
	n += 1 + l + sovScope(uint64(l))
	return n
}
func (m *RecordInput_Hash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	n += 1 + l + sovScope(uint64(l))
	return n
}
func (m *RecordOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovScope(uint64(m.Status))
	}
	return n
}

func (m *Party) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovScope(uint64(m.Role))
	}
	if m.Optional {
		n += 2
	}
	return n
}

func (m *AuditFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedDate)
	n += 1 + l + sovScope(uint64(l))
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedDate)
	n += 1 + l + sovScope(uint64(l))
	l = len(m.UpdatedBy)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovScope(uint64(m.Version))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovScope(uint64(l))
	}
	return n
}

func sovScope(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScope(x uint64) (n int) {
	return sovScope(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Scope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ScopeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpecificationId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owners = append(m.Owners, Party{})
			if err := m.Owners[len(m.Owners)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataAccess", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataAccess = append(m.DataAccess, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueOwnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueOwnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequirePartyRollup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequirePartyRollup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpecificationId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parties = append(m.Parties, Party{})
			if err := m.Parties[len(m.Parties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audit == nil {
				m.Audit = &AuditFields{}
			}
			if err := m.Audit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Process.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, RecordInput{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, RecordOutput{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpecificationId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessId = &Process_Address{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessId = &Process_Hash{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var vv MetadataAddress
			v := &vv
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &RecordInput_RecordId{*v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = &RecordInput_Hash{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RecordInputStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ResultStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Party) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Party: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Party: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Optional = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScope
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScope
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScope
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScope
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScope(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScope
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScope(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScope
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScope
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScope
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScope
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScope
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScope
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScope        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScope          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScope = fmt.Errorf("proto: unexpected end of group")
)
