// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/p8e/p8e.proto

package p8e

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DefinitionSpecType int32

const (
	DefinitionSpecType_DEFINITION_SPEC_TYPE_UNKNOWN   DefinitionSpecType = 0
	DefinitionSpecType_DEFINITION_SPEC_TYPE_PROPOSED  DefinitionSpecType = 1
	DefinitionSpecType_DEFINITION_SPEC_TYPE_FACT      DefinitionSpecType = 2
	DefinitionSpecType_DEFINITION_SPEC_TYPE_FACT_LIST DefinitionSpecType = 3
)

var DefinitionSpecType_name = map[int32]string{
	0: "DEFINITION_SPEC_TYPE_UNKNOWN",
	1: "DEFINITION_SPEC_TYPE_PROPOSED",
	2: "DEFINITION_SPEC_TYPE_FACT",
	3: "DEFINITION_SPEC_TYPE_FACT_LIST",
}

var DefinitionSpecType_value = map[string]int32{
	"DEFINITION_SPEC_TYPE_UNKNOWN":   0,
	"DEFINITION_SPEC_TYPE_PROPOSED":  1,
	"DEFINITION_SPEC_TYPE_FACT":      2,
	"DEFINITION_SPEC_TYPE_FACT_LIST": 3,
}

func (x DefinitionSpecType) String() string {
	return proto.EnumName(DefinitionSpecType_name, int32(x))
}

func (DefinitionSpecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{0}
}

type PublicKeyCurve int32

const (
	PublicKeyCurve_SECP256K1 PublicKeyCurve = 0
	PublicKeyCurve_P256      PublicKeyCurve = 1
)

var PublicKeyCurve_name = map[int32]string{
	0: "SECP256K1",
	1: "P256",
}

var PublicKeyCurve_value = map[string]int32{
	"SECP256K1": 0,
	"P256":      1,
}

func (x PublicKeyCurve) String() string {
	return proto.EnumName(PublicKeyCurve_name, int32(x))
}

func (PublicKeyCurve) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{1}
}

type PublicKeyType int32

const (
	PublicKeyType_ELLIPTIC PublicKeyType = 0
)

var PublicKeyType_name = map[int32]string{
	0: "ELLIPTIC",
}

var PublicKeyType_value = map[string]int32{
	"ELLIPTIC": 0,
}

func (x PublicKeyType) String() string {
	return proto.EnumName(PublicKeyType_name, int32(x))
}

func (PublicKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{2}
}

type ExecutionResultType int32

const (
	ExecutionResultType_RESULT_TYPE_UNKNOWN ExecutionResultType = 0
	ExecutionResultType_RESULT_TYPE_PASS    ExecutionResultType = 1
	// Couldn't process the condition/consideration due to missing facts being generated by other considerations.
	ExecutionResultType_RESULT_TYPE_SKIP ExecutionResultType = 2
	ExecutionResultType_RESULT_TYPE_FAIL ExecutionResultType = 3
)

var ExecutionResultType_name = map[int32]string{
	0: "RESULT_TYPE_UNKNOWN",
	1: "RESULT_TYPE_PASS",
	2: "RESULT_TYPE_SKIP",
	3: "RESULT_TYPE_FAIL",
}

var ExecutionResultType_value = map[string]int32{
	"RESULT_TYPE_UNKNOWN": 0,
	"RESULT_TYPE_PASS":    1,
	"RESULT_TYPE_SKIP":    2,
	"RESULT_TYPE_FAIL":    3,
}

func (x ExecutionResultType) String() string {
	return proto.EnumName(ExecutionResultType_name, int32(x))
}

func (ExecutionResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{3}
}

type PartyType int32

const (
	PartyType_PARTY_TYPE_UNKNOWN    PartyType = 0
	PartyType_PARTY_TYPE_ORIGINATOR PartyType = 1
	PartyType_PARTY_TYPE_SERVICER   PartyType = 2
	PartyType_PARTY_TYPE_INVESTOR   PartyType = 3
	PartyType_PARTY_TYPE_CUSTODIAN  PartyType = 4
	PartyType_PARTY_TYPE_OWNER      PartyType = 5
	PartyType_PARTY_TYPE_AFFILIATE  PartyType = 6
	PartyType_PARTY_TYPE_OMNIBUS    PartyType = 7
	PartyType_PARTY_TYPE_PROVENANCE PartyType = 8
	PartyType_PARTY_TYPE_MARKER     PartyType = 9
	PartyType_PARTY_TYPE_CONTROLLER PartyType = 10
	PartyType_PARTY_TYPE_VALIDATOR  PartyType = 11
)

var PartyType_name = map[int32]string{
	0:  "PARTY_TYPE_UNKNOWN",
	1:  "PARTY_TYPE_ORIGINATOR",
	2:  "PARTY_TYPE_SERVICER",
	3:  "PARTY_TYPE_INVESTOR",
	4:  "PARTY_TYPE_CUSTODIAN",
	5:  "PARTY_TYPE_OWNER",
	6:  "PARTY_TYPE_AFFILIATE",
	7:  "PARTY_TYPE_OMNIBUS",
	8:  "PARTY_TYPE_PROVENANCE",
	9:  "PARTY_TYPE_MARKER",
	10: "PARTY_TYPE_CONTROLLER",
	11: "PARTY_TYPE_VALIDATOR",
}

var PartyType_value = map[string]int32{
	"PARTY_TYPE_UNKNOWN":    0,
	"PARTY_TYPE_ORIGINATOR": 1,
	"PARTY_TYPE_SERVICER":   2,
	"PARTY_TYPE_INVESTOR":   3,
	"PARTY_TYPE_CUSTODIAN":  4,
	"PARTY_TYPE_OWNER":      5,
	"PARTY_TYPE_AFFILIATE":  6,
	"PARTY_TYPE_OMNIBUS":    7,
	"PARTY_TYPE_PROVENANCE": 8,
	"PARTY_TYPE_MARKER":     9,
	"PARTY_TYPE_CONTROLLER": 10,
	"PARTY_TYPE_VALIDATOR":  11,
}

func (x PartyType) String() string {
	return proto.EnumName(PartyType_name, int32(x))
}

func (PartyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{4}
}

type Contract struct {
	Definition *DefinitionSpec `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
	// Points to the proto for the contractSpec
	Spec *Fact `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	// Invoker of this contract
	Invoker *SigningAndEncryptionPublicKeys `protobuf:"bytes,3,opt,name=invoker,proto3" json:"invoker,omitempty"`
	// Constructor arguments.
	// These are always the output of a previously recorded consideration.
	Inputs []*Fact `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// conditions is a deprecated field that is not used at all anymore.
	Conditions     []*Condition     `protobuf:"bytes,5,rep,name=conditions,proto3" json:"conditions,omitempty"` // Deprecated: Do not use.
	Considerations []*Consideration `protobuf:"bytes,6,rep,name=considerations,proto3" json:"considerations,omitempty"`
	Recitals       []*Recital       `protobuf:"bytes,7,rep,name=recitals,proto3" json:"recitals,omitempty"`
	TimesExecuted  int32            `protobuf:"varint,8,opt,name=times_executed,json=timesExecuted,proto3" json:"times_executed,omitempty"`
	// This is only set once when the contract is initially executed
	StartTime *Timestamp `protobuf:"bytes,9,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	Context   []byte     `protobuf:"bytes,10,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{0}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetDefinition() *DefinitionSpec {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *Contract) GetSpec() *Fact {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Contract) GetInvoker() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Invoker
	}
	return nil
}

func (m *Contract) GetInputs() []*Fact {
	if m != nil {
		return m.Inputs
	}
	return nil
}

// Deprecated: Do not use.
func (m *Contract) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Contract) GetConsiderations() []*Consideration {
	if m != nil {
		return m.Considerations
	}
	return nil
}

func (m *Contract) GetRecitals() []*Recital {
	if m != nil {
		return m.Recitals
	}
	return nil
}

func (m *Contract) GetTimesExecuted() int32 {
	if m != nil {
		return m.TimesExecuted
	}
	return 0
}

func (m *Contract) GetStartTime() *Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Contract) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type DefinitionSpec struct {
	Name             string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ResourceLocation *Location          `protobuf:"bytes,2,opt,name=resource_location,json=resourceLocation,proto3" json:"resource_location,omitempty"`
	Signature        *Signature         `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Type             DefinitionSpecType `protobuf:"varint,4,opt,name=type,proto3,enum=provenance.metadata.v1.p8e.DefinitionSpecType" json:"type,omitempty"`
}

func (m *DefinitionSpec) Reset()         { *m = DefinitionSpec{} }
func (m *DefinitionSpec) String() string { return proto.CompactTextString(m) }
func (*DefinitionSpec) ProtoMessage()    {}
func (*DefinitionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{1}
}
func (m *DefinitionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefinitionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefinitionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefinitionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefinitionSpec.Merge(m, src)
}
func (m *DefinitionSpec) XXX_Size() int {
	return m.Size()
}
func (m *DefinitionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DefinitionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DefinitionSpec proto.InternalMessageInfo

func (m *DefinitionSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DefinitionSpec) GetResourceLocation() *Location {
	if m != nil {
		return m.ResourceLocation
	}
	return nil
}

func (m *DefinitionSpec) GetSignature() *Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DefinitionSpec) GetType() DefinitionSpecType {
	if m != nil {
		return m.Type
	}
	return DefinitionSpecType_DEFINITION_SPEC_TYPE_UNKNOWN
}

type Fact struct {
	Name         string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DataLocation *Location `protobuf:"bytes,2,opt,name=data_location,json=dataLocation,proto3" json:"data_location,omitempty"`
}

func (m *Fact) Reset()         { *m = Fact{} }
func (m *Fact) String() string { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()    {}
func (*Fact) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{2}
}
func (m *Fact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fact.Merge(m, src)
}
func (m *Fact) XXX_Size() int {
	return m.Size()
}
func (m *Fact) XXX_DiscardUnknown() {
	xxx_messageInfo_Fact.DiscardUnknown(m)
}

var xxx_messageInfo_Fact proto.InternalMessageInfo

func (m *Fact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Fact) GetDataLocation() *Location {
	if m != nil {
		return m.DataLocation
	}
	return nil
}

type Condition struct {
	ConditionName string           `protobuf:"bytes,1,opt,name=condition_name,json=conditionName,proto3" json:"condition_name,omitempty"`
	Result        *ExecutionResult `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{3}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetConditionName() string {
	if m != nil {
		return m.ConditionName
	}
	return ""
}

func (m *Condition) GetResult() *ExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type Consideration struct {
	ConsiderationName string `protobuf:"bytes,1,opt,name=consideration_name,json=considerationName,proto3" json:"consideration_name,omitempty"`
	// Data pushed to a consideration that will ultimately match the output_spec of the consideration
	Inputs []*ProposedFact  `protobuf:"bytes,2,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Result *ExecutionResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Consideration) Reset()         { *m = Consideration{} }
func (m *Consideration) String() string { return proto.CompactTextString(m) }
func (*Consideration) ProtoMessage()    {}
func (*Consideration) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{4}
}
func (m *Consideration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Consideration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Consideration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Consideration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Consideration.Merge(m, src)
}
func (m *Consideration) XXX_Size() int {
	return m.Size()
}
func (m *Consideration) XXX_DiscardUnknown() {
	xxx_messageInfo_Consideration.DiscardUnknown(m)
}

var xxx_messageInfo_Consideration proto.InternalMessageInfo

func (m *Consideration) GetConsiderationName() string {
	if m != nil {
		return m.ConsiderationName
	}
	return ""
}

func (m *Consideration) GetInputs() []*ProposedFact {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Consideration) GetResult() *ExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type ProposedFact struct {
	Name      string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hash      string               `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Classname string               `protobuf:"bytes,3,opt,name=classname,proto3" json:"classname,omitempty"`
	Ancestor  *ProvenanceReference `protobuf:"bytes,4,opt,name=ancestor,proto3" json:"ancestor,omitempty"`
}

func (m *ProposedFact) Reset()         { *m = ProposedFact{} }
func (m *ProposedFact) String() string { return proto.CompactTextString(m) }
func (*ProposedFact) ProtoMessage()    {}
func (*ProposedFact) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{5}
}
func (m *ProposedFact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposedFact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposedFact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposedFact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposedFact.Merge(m, src)
}
func (m *ProposedFact) XXX_Size() int {
	return m.Size()
}
func (m *ProposedFact) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposedFact.DiscardUnknown(m)
}

var xxx_messageInfo_ProposedFact proto.InternalMessageInfo

func (m *ProposedFact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProposedFact) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProposedFact) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

func (m *ProposedFact) GetAncestor() *ProvenanceReference {
	if m != nil {
		return m.Ancestor
	}
	return nil
}

type ExecutionResult struct {
	Output       *ProposedFact       `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Result       ExecutionResultType `protobuf:"varint,2,opt,name=result,proto3,enum=provenance.metadata.v1.p8e.ExecutionResultType" json:"result,omitempty"`
	RecordedAt   *Timestamp          `protobuf:"bytes,3,opt,name=recorded_at,json=recordedAt,proto3" json:"recorded_at,omitempty"`
	ErrorMessage string              `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *ExecutionResult) Reset()         { *m = ExecutionResult{} }
func (m *ExecutionResult) String() string { return proto.CompactTextString(m) }
func (*ExecutionResult) ProtoMessage()    {}
func (*ExecutionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{6}
}
func (m *ExecutionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionResult.Merge(m, src)
}
func (m *ExecutionResult) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionResult proto.InternalMessageInfo

func (m *ExecutionResult) GetOutput() *ProposedFact {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ExecutionResult) GetResult() ExecutionResultType {
	if m != nil {
		return m.Result
	}
	return ExecutionResultType_RESULT_TYPE_UNKNOWN
}

func (m *ExecutionResult) GetRecordedAt() *Timestamp {
	if m != nil {
		return m.RecordedAt
	}
	return nil
}

func (m *ExecutionResult) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type Recitals struct {
	Parties []*Recital `protobuf:"bytes,1,rep,name=parties,proto3" json:"parties,omitempty"`
}

func (m *Recitals) Reset()         { *m = Recitals{} }
func (m *Recitals) String() string { return proto.CompactTextString(m) }
func (*Recitals) ProtoMessage()    {}
func (*Recitals) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{7}
}
func (m *Recitals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recitals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recitals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recitals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recitals.Merge(m, src)
}
func (m *Recitals) XXX_Size() int {
	return m.Size()
}
func (m *Recitals) XXX_DiscardUnknown() {
	xxx_messageInfo_Recitals.DiscardUnknown(m)
}

var xxx_messageInfo_Recitals proto.InternalMessageInfo

func (m *Recitals) GetParties() []*Recital {
	if m != nil {
		return m.Parties
	}
	return nil
}

type Recital struct {
	SignerRole PartyType                       `protobuf:"varint,1,opt,name=signer_role,json=signerRole,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"signer_role,omitempty"`
	Signer     *SigningAndEncryptionPublicKeys `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Address    []byte                          `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Recital) Reset()         { *m = Recital{} }
func (m *Recital) String() string { return proto.CompactTextString(m) }
func (*Recital) ProtoMessage()    {}
func (*Recital) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{8}
}
func (m *Recital) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recital) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recital.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recital) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recital.Merge(m, src)
}
func (m *Recital) XXX_Size() int {
	return m.Size()
}
func (m *Recital) XXX_DiscardUnknown() {
	xxx_messageInfo_Recital.DiscardUnknown(m)
}

var xxx_messageInfo_Recital proto.InternalMessageInfo

func (m *Recital) GetSignerRole() PartyType {
	if m != nil {
		return m.SignerRole
	}
	return PartyType_PARTY_TYPE_UNKNOWN
}

func (m *Recital) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *Recital) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

type Location struct {
	Ref       *ProvenanceReference `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	Classname string               `protobuf:"bytes,2,opt,name=classname,proto3" json:"classname,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{9}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetRef() *ProvenanceReference {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Location) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

type ProvenanceReference struct {
	// [Req] [Scope.uuid]
	// Scope ID
	ScopeUuid *UUID `protobuf:"bytes,1,opt,name=scope_uuid,json=scopeUuid,proto3" json:"scope_uuid,omitempty"`
	// [Opt] [RecordGroup.group_uuid]
	// require record to be within a specific group
	GroupUuid *UUID `protobuf:"bytes,2,opt,name=group_uuid,json=groupUuid,proto3" json:"group_uuid,omitempty"`
	// [Opt] [Record.result_hash]
	// specify a specific record inside a scope (and group) by result-hash
	Hash string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	// [Opt] [Record.result_name]
	// specify a result-name of a record within a scope
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ProvenanceReference) Reset()         { *m = ProvenanceReference{} }
func (m *ProvenanceReference) String() string { return proto.CompactTextString(m) }
func (*ProvenanceReference) ProtoMessage()    {}
func (*ProvenanceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{10}
}
func (m *ProvenanceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvenanceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvenanceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvenanceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvenanceReference.Merge(m, src)
}
func (m *ProvenanceReference) XXX_Size() int {
	return m.Size()
}
func (m *ProvenanceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvenanceReference.DiscardUnknown(m)
}

var xxx_messageInfo_ProvenanceReference proto.InternalMessageInfo

func (m *ProvenanceReference) GetScopeUuid() *UUID {
	if m != nil {
		return m.ScopeUuid
	}
	return nil
}

func (m *ProvenanceReference) GetGroupUuid() *UUID {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *ProvenanceReference) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProvenanceReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type SignatureSet struct {
	Signatures []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *SignatureSet) Reset()         { *m = SignatureSet{} }
func (m *SignatureSet) String() string { return proto.CompactTextString(m) }
func (*SignatureSet) ProtoMessage()    {}
func (*SignatureSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{11}
}
func (m *SignatureSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureSet.Merge(m, src)
}
func (m *SignatureSet) XXX_Size() int {
	return m.Size()
}
func (m *SignatureSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureSet.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureSet proto.InternalMessageInfo

func (m *SignatureSet) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Signature struct {
	// Signature Detail
	Algo      string `protobuf:"bytes,1,opt,name=algo,proto3" json:"algo,omitempty"`
	Provider  string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	Signature string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Identity of signer
	Signer *SigningAndEncryptionPublicKeys `protobuf:"bytes,4,opt,name=signer,proto3" json:"signer,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{12}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *Signature) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Signature) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

type SigningAndEncryptionPublicKeys struct {
	SigningPublicKey    *PublicKey `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	EncryptionPublicKey *PublicKey `protobuf:"bytes,2,opt,name=encryption_public_key,json=encryptionPublicKey,proto3" json:"encryption_public_key,omitempty"`
}

func (m *SigningAndEncryptionPublicKeys) Reset()         { *m = SigningAndEncryptionPublicKeys{} }
func (m *SigningAndEncryptionPublicKeys) String() string { return proto.CompactTextString(m) }
func (*SigningAndEncryptionPublicKeys) ProtoMessage()    {}
func (*SigningAndEncryptionPublicKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{13}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningAndEncryptionPublicKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.Merge(m, src)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Size() int {
	return m.Size()
}
func (m *SigningAndEncryptionPublicKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.DiscardUnknown(m)
}

var xxx_messageInfo_SigningAndEncryptionPublicKeys proto.InternalMessageInfo

func (m *SigningAndEncryptionPublicKeys) GetSigningPublicKey() *PublicKey {
	if m != nil {
		return m.SigningPublicKey
	}
	return nil
}

func (m *SigningAndEncryptionPublicKeys) GetEncryptionPublicKey() *PublicKey {
	if m != nil {
		return m.EncryptionPublicKey
	}
	return nil
}

type PublicKey struct {
	PublicKeyBytes []byte         `protobuf:"bytes,1,opt,name=public_key_bytes,json=publicKeyBytes,proto3" json:"public_key_bytes,omitempty"`
	Type           PublicKeyType  `protobuf:"varint,2,opt,name=type,proto3,enum=provenance.metadata.v1.p8e.PublicKeyType" json:"type,omitempty"`
	Curve          PublicKeyCurve `protobuf:"varint,3,opt,name=curve,proto3,enum=provenance.metadata.v1.p8e.PublicKeyCurve" json:"curve,omitempty"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{14}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKeyBytes() []byte {
	if m != nil {
		return m.PublicKeyBytes
	}
	return nil
}

func (m *PublicKey) GetType() PublicKeyType {
	if m != nil {
		return m.Type
	}
	return PublicKeyType_ELLIPTIC
}

func (m *PublicKey) GetCurve() PublicKeyCurve {
	if m != nil {
		return m.Curve
	}
	return PublicKeyCurve_SECP256K1
}

type UUID struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UUID) Reset()         { *m = UUID{} }
func (m *UUID) String() string { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()    {}
func (*UUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{15}
}
func (m *UUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID.Merge(m, src)
}
func (m *UUID) XXX_Size() int {
	return m.Size()
}
func (m *UUID) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID.DiscardUnknown(m)
}

var xxx_messageInfo_UUID proto.InternalMessageInfo

func (m *UUID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A Timestamp represents a point in time using values relative to the epoch.
type Timestamp struct {
	// Represents seconds of UTC time since Unix epoch
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{16}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

type ContractSpec struct {
	Definition         *DefinitionSpec      `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
	InputSpecs         []*DefinitionSpec    `protobuf:"bytes,2,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	PartiesInvolved    []PartyType          `protobuf:"varint,3,rep,packed,name=parties_involved,json=partiesInvolved,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"parties_involved,omitempty"`
	ConditionSpecs     []*ConditionSpec     `protobuf:"bytes,4,rep,name=condition_specs,json=conditionSpecs,proto3" json:"condition_specs,omitempty"`
	ConsiderationSpecs []*ConsiderationSpec `protobuf:"bytes,5,rep,name=consideration_specs,json=considerationSpecs,proto3" json:"consideration_specs,omitempty"`
}

func (m *ContractSpec) Reset()         { *m = ContractSpec{} }
func (m *ContractSpec) String() string { return proto.CompactTextString(m) }
func (*ContractSpec) ProtoMessage()    {}
func (*ContractSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{17}
}
func (m *ContractSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractSpec.Merge(m, src)
}
func (m *ContractSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContractSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContractSpec proto.InternalMessageInfo

func (m *ContractSpec) GetDefinition() *DefinitionSpec {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *ContractSpec) GetInputSpecs() []*DefinitionSpec {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ContractSpec) GetPartiesInvolved() []PartyType {
	if m != nil {
		return m.PartiesInvolved
	}
	return nil
}

func (m *ContractSpec) GetConditionSpecs() []*ConditionSpec {
	if m != nil {
		return m.ConditionSpecs
	}
	return nil
}

func (m *ContractSpec) GetConsiderationSpecs() []*ConsiderationSpec {
	if m != nil {
		return m.ConsiderationSpecs
	}
	return nil
}

type ConditionSpec struct {
	FuncName   string            `protobuf:"bytes,1,opt,name=func_name,json=funcName,proto3" json:"func_name,omitempty"`
	InputSpecs []*DefinitionSpec `protobuf:"bytes,2,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	OutputSpec *OutputSpec       `protobuf:"bytes,3,opt,name=output_spec,json=outputSpec,proto3" json:"output_spec,omitempty"`
}

func (m *ConditionSpec) Reset()         { *m = ConditionSpec{} }
func (m *ConditionSpec) String() string { return proto.CompactTextString(m) }
func (*ConditionSpec) ProtoMessage()    {}
func (*ConditionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{18}
}
func (m *ConditionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionSpec.Merge(m, src)
}
func (m *ConditionSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConditionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionSpec proto.InternalMessageInfo

func (m *ConditionSpec) GetFuncName() string {
	if m != nil {
		return m.FuncName
	}
	return ""
}

func (m *ConditionSpec) GetInputSpecs() []*DefinitionSpec {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ConditionSpec) GetOutputSpec() *OutputSpec {
	if m != nil {
		return m.OutputSpec
	}
	return nil
}

type ConsiderationSpec struct {
	FuncName string `protobuf:"bytes,1,opt,name=func_name,json=funcName,proto3" json:"func_name,omitempty"`
	// Invoking party
	ResponsibleParty PartyType         `protobuf:"varint,2,opt,name=responsible_party,json=responsibleParty,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"responsible_party,omitempty"`
	InputSpecs       []*DefinitionSpec `protobuf:"bytes,3,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	OutputSpec       *OutputSpec       `protobuf:"bytes,4,opt,name=output_spec,json=outputSpec,proto3" json:"output_spec,omitempty"`
}

func (m *ConsiderationSpec) Reset()         { *m = ConsiderationSpec{} }
func (m *ConsiderationSpec) String() string { return proto.CompactTextString(m) }
func (*ConsiderationSpec) ProtoMessage()    {}
func (*ConsiderationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{19}
}
func (m *ConsiderationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsiderationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsiderationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsiderationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsiderationSpec.Merge(m, src)
}
func (m *ConsiderationSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConsiderationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsiderationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConsiderationSpec proto.InternalMessageInfo

func (m *ConsiderationSpec) GetFuncName() string {
	if m != nil {
		return m.FuncName
	}
	return ""
}

func (m *ConsiderationSpec) GetResponsibleParty() PartyType {
	if m != nil {
		return m.ResponsibleParty
	}
	return PartyType_PARTY_TYPE_UNKNOWN
}

func (m *ConsiderationSpec) GetInputSpecs() []*DefinitionSpec {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ConsiderationSpec) GetOutputSpec() *OutputSpec {
	if m != nil {
		return m.OutputSpec
	}
	return nil
}

type OutputSpec struct {
	Spec *DefinitionSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *OutputSpec) Reset()         { *m = OutputSpec{} }
func (m *OutputSpec) String() string { return proto.CompactTextString(m) }
func (*OutputSpec) ProtoMessage()    {}
func (*OutputSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{20}
}
func (m *OutputSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputSpec.Merge(m, src)
}
func (m *OutputSpec) XXX_Size() int {
	return m.Size()
}
func (m *OutputSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OutputSpec proto.InternalMessageInfo

func (m *OutputSpec) GetSpec() *DefinitionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.metadata.v1.p8e.DefinitionSpecType", DefinitionSpecType_name, DefinitionSpecType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PublicKeyCurve", PublicKeyCurve_name, PublicKeyCurve_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PublicKeyType", PublicKeyType_name, PublicKeyType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.ExecutionResultType", ExecutionResultType_name, ExecutionResultType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PartyType", PartyType_name, PartyType_value)
	proto.RegisterType((*Contract)(nil), "provenance.metadata.v1.p8e.Contract")
	proto.RegisterType((*DefinitionSpec)(nil), "provenance.metadata.v1.p8e.DefinitionSpec")
	proto.RegisterType((*Fact)(nil), "provenance.metadata.v1.p8e.Fact")
	proto.RegisterType((*Condition)(nil), "provenance.metadata.v1.p8e.Condition")
	proto.RegisterType((*Consideration)(nil), "provenance.metadata.v1.p8e.Consideration")
	proto.RegisterType((*ProposedFact)(nil), "provenance.metadata.v1.p8e.ProposedFact")
	proto.RegisterType((*ExecutionResult)(nil), "provenance.metadata.v1.p8e.ExecutionResult")
	proto.RegisterType((*Recitals)(nil), "provenance.metadata.v1.p8e.Recitals")
	proto.RegisterType((*Recital)(nil), "provenance.metadata.v1.p8e.Recital")
	proto.RegisterType((*Location)(nil), "provenance.metadata.v1.p8e.Location")
	proto.RegisterType((*ProvenanceReference)(nil), "provenance.metadata.v1.p8e.ProvenanceReference")
	proto.RegisterType((*SignatureSet)(nil), "provenance.metadata.v1.p8e.SignatureSet")
	proto.RegisterType((*Signature)(nil), "provenance.metadata.v1.p8e.Signature")
	proto.RegisterType((*SigningAndEncryptionPublicKeys)(nil), "provenance.metadata.v1.p8e.SigningAndEncryptionPublicKeys")
	proto.RegisterType((*PublicKey)(nil), "provenance.metadata.v1.p8e.PublicKey")
	proto.RegisterType((*UUID)(nil), "provenance.metadata.v1.p8e.UUID")
	proto.RegisterType((*Timestamp)(nil), "provenance.metadata.v1.p8e.Timestamp")
	proto.RegisterType((*ContractSpec)(nil), "provenance.metadata.v1.p8e.ContractSpec")
	proto.RegisterType((*ConditionSpec)(nil), "provenance.metadata.v1.p8e.ConditionSpec")
	proto.RegisterType((*ConsiderationSpec)(nil), "provenance.metadata.v1.p8e.ConsiderationSpec")
	proto.RegisterType((*OutputSpec)(nil), "provenance.metadata.v1.p8e.OutputSpec")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/p8e/p8e.proto", fileDescriptor_92e2ab9f03ad9d0c)
}

var fileDescriptor_92e2ab9f03ad9d0c = []byte{
	// 1629 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x6f, 0xdb, 0xc6,
	0x12, 0x37, 0x25, 0xd9, 0x16, 0xc7, 0xb2, 0x42, 0xaf, 0x93, 0xf7, 0x94, 0xbc, 0x58, 0xd0, 0x63,
	0x92, 0x07, 0xc7, 0x0f, 0x91, 0x11, 0xbf, 0xd7, 0xc2, 0x68, 0x91, 0x26, 0xb2, 0x4c, 0x07, 0xac,
	0x15, 0x49, 0x59, 0x4a, 0x0e, 0xd2, 0x43, 0x09, 0x9a, 0x5a, 0x3b, 0x44, 0x64, 0x92, 0xe0, 0x1f,
	0x37, 0xba, 0x15, 0xbd, 0xf5, 0xd6, 0x73, 0xd1, 0x4b, 0x3f, 0x40, 0xae, 0x05, 0x7a, 0x2a, 0x50,
	0xa0, 0x40, 0x8f, 0x39, 0xf6, 0x58, 0x24, 0x5f, 0xa4, 0xd8, 0xe5, 0x5f, 0x31, 0x0e, 0x23, 0xa7,
	0x3e, 0x08, 0xd8, 0x9d, 0x9d, 0xdf, 0x6f, 0x66, 0x77, 0x67, 0x66, 0x87, 0x82, 0x9b, 0xb6, 0x63,
	0x9d, 0x12, 0x53, 0x33, 0x75, 0xb2, 0x79, 0x42, 0x3c, 0x6d, 0xa4, 0x79, 0xda, 0xe6, 0xe9, 0xdd,
	0x4d, 0x7b, 0x9b, 0xd0, 0x5f, 0xd3, 0x76, 0x2c, 0xcf, 0x42, 0xd7, 0x12, 0xad, 0x66, 0xa4, 0xd5,
	0x3c, 0xbd, 0xdb, 0xb4, 0xb7, 0x89, 0xf8, 0xcd, 0x3c, 0x94, 0xdb, 0x96, 0xe9, 0x39, 0x9a, 0xee,
	0xa1, 0xcf, 0x01, 0x46, 0xe4, 0xc8, 0x30, 0x0d, 0xcf, 0xb0, 0xcc, 0x1a, 0xd7, 0xe0, 0xd6, 0x97,
	0xb6, 0x36, 0x9a, 0xef, 0x46, 0x37, 0x77, 0x63, 0x6d, 0xc5, 0x26, 0x3a, 0x4e, 0xa1, 0xd1, 0xff,
	0xa1, 0xe4, 0xda, 0x44, 0xaf, 0x15, 0x18, 0x4b, 0x23, 0x8f, 0x65, 0x4f, 0xd3, 0x3d, 0xcc, 0xb4,
	0xd1, 0x00, 0x16, 0x0d, 0xf3, 0xd4, 0x7a, 0x4e, 0x9c, 0x5a, 0x91, 0x01, 0x3f, 0xc9, 0x03, 0x2a,
	0xc6, 0xb1, 0x69, 0x98, 0xc7, 0x2d, 0x73, 0x24, 0x99, 0xba, 0x33, 0xb1, 0xa9, 0xe1, 0xbe, 0x7f,
	0x38, 0x36, 0xf4, 0x7d, 0x32, 0x71, 0x71, 0x44, 0x85, 0xb6, 0x61, 0xc1, 0x30, 0x6d, 0xdf, 0x73,
	0x6b, 0xa5, 0x46, 0x71, 0x26, 0x6f, 0x42, 0x7d, 0x24, 0x03, 0xe8, 0x96, 0x39, 0x62, 0x5b, 0x72,
	0x6b, 0xf3, 0x0c, 0x7d, 0x2b, 0x0f, 0xdd, 0x8e, 0xb4, 0x77, 0x0a, 0x35, 0x0e, 0xa7, 0xc0, 0xe8,
	0x31, 0x54, 0x75, 0xcb, 0x74, 0x8d, 0x11, 0x71, 0xb4, 0x80, 0x6e, 0x81, 0xd1, 0xdd, 0x7e, 0x0f,
	0x5d, 0x82, 0xc0, 0x19, 0x02, 0x74, 0x1f, 0xca, 0x0e, 0xd1, 0x0d, 0x4f, 0x1b, 0xbb, 0xb5, 0x45,
	0x46, 0x76, 0x23, 0x8f, 0x0c, 0x07, 0xba, 0x38, 0x06, 0xa1, 0x5b, 0x50, 0xf5, 0x8c, 0x13, 0xe2,
	0xaa, 0xe4, 0x05, 0xd1, 0x7d, 0x8f, 0x8c, 0x6a, 0xe5, 0x06, 0xb7, 0x3e, 0x8f, 0x97, 0x99, 0x54,
	0x0a, 0x85, 0x68, 0x17, 0xc0, 0xf5, 0x34, 0xc7, 0x53, 0xa9, 0xb8, 0xc6, 0xb3, 0x8b, 0xc9, 0x3d,
	0x85, 0x01, 0x85, 0x7b, 0xda, 0x89, 0x8d, 0x79, 0x06, 0xa4, 0x73, 0x54, 0x83, 0x45, 0xdd, 0x32,
	0x3d, 0xf2, 0xc2, 0xab, 0x41, 0x83, 0x5b, 0xaf, 0xe0, 0x68, 0x2a, 0x7e, 0x5d, 0x80, 0xea, 0x74,
	0x28, 0x21, 0x04, 0x25, 0x53, 0x3b, 0x21, 0x2c, 0x08, 0x79, 0xcc, 0xc6, 0xe8, 0x31, 0xac, 0x38,
	0xc4, 0xb5, 0x7c, 0x47, 0x27, 0xea, 0xd8, 0xd2, 0xd9, 0x21, 0x84, 0xf1, 0x75, 0x33, 0xcf, 0x9b,
	0x4e, 0xa8, 0x8b, 0x85, 0x08, 0x1e, 0x49, 0x50, 0x1b, 0x78, 0xd7, 0x38, 0x36, 0x35, 0xcf, 0x77,
	0x48, 0x18, 0x71, 0xb7, 0xde, 0x17, 0x71, 0x4c, 0x19, 0x27, 0x38, 0xb4, 0x03, 0x25, 0x6f, 0x62,
	0x93, 0x5a, 0xa9, 0xc1, 0xad, 0x57, 0xb7, 0x9a, 0xb3, 0x27, 0xcc, 0x60, 0x62, 0x13, 0xcc, 0xb0,
	0x22, 0x81, 0x12, 0x0d, 0xbc, 0x33, 0xf7, 0x2d, 0xc3, 0x32, 0xe5, 0xf8, 0xb0, 0x3d, 0x57, 0xa8,
	0x34, 0x9a, 0x89, 0x5f, 0x01, 0x1f, 0x47, 0x28, 0xbd, 0xfd, 0x38, 0x3e, 0xd5, 0x94, 0xd5, 0xe5,
	0x58, 0xda, 0xa5, 0xe6, 0xdb, 0xb0, 0xe0, 0x10, 0xd7, 0x1f, 0x7b, 0xa1, 0xdd, 0xff, 0xe6, 0xd9,
	0x0d, 0x62, 0x86, 0x1a, 0x66, 0x10, 0x1c, 0x42, 0xc5, 0xdf, 0x38, 0x58, 0x9e, 0x0a, 0x66, 0x74,
	0x07, 0xd0, 0x54, 0x38, 0xa7, 0x3d, 0x58, 0x99, 0x5a, 0x61, 0x5e, 0x3c, 0x88, 0x73, 0xb8, 0xc0,
	0x22, 0x7d, 0x3d, 0xcf, 0x8b, 0xbe, 0x63, 0xd9, 0x96, 0x4b, 0x46, 0x53, 0xb9, 0x9c, 0xec, 0xa3,
	0xf8, 0xe1, 0xfb, 0xf8, 0x91, 0x83, 0x4a, 0x9a, 0xfd, 0xcc, 0x0b, 0x43, 0x50, 0x7a, 0xa6, 0xb9,
	0xcf, 0xd8, 0x79, 0xf1, 0x98, 0x8d, 0xd1, 0x75, 0xe0, 0xf5, 0xb1, 0xe6, 0xba, 0x4c, 0xb9, 0xc8,
	0x16, 0x12, 0x01, 0xda, 0x87, 0x32, 0x75, 0xc3, 0xf5, 0x2c, 0x87, 0x85, 0xd1, 0xd2, 0xd6, 0xe6,
	0x7b, 0xf6, 0x17, 0x2e, 0x61, 0x72, 0x44, 0x1c, 0x42, 0x07, 0x31, 0x81, 0xf8, 0x6d, 0x01, 0x2e,
	0x65, 0xfc, 0xa7, 0xc7, 0x67, 0xf9, 0x9e, 0xed, 0x7b, 0x61, 0x59, 0x3f, 0xc7, 0xf1, 0x05, 0x38,
	0xf4, 0x70, 0x2a, 0x0c, 0xaa, 0xf9, 0x0e, 0x66, 0xcc, 0xb3, 0x40, 0x0f, 0xe1, 0x68, 0x0f, 0x96,
	0x1c, 0xa2, 0x5b, 0xce, 0x88, 0x8c, 0x54, 0xcd, 0x9b, 0x25, 0xeb, 0x92, 0x72, 0x02, 0x11, 0xb2,
	0xe5, 0xa1, 0x1b, 0xb0, 0x4c, 0x1c, 0xc7, 0x72, 0xd4, 0x13, 0xe2, 0xba, 0xda, 0x71, 0x90, 0x7f,
	0x3c, 0xae, 0x30, 0xe1, 0xa3, 0x40, 0x26, 0xca, 0x50, 0xc6, 0x51, 0xb5, 0xbb, 0x07, 0x8b, 0xb6,
	0xe6, 0x78, 0x06, 0x71, 0x6b, 0xdc, 0xec, 0xd5, 0x32, 0xc2, 0x88, 0xbf, 0x70, 0xb0, 0x18, 0x0a,
	0xe9, 0x1e, 0x68, 0xfe, 0x13, 0x47, 0x75, 0xac, 0x71, 0x70, 0xf9, 0xd5, 0xfc, 0x3d, 0xf4, 0x35,
	0xc7, 0x9b, 0xb0, 0x73, 0x80, 0x00, 0x89, 0xad, 0x31, 0x41, 0x18, 0x16, 0x82, 0x59, 0x98, 0x5b,
	0x7f, 0xe7, 0xb9, 0x0b, 0x99, 0x68, 0x9d, 0xd5, 0x46, 0x23, 0x87, 0xb8, 0x2e, 0x3b, 0xdb, 0x0a,
	0x8e, 0xa6, 0xe2, 0x73, 0x28, 0xc7, 0x95, 0xaf, 0x05, 0x45, 0x87, 0x1c, 0x85, 0xd1, 0x70, 0xee,
	0x60, 0xa3, 0xd8, 0xe9, 0x90, 0x2e, 0x64, 0x42, 0x9a, 0x1e, 0xd7, 0xea, 0x19, 0x50, 0x74, 0x1f,
	0xc0, 0xd5, 0x2d, 0x9b, 0xa8, 0xbe, 0x6f, 0x8c, 0x42, 0xfb, 0xb9, 0x0f, 0xf2, 0x70, 0x28, 0xef,
	0x62, 0x9e, 0x61, 0x86, 0xbe, 0x31, 0xa2, 0x04, 0xc7, 0x8e, 0xe5, 0xdb, 0x01, 0x41, 0x61, 0x56,
	0x02, 0x86, 0x61, 0x04, 0x51, 0x7a, 0x16, 0x53, 0xe9, 0x19, 0xa5, 0x71, 0x29, 0x49, 0x63, 0x71,
	0x08, 0x95, 0xb8, 0xde, 0x2b, 0xc4, 0x43, 0x12, 0x40, 0x5c, 0xf4, 0xa3, 0x10, 0x9a, 0xf1, 0xb5,
	0x48, 0x01, 0xc5, 0x97, 0x1c, 0xf0, 0xf1, 0x0a, 0x35, 0xac, 0x8d, 0x8f, 0xad, 0xa8, 0x7e, 0xd0,
	0x31, 0xba, 0x06, 0x65, 0xca, 0x4a, 0x0b, 0x60, 0x78, 0xae, 0xf1, 0x9c, 0x1e, 0xfa, 0xf4, 0x8b,
	0xc5, 0xa7, 0x9f, 0xa2, 0x24, 0x9e, 0x4a, 0x17, 0x15, 0x4f, 0xe2, 0x2b, 0x0e, 0xea, 0xf9, 0xaa,
	0x48, 0x01, 0xe4, 0x06, 0x1a, 0xaa, 0xcd, 0xa4, 0xea, 0x73, 0x32, 0x09, 0xef, 0x36, 0x3f, 0x2b,
	0x22, 0x0e, 0x2c, 0x84, 0x04, 0xb1, 0x04, 0x3d, 0x85, 0x2b, 0x24, 0x36, 0x96, 0xe6, 0x2d, 0x9c,
	0x87, 0x77, 0x95, 0xbc, 0xed, 0xb0, 0xf8, 0x13, 0x07, 0x7c, 0x62, 0x68, 0x1d, 0x84, 0x84, 0x5d,
	0x3d, 0x9c, 0x78, 0xec, 0x76, 0x69, 0xe6, 0x54, 0xed, 0x48, 0x69, 0x87, 0x4a, 0xd1, 0xbd, 0xf0,
	0xa5, 0x0f, 0x2a, 0xe0, 0xed, 0x99, 0x3c, 0x48, 0x1e, 0x79, 0xf4, 0x00, 0xe6, 0x75, 0xdf, 0x39,
	0x0d, 0xee, 0xad, 0x9a, 0xdf, 0x5a, 0xc7, 0xf8, 0x36, 0x45, 0xe0, 0x00, 0x28, 0x5e, 0x87, 0x12,
	0x8d, 0x66, 0x74, 0x19, 0xe6, 0x4f, 0xb5, 0xb1, 0x1f, 0x3d, 0x3b, 0xc1, 0x44, 0xfc, 0x14, 0xf8,
	0xb8, 0x54, 0xd2, 0x32, 0xe0, 0x12, 0xfa, 0x92, 0x07, 0x9b, 0x29, 0xe2, 0x68, 0x4a, 0xc1, 0xa6,
	0x66, 0x5a, 0x2e, 0xdb, 0xc6, 0x3c, 0x0e, 0x26, 0xe2, 0xcb, 0x22, 0x54, 0xa2, 0x2f, 0x01, 0xd6,
	0x82, 0x5d, 0xe4, 0xd7, 0xc0, 0x3e, 0x2c, 0xb1, 0x57, 0x58, 0xa5, 0x5d, 0x7e, 0xf4, 0x84, 0x9f,
	0x8b, 0x8c, 0xc1, 0xe9, 0xd0, 0x45, 0x7d, 0x10, 0xc2, 0x9a, 0xac, 0xd2, 0x0e, 0x7f, 0x7c, 0x4a,
	0x46, 0xb5, 0x62, 0xa3, 0x38, 0x7b, 0x05, 0xbe, 0x14, 0xc2, 0xe5, 0x10, 0x8d, 0x30, 0x5c, 0x4a,
	0x3a, 0xa1, 0xc0, 0xc5, 0xd2, 0x4c, 0xcd, 0xf9, 0x28, 0xf1, 0x30, 0xe9, 0xa5, 0x02, 0x2f, 0xbf,
	0x84, 0xd5, 0xe9, 0xfe, 0x26, 0xe0, 0x0d, 0xbe, 0x21, 0xee, 0xcc, 0xdc, 0xf4, 0x33, 0xee, 0xe9,
	0x4e, 0x89, 0xf1, 0x8b, 0xbf, 0x06, 0x1d, 0x55, 0x62, 0x12, 0xfd, 0x0b, 0xf8, 0x23, 0xdf, 0xd4,
	0xd3, 0x8d, 0x54, 0x99, 0x0a, 0xba, 0x41, 0x87, 0x71, 0x81, 0x37, 0xf0, 0x10, 0x96, 0x82, 0xae,
	0x80, 0xb1, 0x85, 0x4f, 0xf8, 0x7f, 0xf2, 0xc8, 0x7a, 0x4c, 0x3d, 0x20, 0xb2, 0xe2, 0xb1, 0xf8,
	0x7d, 0x01, 0x56, 0xde, 0xda, 0x6e, 0xfe, 0x46, 0x30, 0xfb, 0x0a, 0xb0, 0x29, 0xe8, 0x70, 0x4c,
	0x54, 0x7a, 0x95, 0x93, 0x30, 0x21, 0x67, 0xbc, 0x7e, 0x21, 0x85, 0x67, 0xd2, 0xec, 0xe1, 0x14,
	0x2f, 0xf2, 0x70, 0x4a, 0x1f, 0x7c, 0x38, 0x1d, 0x80, 0x64, 0x05, 0x7d, 0x16, 0x7e, 0x50, 0x9f,
	0x3f, 0x11, 0x19, 0x6e, 0xe3, 0x07, 0x0e, 0xd0, 0xdb, 0x9f, 0x1f, 0xa8, 0x01, 0xd7, 0x77, 0xa5,
	0x3d, 0xb9, 0x2b, 0x0f, 0xe4, 0x5e, 0x57, 0x55, 0xfa, 0x52, 0x5b, 0x1d, 0x3c, 0xed, 0x4b, 0xea,
	0xb0, 0xbb, 0xdf, 0xed, 0x3d, 0xe9, 0x0a, 0x73, 0xe8, 0xdf, 0xb0, 0x76, 0xa6, 0x46, 0x1f, 0xf7,
	0xfa, 0x3d, 0x45, 0xda, 0x15, 0x38, 0xb4, 0x06, 0x57, 0xcf, 0x54, 0xd9, 0x6b, 0xb5, 0x07, 0x42,
	0x01, 0x89, 0x50, 0x7f, 0xe7, 0xb2, 0xda, 0x91, 0x95, 0x81, 0x50, 0xdc, 0xb8, 0x0d, 0xd5, 0xe9,
	0x92, 0x87, 0x96, 0x81, 0x57, 0xa4, 0x76, 0x7f, 0xeb, 0xa3, 0x8f, 0xf7, 0xef, 0x0a, 0x73, 0xa8,
	0x0c, 0x25, 0x3a, 0x16, 0xb8, 0x8d, 0x35, 0x58, 0x9e, 0xaa, 0xae, 0xa8, 0x02, 0x65, 0xa9, 0xd3,
	0x91, 0xfb, 0x03, 0xb9, 0x2d, 0xcc, 0x6d, 0xd8, 0xb0, 0x7a, 0x46, 0xfb, 0x89, 0xfe, 0x09, 0xab,
	0x58, 0x52, 0x86, 0x9d, 0x41, 0x76, 0x7f, 0x97, 0x41, 0x48, 0x2f, 0xf4, 0x5b, 0x8a, 0x22, 0x70,
	0x59, 0xa9, 0xb2, 0x2f, 0xf7, 0x85, 0x42, 0x56, 0xba, 0xd7, 0x92, 0x3b, 0x42, 0x71, 0xe3, 0xe7,
	0x02, 0xf0, 0x71, 0x78, 0xa1, 0x7f, 0x00, 0xea, 0xb7, 0xf0, 0xe0, 0x69, 0xd6, 0xce, 0x55, 0xb8,
	0x92, 0x92, 0xf7, 0xb0, 0xfc, 0x50, 0xee, 0xb6, 0x06, 0x3d, 0x2c, 0x70, 0xd4, 0xb7, 0xd4, 0x92,
	0x22, 0xe1, 0x03, 0xb9, 0x2d, 0x61, 0xa1, 0x90, 0x59, 0x90, 0xbb, 0x07, 0x92, 0x42, 0x11, 0x45,
	0x54, 0x83, 0xcb, 0xa9, 0x85, 0xf6, 0x50, 0x19, 0xf4, 0x76, 0xe5, 0x56, 0x57, 0x28, 0x51, 0x17,
	0xd3, 0x66, 0x9e, 0x74, 0x25, 0x2c, 0xcc, 0x67, 0xf4, 0x5b, 0x7b, 0x7b, 0x72, 0x47, 0x6e, 0x0d,
	0x24, 0x61, 0x21, 0xe3, 0x6e, 0xef, 0x51, 0x57, 0xde, 0x19, 0x2a, 0xc2, 0x62, 0xc6, 0xdd, 0x3e,
	0xee, 0x1d, 0x48, 0xdd, 0x56, 0xb7, 0x2d, 0x09, 0x65, 0x74, 0x05, 0x56, 0x52, 0x4b, 0x8f, 0x5a,
	0x78, 0x5f, 0xc2, 0x02, 0x9f, 0x41, 0xb4, 0x7b, 0xdd, 0x01, 0xee, 0x75, 0x3a, 0x12, 0x16, 0x20,
	0x63, 0xfe, 0xa0, 0xd5, 0x91, 0x77, 0xd9, 0xd6, 0x97, 0x76, 0xdc, 0xdf, 0x5f, 0xd7, 0xb9, 0x57,
	0xaf, 0xeb, 0xdc, 0x9f, 0xaf, 0xeb, 0xdc, 0x77, 0x6f, 0xea, 0x73, 0xaf, 0xde, 0xd4, 0xe7, 0xfe,
	0x78, 0x53, 0x9f, 0x83, 0x35, 0xc3, 0xca, 0x09, 0xf2, 0x3e, 0xf7, 0xc5, 0xf6, 0xb1, 0xe1, 0x3d,
	0xf3, 0x0f, 0x9b, 0xba, 0x75, 0xb2, 0x99, 0x28, 0xde, 0x31, 0xac, 0xd4, 0x6c, 0xf3, 0x45, 0xf2,
	0xc7, 0x18, 0x7d, 0x83, 0xdd, 0x4d, 0x7b, 0x9b, 0x1c, 0x2e, 0xb0, 0x3f, 0xc6, 0xfe, 0xf7, 0x57,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x04, 0xac, 0x81, 0xae, 0x40, 0x13, 0x00, 0x00,
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x52
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TimesExecuted != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.TimesExecuted))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Recitals) > 0 {
		for iNdEx := len(m.Recitals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recitals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Considerations) > 0 {
		for iNdEx := len(m.Considerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Considerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Invoker != nil {
		{
			size, err := m.Invoker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefinitionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefinitionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefinitionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ResourceLocation != nil {
		{
			size, err := m.ResourceLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Fact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataLocation != nil {
		{
			size, err := m.DataLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConditionName) > 0 {
		i -= len(m.ConditionName)
		copy(dAtA[i:], m.ConditionName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ConditionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Consideration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Consideration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Consideration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ConsiderationName) > 0 {
		i -= len(m.ConsiderationName)
		copy(dAtA[i:], m.ConsiderationName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ConsiderationName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposedFact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposedFact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposedFact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ancestor != nil {
		{
			size, err := m.Ancestor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if m.RecordedAt != nil {
		{
			size, err := m.RecordedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Recitals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recitals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recitals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parties) > 0 {
		for iNdEx := len(m.Parties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Recital) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recital) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recital) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SignerRole != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.SignerRole))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvenanceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvenanceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvenanceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupUuid != nil {
		{
			size, err := m.GroupUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ScopeUuid != nil {
		{
			size, err := m.ScopeUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Algo) > 0 {
		i -= len(m.Algo)
		copy(dAtA[i:], m.Algo)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Algo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningAndEncryptionPublicKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningAndEncryptionPublicKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningAndEncryptionPublicKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptionPublicKey != nil {
		{
			size, err := m.EncryptionPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SigningPublicKey != nil {
		{
			size, err := m.SigningPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Curve != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Curve))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicKeyBytes) > 0 {
		i -= len(m.PublicKeyBytes)
		copy(dAtA[i:], m.PublicKeyBytes)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.PublicKeyBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsiderationSpecs) > 0 {
		for iNdEx := len(m.ConsiderationSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsiderationSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ConditionSpecs) > 0 {
		for iNdEx := len(m.ConditionSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConditionSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PartiesInvolved) > 0 {
		dAtA21 := make([]byte, len(m.PartiesInvolved)*10)
		var j20 int
		for _, num := range m.PartiesInvolved {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintP8E(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSpec != nil {
		{
			size, err := m.OutputSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FuncName) > 0 {
		i -= len(m.FuncName)
		copy(dAtA[i:], m.FuncName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.FuncName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsiderationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsiderationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsiderationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSpec != nil {
		{
			size, err := m.OutputSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ResponsibleParty != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.ResponsibleParty))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FuncName) > 0 {
		i -= len(m.FuncName)
		copy(dAtA[i:], m.FuncName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.FuncName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintP8E(dAtA []byte, offset int, v uint64) int {
	offset -= sovP8E(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Invoker != nil {
		l = m.Invoker.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Considerations) > 0 {
		for _, e := range m.Considerations {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Recitals) > 0 {
		for _, e := range m.Recitals {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.TimesExecuted != 0 {
		n += 1 + sovP8E(uint64(m.TimesExecuted))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *DefinitionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.ResourceLocation != nil {
		l = m.ResourceLocation.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovP8E(uint64(m.Type))
	}
	return n
}

func (m *Fact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.DataLocation != nil {
		l = m.DataLocation.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConditionName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Consideration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsiderationName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ProposedFact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Ancestor != nil {
		l = m.Ancestor.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ExecutionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovP8E(uint64(m.Result))
	}
	if m.RecordedAt != nil {
		l = m.RecordedAt.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Recitals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parties) > 0 {
		for _, e := range m.Parties {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *Recital) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignerRole != 0 {
		n += 1 + sovP8E(uint64(m.SignerRole))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ProvenanceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopeUuid != nil {
		l = m.ScopeUuid.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.GroupUuid != nil {
		l = m.GroupUuid.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *SignatureSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *SigningAndEncryptionPublicKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningPublicKey != nil {
		l = m.SigningPublicKey.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.EncryptionPublicKey != nil {
		l = m.EncryptionPublicKey.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKeyBytes)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovP8E(uint64(m.Type))
	}
	if m.Curve != 0 {
		n += 1 + sovP8E(uint64(m.Curve))
	}
	return n
}

func (m *UUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovP8E(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovP8E(uint64(m.Nanos))
	}
	return n
}

func (m *ContractSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.PartiesInvolved) > 0 {
		l = 0
		for _, e := range m.PartiesInvolved {
			l += sovP8E(uint64(e))
		}
		n += 1 + sovP8E(uint64(l)) + l
	}
	if len(m.ConditionSpecs) > 0 {
		for _, e := range m.ConditionSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.ConsiderationSpecs) > 0 {
		for _, e := range m.ConsiderationSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *ConditionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.OutputSpec != nil {
		l = m.OutputSpec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ConsiderationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.ResponsibleParty != 0 {
		n += 1 + sovP8E(uint64(m.ResponsibleParty))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.OutputSpec != nil {
		l = m.OutputSpec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *OutputSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func sovP8E(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozP8E(x uint64) (n int) {
	return sovP8E(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &DefinitionSpec{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Fact{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoker == nil {
				m.Invoker = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Invoker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &Fact{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Considerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Considerations = append(m.Considerations, &Consideration{})
			if err := m.Considerations[len(m.Considerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recitals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recitals = append(m.Recitals, &Recital{})
			if err := m.Recitals[len(m.Recitals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimesExecuted", wireType)
			}
			m.TimesExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimesExecuted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefinitionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefinitionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefinitionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLocation == nil {
				m.ResourceLocation = &Location{}
			}
			if err := m.ResourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DefinitionSpecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataLocation == nil {
				m.DataLocation = &Location{}
			}
			if err := m.DataLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &ExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Consideration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Consideration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Consideration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &ProposedFact{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &ExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposedFact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposedFact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposedFact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ancestor == nil {
				m.Ancestor = &ProvenanceReference{}
			}
			if err := m.Ancestor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &ProposedFact{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ExecutionResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecordedAt == nil {
				m.RecordedAt = &Timestamp{}
			}
			if err := m.RecordedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recitals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recitals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recitals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parties = append(m.Parties, &Recital{})
			if err := m.Parties[len(m.Parties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recital) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recital: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recital: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerRole", wireType)
			}
			m.SignerRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignerRole |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ProvenanceReference{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvenanceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvenanceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvenanceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeUuid == nil {
				m.ScopeUuid = &UUID{}
			}
			if err := m.ScopeUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupUuid == nil {
				m.GroupUuid = &UUID{}
			}
			if err := m.GroupUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningAndEncryptionPublicKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningPublicKey == nil {
				m.SigningPublicKey = &PublicKey{}
			}
			if err := m.SigningPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionPublicKey == nil {
				m.EncryptionPublicKey = &PublicKey{}
			}
			if err := m.EncryptionPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBytes = append(m.PublicKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyBytes == nil {
				m.PublicKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PublicKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			m.Curve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curve |= PublicKeyCurve(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &DefinitionSpec{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &DefinitionSpec{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v PartyType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowP8E
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PartyType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartiesInvolved = append(m.PartiesInvolved, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowP8E
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthP8E
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthP8E
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PartiesInvolved) == 0 {
					m.PartiesInvolved = make([]PartyType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PartyType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowP8E
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PartyType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartiesInvolved = append(m.PartiesInvolved, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiesInvolved", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionSpecs = append(m.ConditionSpecs, &ConditionSpec{})
			if err := m.ConditionSpecs[len(m.ConditionSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationSpecs = append(m.ConsiderationSpecs, &ConsiderationSpec{})
			if err := m.ConsiderationSpecs[len(m.ConsiderationSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &DefinitionSpec{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSpec == nil {
				m.OutputSpec = &OutputSpec{}
			}
			if err := m.OutputSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsiderationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsiderationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsiderationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsibleParty", wireType)
			}
			m.ResponsibleParty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponsibleParty |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &DefinitionSpec{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSpec == nil {
				m.OutputSpec = &OutputSpec{}
			}
			if err := m.OutputSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DefinitionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipP8E(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthP8E
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupP8E
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthP8E
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthP8E        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowP8E          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupP8E = fmt.Errorf("proto: unexpected end of group")
)
