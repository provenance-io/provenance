// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/p8e/p8e.proto

package p8e

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Deprecated: Do not use.
type DefinitionSpecType int32 // Deprecated: Do not use.
const (
	// Deprecated: Do not use.
	DefinitionSpecType_DEFINITION_SPEC_TYPE_UNKNOWN DefinitionSpecType = 0
	// Deprecated: Do not use.
	DefinitionSpecType_DEFINITION_SPEC_TYPE_PROPOSED DefinitionSpecType = 1
	// Deprecated: Do not use.
	DefinitionSpecType_DEFINITION_SPEC_TYPE_FACT DefinitionSpecType = 2
	// Deprecated: Do not use.
	DefinitionSpecType_DEFINITION_SPEC_TYPE_FACT_LIST DefinitionSpecType = 3
)

var DefinitionSpecType_name = map[int32]string{
	0: "DEFINITION_SPEC_TYPE_UNKNOWN",
	1: "DEFINITION_SPEC_TYPE_PROPOSED",
	2: "DEFINITION_SPEC_TYPE_FACT",
	3: "DEFINITION_SPEC_TYPE_FACT_LIST",
}

var DefinitionSpecType_value = map[string]int32{
	"DEFINITION_SPEC_TYPE_UNKNOWN":   0,
	"DEFINITION_SPEC_TYPE_PROPOSED":  1,
	"DEFINITION_SPEC_TYPE_FACT":      2,
	"DEFINITION_SPEC_TYPE_FACT_LIST": 3,
}

func (x DefinitionSpecType) String() string {
	return proto.EnumName(DefinitionSpecType_name, int32(x))
}

func (DefinitionSpecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{0}
}

// Deprecated: Do not use.
type PublicKeyCurve int32 // Deprecated: Do not use.
const (
	// Deprecated: Do not use.
	PublicKeyCurve_SECP256K1 PublicKeyCurve = 0
	// Deprecated: Do not use.
	PublicKeyCurve_P256 PublicKeyCurve = 1
)

var PublicKeyCurve_name = map[int32]string{
	0: "SECP256K1",
	1: "P256",
}

var PublicKeyCurve_value = map[string]int32{
	"SECP256K1": 0,
	"P256":      1,
}

func (x PublicKeyCurve) String() string {
	return proto.EnumName(PublicKeyCurve_name, int32(x))
}

func (PublicKeyCurve) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{1}
}

// Deprecated: Do not use.
type PublicKeyType int32 // Deprecated: Do not use.
const (
	// Deprecated: Do not use.
	PublicKeyType_ELLIPTIC PublicKeyType = 0
)

var PublicKeyType_name = map[int32]string{
	0: "ELLIPTIC",
}

var PublicKeyType_value = map[string]int32{
	"ELLIPTIC": 0,
}

func (x PublicKeyType) String() string {
	return proto.EnumName(PublicKeyType_name, int32(x))
}

func (PublicKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{2}
}

// Deprecated: Do not use.
type ExecutionResultType int32 // Deprecated: Do not use.
const (
	// Deprecated: Do not use.
	ExecutionResultType_RESULT_TYPE_UNKNOWN ExecutionResultType = 0
	// Deprecated: Do not use.
	ExecutionResultType_RESULT_TYPE_PASS ExecutionResultType = 1
	// Deprecated: Do not use.
	ExecutionResultType_RESULT_TYPE_SKIP ExecutionResultType = 2
	// Deprecated: Do not use.
	ExecutionResultType_RESULT_TYPE_FAIL ExecutionResultType = 3
)

var ExecutionResultType_name = map[int32]string{
	0: "RESULT_TYPE_UNKNOWN",
	1: "RESULT_TYPE_PASS",
	2: "RESULT_TYPE_SKIP",
	3: "RESULT_TYPE_FAIL",
}

var ExecutionResultType_value = map[string]int32{
	"RESULT_TYPE_UNKNOWN": 0,
	"RESULT_TYPE_PASS":    1,
	"RESULT_TYPE_SKIP":    2,
	"RESULT_TYPE_FAIL":    3,
}

func (x ExecutionResultType) String() string {
	return proto.EnumName(ExecutionResultType_name, int32(x))
}

func (ExecutionResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{3}
}

// Deprecated: Do not use.
type PartyType int32 // Deprecated: Do not use.
const (
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_UNKNOWN PartyType = 0
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_ORIGINATOR PartyType = 1
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_SERVICER PartyType = 2
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_INVESTOR PartyType = 3
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_CUSTODIAN PartyType = 4
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_OWNER PartyType = 5
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_AFFILIATE PartyType = 6
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_OMNIBUS PartyType = 7
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_PROVENANCE PartyType = 8
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_MARKER PartyType = 9
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_CONTROLLER PartyType = 10
	// Deprecated: Do not use.
	PartyType_PARTY_TYPE_VALIDATOR PartyType = 11
)

var PartyType_name = map[int32]string{
	0:  "PARTY_TYPE_UNKNOWN",
	1:  "PARTY_TYPE_ORIGINATOR",
	2:  "PARTY_TYPE_SERVICER",
	3:  "PARTY_TYPE_INVESTOR",
	4:  "PARTY_TYPE_CUSTODIAN",
	5:  "PARTY_TYPE_OWNER",
	6:  "PARTY_TYPE_AFFILIATE",
	7:  "PARTY_TYPE_OMNIBUS",
	8:  "PARTY_TYPE_PROVENANCE",
	9:  "PARTY_TYPE_MARKER",
	10: "PARTY_TYPE_CONTROLLER",
	11: "PARTY_TYPE_VALIDATOR",
}

var PartyType_value = map[string]int32{
	"PARTY_TYPE_UNKNOWN":    0,
	"PARTY_TYPE_ORIGINATOR": 1,
	"PARTY_TYPE_SERVICER":   2,
	"PARTY_TYPE_INVESTOR":   3,
	"PARTY_TYPE_CUSTODIAN":  4,
	"PARTY_TYPE_OWNER":      5,
	"PARTY_TYPE_AFFILIATE":  6,
	"PARTY_TYPE_OMNIBUS":    7,
	"PARTY_TYPE_PROVENANCE": 8,
	"PARTY_TYPE_MARKER":     9,
	"PARTY_TYPE_CONTROLLER": 10,
	"PARTY_TYPE_VALIDATOR":  11,
}

func (x PartyType) String() string {
	return proto.EnumName(PartyType_name, int32(x))
}

func (PartyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{4}
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Contract struct {
	Definition     *DefinitionSpec                 `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
	Spec           *Fact                           `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	Invoker        *SigningAndEncryptionPublicKeys `protobuf:"bytes,3,opt,name=invoker,proto3" json:"invoker,omitempty"`
	Inputs         []*Fact                         `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Conditions     []*Condition                    `protobuf:"bytes,5,rep,name=conditions,proto3" json:"conditions,omitempty"` // Deprecated: Do not use.
	Considerations []*Consideration                `protobuf:"bytes,6,rep,name=considerations,proto3" json:"considerations,omitempty"`
	Recitals       []*Recital                      `protobuf:"bytes,7,rep,name=recitals,proto3" json:"recitals,omitempty"`
	TimesExecuted  int32                           `protobuf:"varint,8,opt,name=times_executed,json=timesExecuted,proto3" json:"times_executed,omitempty"`
	StartTime      *Timestamp                      `protobuf:"bytes,9,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	Context        []byte                          `protobuf:"bytes,10,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{0}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetDefinition() *DefinitionSpec {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *Contract) GetSpec() *Fact {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Contract) GetInvoker() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Invoker
	}
	return nil
}

func (m *Contract) GetInputs() []*Fact {
	if m != nil {
		return m.Inputs
	}
	return nil
}

// Deprecated: Do not use.
func (m *Contract) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Contract) GetConsiderations() []*Consideration {
	if m != nil {
		return m.Considerations
	}
	return nil
}

func (m *Contract) GetRecitals() []*Recital {
	if m != nil {
		return m.Recitals
	}
	return nil
}

func (m *Contract) GetTimesExecuted() int32 {
	if m != nil {
		return m.TimesExecuted
	}
	return 0
}

func (m *Contract) GetStartTime() *Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Contract) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type DefinitionSpec struct {
	Name             string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ResourceLocation *Location          `protobuf:"bytes,2,opt,name=resource_location,json=resourceLocation,proto3" json:"resource_location,omitempty"`
	Signature        *Signature         `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Type             DefinitionSpecType `protobuf:"varint,4,opt,name=type,proto3,enum=provenance.metadata.v1.p8e.DefinitionSpecType" json:"type,omitempty"`
}

func (m *DefinitionSpec) Reset()         { *m = DefinitionSpec{} }
func (m *DefinitionSpec) String() string { return proto.CompactTextString(m) }
func (*DefinitionSpec) ProtoMessage()    {}
func (*DefinitionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{1}
}
func (m *DefinitionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefinitionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefinitionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefinitionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefinitionSpec.Merge(m, src)
}
func (m *DefinitionSpec) XXX_Size() int {
	return m.Size()
}
func (m *DefinitionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DefinitionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DefinitionSpec proto.InternalMessageInfo

func (m *DefinitionSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DefinitionSpec) GetResourceLocation() *Location {
	if m != nil {
		return m.ResourceLocation
	}
	return nil
}

func (m *DefinitionSpec) GetSignature() *Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DefinitionSpec) GetType() DefinitionSpecType {
	if m != nil {
		return m.Type
	}
	return DefinitionSpecType_DEFINITION_SPEC_TYPE_UNKNOWN
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Fact struct {
	Name         string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DataLocation *Location `protobuf:"bytes,2,opt,name=data_location,json=dataLocation,proto3" json:"data_location,omitempty"`
}

func (m *Fact) Reset()         { *m = Fact{} }
func (m *Fact) String() string { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()    {}
func (*Fact) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{2}
}
func (m *Fact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fact.Merge(m, src)
}
func (m *Fact) XXX_Size() int {
	return m.Size()
}
func (m *Fact) XXX_DiscardUnknown() {
	xxx_messageInfo_Fact.DiscardUnknown(m)
}

var xxx_messageInfo_Fact proto.InternalMessageInfo

func (m *Fact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Fact) GetDataLocation() *Location {
	if m != nil {
		return m.DataLocation
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Condition struct {
	ConditionName string           `protobuf:"bytes,1,opt,name=condition_name,json=conditionName,proto3" json:"condition_name,omitempty"`
	Result        *ExecutionResult `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{3}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetConditionName() string {
	if m != nil {
		return m.ConditionName
	}
	return ""
}

func (m *Condition) GetResult() *ExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Consideration struct {
	ConsiderationName string           `protobuf:"bytes,1,opt,name=consideration_name,json=considerationName,proto3" json:"consideration_name,omitempty"`
	Inputs            []*ProposedFact  `protobuf:"bytes,2,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Result            *ExecutionResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Consideration) Reset()         { *m = Consideration{} }
func (m *Consideration) String() string { return proto.CompactTextString(m) }
func (*Consideration) ProtoMessage()    {}
func (*Consideration) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{4}
}
func (m *Consideration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Consideration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Consideration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Consideration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Consideration.Merge(m, src)
}
func (m *Consideration) XXX_Size() int {
	return m.Size()
}
func (m *Consideration) XXX_DiscardUnknown() {
	xxx_messageInfo_Consideration.DiscardUnknown(m)
}

var xxx_messageInfo_Consideration proto.InternalMessageInfo

func (m *Consideration) GetConsiderationName() string {
	if m != nil {
		return m.ConsiderationName
	}
	return ""
}

func (m *Consideration) GetInputs() []*ProposedFact {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Consideration) GetResult() *ExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type ProposedFact struct {
	Name      string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hash      string               `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Classname string               `protobuf:"bytes,3,opt,name=classname,proto3" json:"classname,omitempty"`
	Ancestor  *ProvenanceReference `protobuf:"bytes,4,opt,name=ancestor,proto3" json:"ancestor,omitempty"`
}

func (m *ProposedFact) Reset()         { *m = ProposedFact{} }
func (m *ProposedFact) String() string { return proto.CompactTextString(m) }
func (*ProposedFact) ProtoMessage()    {}
func (*ProposedFact) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{5}
}
func (m *ProposedFact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposedFact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposedFact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposedFact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposedFact.Merge(m, src)
}
func (m *ProposedFact) XXX_Size() int {
	return m.Size()
}
func (m *ProposedFact) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposedFact.DiscardUnknown(m)
}

var xxx_messageInfo_ProposedFact proto.InternalMessageInfo

func (m *ProposedFact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProposedFact) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProposedFact) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

func (m *ProposedFact) GetAncestor() *ProvenanceReference {
	if m != nil {
		return m.Ancestor
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type ExecutionResult struct {
	Output       *ProposedFact       `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Result       ExecutionResultType `protobuf:"varint,2,opt,name=result,proto3,enum=provenance.metadata.v1.p8e.ExecutionResultType" json:"result,omitempty"`
	RecordedAt   *Timestamp          `protobuf:"bytes,3,opt,name=recorded_at,json=recordedAt,proto3" json:"recorded_at,omitempty"`
	ErrorMessage string              `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *ExecutionResult) Reset()         { *m = ExecutionResult{} }
func (m *ExecutionResult) String() string { return proto.CompactTextString(m) }
func (*ExecutionResult) ProtoMessage()    {}
func (*ExecutionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{6}
}
func (m *ExecutionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionResult.Merge(m, src)
}
func (m *ExecutionResult) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionResult proto.InternalMessageInfo

func (m *ExecutionResult) GetOutput() *ProposedFact {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ExecutionResult) GetResult() ExecutionResultType {
	if m != nil {
		return m.Result
	}
	return ExecutionResultType_RESULT_TYPE_UNKNOWN
}

func (m *ExecutionResult) GetRecordedAt() *Timestamp {
	if m != nil {
		return m.RecordedAt
	}
	return nil
}

func (m *ExecutionResult) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Recitals struct {
	Parties []*Recital `protobuf:"bytes,1,rep,name=parties,proto3" json:"parties,omitempty"`
}

func (m *Recitals) Reset()         { *m = Recitals{} }
func (m *Recitals) String() string { return proto.CompactTextString(m) }
func (*Recitals) ProtoMessage()    {}
func (*Recitals) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{7}
}
func (m *Recitals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recitals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recitals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recitals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recitals.Merge(m, src)
}
func (m *Recitals) XXX_Size() int {
	return m.Size()
}
func (m *Recitals) XXX_DiscardUnknown() {
	xxx_messageInfo_Recitals.DiscardUnknown(m)
}

var xxx_messageInfo_Recitals proto.InternalMessageInfo

func (m *Recitals) GetParties() []*Recital {
	if m != nil {
		return m.Parties
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Recital struct {
	SignerRole PartyType                       `protobuf:"varint,1,opt,name=signer_role,json=signerRole,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"signer_role,omitempty"`
	Signer     *SigningAndEncryptionPublicKeys `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Address    []byte                          `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Recital) Reset()         { *m = Recital{} }
func (m *Recital) String() string { return proto.CompactTextString(m) }
func (*Recital) ProtoMessage()    {}
func (*Recital) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{8}
}
func (m *Recital) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recital) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recital.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recital) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recital.Merge(m, src)
}
func (m *Recital) XXX_Size() int {
	return m.Size()
}
func (m *Recital) XXX_DiscardUnknown() {
	xxx_messageInfo_Recital.DiscardUnknown(m)
}

var xxx_messageInfo_Recital proto.InternalMessageInfo

func (m *Recital) GetSignerRole() PartyType {
	if m != nil {
		return m.SignerRole
	}
	return PartyType_PARTY_TYPE_UNKNOWN
}

func (m *Recital) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *Recital) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Location struct {
	Ref       *ProvenanceReference `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	Classname string               `protobuf:"bytes,2,opt,name=classname,proto3" json:"classname,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{9}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetRef() *ProvenanceReference {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Location) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type ProvenanceReference struct {
	ScopeUuid *UUID  `protobuf:"bytes,1,opt,name=scope_uuid,json=scopeUuid,proto3" json:"scope_uuid,omitempty"`
	GroupUuid *UUID  `protobuf:"bytes,2,opt,name=group_uuid,json=groupUuid,proto3" json:"group_uuid,omitempty"`
	Hash      string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	Name      string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ProvenanceReference) Reset()         { *m = ProvenanceReference{} }
func (m *ProvenanceReference) String() string { return proto.CompactTextString(m) }
func (*ProvenanceReference) ProtoMessage()    {}
func (*ProvenanceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{10}
}
func (m *ProvenanceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvenanceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvenanceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvenanceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvenanceReference.Merge(m, src)
}
func (m *ProvenanceReference) XXX_Size() int {
	return m.Size()
}
func (m *ProvenanceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvenanceReference.DiscardUnknown(m)
}

var xxx_messageInfo_ProvenanceReference proto.InternalMessageInfo

func (m *ProvenanceReference) GetScopeUuid() *UUID {
	if m != nil {
		return m.ScopeUuid
	}
	return nil
}

func (m *ProvenanceReference) GetGroupUuid() *UUID {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *ProvenanceReference) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProvenanceReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type SignatureSet struct {
	Signatures []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *SignatureSet) Reset()         { *m = SignatureSet{} }
func (m *SignatureSet) String() string { return proto.CompactTextString(m) }
func (*SignatureSet) ProtoMessage()    {}
func (*SignatureSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{11}
}
func (m *SignatureSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureSet.Merge(m, src)
}
func (m *SignatureSet) XXX_Size() int {
	return m.Size()
}
func (m *SignatureSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureSet.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureSet proto.InternalMessageInfo

func (m *SignatureSet) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Signature struct {
	Algo      string                          `protobuf:"bytes,1,opt,name=algo,proto3" json:"algo,omitempty"`
	Provider  string                          `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	Signature string                          `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Signer    *SigningAndEncryptionPublicKeys `protobuf:"bytes,4,opt,name=signer,proto3" json:"signer,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{12}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *Signature) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Signature) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type SigningAndEncryptionPublicKeys struct {
	SigningPublicKey    *PublicKey `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	EncryptionPublicKey *PublicKey `protobuf:"bytes,2,opt,name=encryption_public_key,json=encryptionPublicKey,proto3" json:"encryption_public_key,omitempty"`
}

func (m *SigningAndEncryptionPublicKeys) Reset()         { *m = SigningAndEncryptionPublicKeys{} }
func (m *SigningAndEncryptionPublicKeys) String() string { return proto.CompactTextString(m) }
func (*SigningAndEncryptionPublicKeys) ProtoMessage()    {}
func (*SigningAndEncryptionPublicKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{13}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningAndEncryptionPublicKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.Merge(m, src)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Size() int {
	return m.Size()
}
func (m *SigningAndEncryptionPublicKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.DiscardUnknown(m)
}

var xxx_messageInfo_SigningAndEncryptionPublicKeys proto.InternalMessageInfo

func (m *SigningAndEncryptionPublicKeys) GetSigningPublicKey() *PublicKey {
	if m != nil {
		return m.SigningPublicKey
	}
	return nil
}

func (m *SigningAndEncryptionPublicKeys) GetEncryptionPublicKey() *PublicKey {
	if m != nil {
		return m.EncryptionPublicKey
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type PublicKey struct {
	PublicKeyBytes []byte         `protobuf:"bytes,1,opt,name=public_key_bytes,json=publicKeyBytes,proto3" json:"public_key_bytes,omitempty"`
	Type           PublicKeyType  `protobuf:"varint,2,opt,name=type,proto3,enum=provenance.metadata.v1.p8e.PublicKeyType" json:"type,omitempty"`
	Curve          PublicKeyCurve `protobuf:"varint,3,opt,name=curve,proto3,enum=provenance.metadata.v1.p8e.PublicKeyCurve" json:"curve,omitempty"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{14}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKeyBytes() []byte {
	if m != nil {
		return m.PublicKeyBytes
	}
	return nil
}

func (m *PublicKey) GetType() PublicKeyType {
	if m != nil {
		return m.Type
	}
	return PublicKeyType_ELLIPTIC
}

func (m *PublicKey) GetCurve() PublicKeyCurve {
	if m != nil {
		return m.Curve
	}
	return PublicKeyCurve_SECP256K1
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type UUID struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UUID) Reset()         { *m = UUID{} }
func (m *UUID) String() string { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()    {}
func (*UUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{15}
}
func (m *UUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID.Merge(m, src)
}
func (m *UUID) XXX_Size() int {
	return m.Size()
}
func (m *UUID) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID.DiscardUnknown(m)
}

var xxx_messageInfo_UUID proto.InternalMessageInfo

func (m *UUID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type Timestamp struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Nanos   int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{16}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type ContractSpec struct {
	Definition         *DefinitionSpec      `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
	InputSpecs         []*DefinitionSpec    `protobuf:"bytes,2,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	PartiesInvolved    []PartyType          `protobuf:"varint,3,rep,packed,name=parties_involved,json=partiesInvolved,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"parties_involved,omitempty"`
	ConditionSpecs     []*ConditionSpec     `protobuf:"bytes,4,rep,name=condition_specs,json=conditionSpecs,proto3" json:"condition_specs,omitempty"`
	ConsiderationSpecs []*ConsiderationSpec `protobuf:"bytes,5,rep,name=consideration_specs,json=considerationSpecs,proto3" json:"consideration_specs,omitempty"`
}

func (m *ContractSpec) Reset()         { *m = ContractSpec{} }
func (m *ContractSpec) String() string { return proto.CompactTextString(m) }
func (*ContractSpec) ProtoMessage()    {}
func (*ContractSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{17}
}
func (m *ContractSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractSpec.Merge(m, src)
}
func (m *ContractSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContractSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContractSpec proto.InternalMessageInfo

func (m *ContractSpec) GetDefinition() *DefinitionSpec {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *ContractSpec) GetInputSpecs() []*DefinitionSpec {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ContractSpec) GetPartiesInvolved() []PartyType {
	if m != nil {
		return m.PartiesInvolved
	}
	return nil
}

func (m *ContractSpec) GetConditionSpecs() []*ConditionSpec {
	if m != nil {
		return m.ConditionSpecs
	}
	return nil
}

func (m *ContractSpec) GetConsiderationSpecs() []*ConsiderationSpec {
	if m != nil {
		return m.ConsiderationSpecs
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type ConditionSpec struct {
	FuncName   string            `protobuf:"bytes,1,opt,name=func_name,json=funcName,proto3" json:"func_name,omitempty"`
	InputSpecs []*DefinitionSpec `protobuf:"bytes,2,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	OutputSpec *OutputSpec       `protobuf:"bytes,3,opt,name=output_spec,json=outputSpec,proto3" json:"output_spec,omitempty"`
}

func (m *ConditionSpec) Reset()         { *m = ConditionSpec{} }
func (m *ConditionSpec) String() string { return proto.CompactTextString(m) }
func (*ConditionSpec) ProtoMessage()    {}
func (*ConditionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{18}
}
func (m *ConditionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionSpec.Merge(m, src)
}
func (m *ConditionSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConditionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionSpec proto.InternalMessageInfo

func (m *ConditionSpec) GetFuncName() string {
	if m != nil {
		return m.FuncName
	}
	return ""
}

func (m *ConditionSpec) GetInputSpecs() []*DefinitionSpec {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ConditionSpec) GetOutputSpec() *OutputSpec {
	if m != nil {
		return m.OutputSpec
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type ConsiderationSpec struct {
	FuncName         string            `protobuf:"bytes,1,opt,name=func_name,json=funcName,proto3" json:"func_name,omitempty"`
	ResponsibleParty PartyType         `protobuf:"varint,2,opt,name=responsible_party,json=responsibleParty,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"responsible_party,omitempty"`
	InputSpecs       []*DefinitionSpec `protobuf:"bytes,3,rep,name=input_specs,json=inputSpecs,proto3" json:"input_specs,omitempty"`
	OutputSpec       *OutputSpec       `protobuf:"bytes,4,opt,name=output_spec,json=outputSpec,proto3" json:"output_spec,omitempty"`
}

func (m *ConsiderationSpec) Reset()         { *m = ConsiderationSpec{} }
func (m *ConsiderationSpec) String() string { return proto.CompactTextString(m) }
func (*ConsiderationSpec) ProtoMessage()    {}
func (*ConsiderationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{19}
}
func (m *ConsiderationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsiderationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsiderationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsiderationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsiderationSpec.Merge(m, src)
}
func (m *ConsiderationSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConsiderationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsiderationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConsiderationSpec proto.InternalMessageInfo

func (m *ConsiderationSpec) GetFuncName() string {
	if m != nil {
		return m.FuncName
	}
	return ""
}

func (m *ConsiderationSpec) GetResponsibleParty() PartyType {
	if m != nil {
		return m.ResponsibleParty
	}
	return PartyType_PARTY_TYPE_UNKNOWN
}

func (m *ConsiderationSpec) GetInputSpecs() []*DefinitionSpec {
	if m != nil {
		return m.InputSpecs
	}
	return nil
}

func (m *ConsiderationSpec) GetOutputSpec() *OutputSpec {
	if m != nil {
		return m.OutputSpec
	}
	return nil
}

// Deprecated: Do not use.
//
// Deprecated: Do not use.
type OutputSpec struct {
	Spec *DefinitionSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *OutputSpec) Reset()         { *m = OutputSpec{} }
func (m *OutputSpec) String() string { return proto.CompactTextString(m) }
func (*OutputSpec) ProtoMessage()    {}
func (*OutputSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{20}
}
func (m *OutputSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputSpec.Merge(m, src)
}
func (m *OutputSpec) XXX_Size() int {
	return m.Size()
}
func (m *OutputSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OutputSpec proto.InternalMessageInfo

func (m *OutputSpec) GetSpec() *DefinitionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.metadata.v1.p8e.DefinitionSpecType", DefinitionSpecType_name, DefinitionSpecType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PublicKeyCurve", PublicKeyCurve_name, PublicKeyCurve_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PublicKeyType", PublicKeyType_name, PublicKeyType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.ExecutionResultType", ExecutionResultType_name, ExecutionResultType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PartyType", PartyType_name, PartyType_value)
	proto.RegisterType((*Contract)(nil), "provenance.metadata.v1.p8e.Contract")
	proto.RegisterType((*DefinitionSpec)(nil), "provenance.metadata.v1.p8e.DefinitionSpec")
	proto.RegisterType((*Fact)(nil), "provenance.metadata.v1.p8e.Fact")
	proto.RegisterType((*Condition)(nil), "provenance.metadata.v1.p8e.Condition")
	proto.RegisterType((*Consideration)(nil), "provenance.metadata.v1.p8e.Consideration")
	proto.RegisterType((*ProposedFact)(nil), "provenance.metadata.v1.p8e.ProposedFact")
	proto.RegisterType((*ExecutionResult)(nil), "provenance.metadata.v1.p8e.ExecutionResult")
	proto.RegisterType((*Recitals)(nil), "provenance.metadata.v1.p8e.Recitals")
	proto.RegisterType((*Recital)(nil), "provenance.metadata.v1.p8e.Recital")
	proto.RegisterType((*Location)(nil), "provenance.metadata.v1.p8e.Location")
	proto.RegisterType((*ProvenanceReference)(nil), "provenance.metadata.v1.p8e.ProvenanceReference")
	proto.RegisterType((*SignatureSet)(nil), "provenance.metadata.v1.p8e.SignatureSet")
	proto.RegisterType((*Signature)(nil), "provenance.metadata.v1.p8e.Signature")
	proto.RegisterType((*SigningAndEncryptionPublicKeys)(nil), "provenance.metadata.v1.p8e.SigningAndEncryptionPublicKeys")
	proto.RegisterType((*PublicKey)(nil), "provenance.metadata.v1.p8e.PublicKey")
	proto.RegisterType((*UUID)(nil), "provenance.metadata.v1.p8e.UUID")
	proto.RegisterType((*Timestamp)(nil), "provenance.metadata.v1.p8e.Timestamp")
	proto.RegisterType((*ContractSpec)(nil), "provenance.metadata.v1.p8e.ContractSpec")
	proto.RegisterType((*ConditionSpec)(nil), "provenance.metadata.v1.p8e.ConditionSpec")
	proto.RegisterType((*ConsiderationSpec)(nil), "provenance.metadata.v1.p8e.ConsiderationSpec")
	proto.RegisterType((*OutputSpec)(nil), "provenance.metadata.v1.p8e.OutputSpec")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/p8e/p8e.proto", fileDescriptor_92e2ab9f03ad9d0c)
}

var fileDescriptor_92e2ab9f03ad9d0c = []byte{
	// 1655 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0x36, 0x25, 0xd9, 0x16, 0x8f, 0x65, 0x85, 0x1e, 0x27, 0xf7, 0x32, 0xb9, 0x89, 0xa0, 0xbc,
	0x2e, 0x9c, 0x5c, 0x58, 0x46, 0x7c, 0x1f, 0x30, 0x02, 0xe4, 0x26, 0xb2, 0x4c, 0x07, 0xac, 0x65,
	0x89, 0x19, 0xca, 0x0e, 0xdc, 0x45, 0x09, 0x9a, 0x1a, 0x3b, 0x44, 0x64, 0x92, 0xe0, 0xc3, 0x88,
	0xd0, 0x6d, 0xd1, 0x5d, 0x81, 0xfe, 0x82, 0xa2, 0x9b, 0xfe, 0x80, 0x6e, 0x0b, 0x74, 0x55, 0xa0,
	0x68, 0x77, 0x59, 0x74, 0xd1, 0x65, 0x91, 0xfc, 0x91, 0x62, 0x86, 0x4f, 0x31, 0x0e, 0x23, 0x37,
	0x5e, 0x08, 0xe0, 0x9c, 0x39, 0xdf, 0x77, 0x1e, 0x73, 0xe6, 0xcc, 0x8c, 0xe0, 0x8e, 0xe3, 0xda,
	0xa7, 0xc4, 0xd2, 0x2d, 0x83, 0xac, 0x9d, 0x10, 0x5f, 0x1f, 0xea, 0xbe, 0xbe, 0x76, 0xfa, 0x60,
	0xcd, 0xd9, 0x20, 0xf4, 0xd7, 0x72, 0x5c, 0xdb, 0xb7, 0xd1, 0xb5, 0x54, 0xab, 0x15, 0x6b, 0xb5,
	0x4e, 0x1f, 0xb4, 0x9c, 0x0d, 0x72, 0xeb, 0xcb, 0x59, 0xa8, 0x76, 0x6c, 0xcb, 0x77, 0x75, 0xc3,
	0x47, 0x9f, 0x00, 0x0c, 0xc9, 0x91, 0x69, 0x99, 0xbe, 0x69, 0x5b, 0x22, 0xd7, 0xe4, 0x56, 0x16,
	0xd6, 0xef, 0xb7, 0xde, 0x8f, 0x6e, 0x6d, 0x25, 0xda, 0xaa, 0x43, 0x0c, 0x9c, 0x41, 0xa3, 0xff,
	0x40, 0xc5, 0x73, 0x88, 0x21, 0x96, 0x18, 0x4b, 0xb3, 0x88, 0x65, 0x5b, 0x37, 0x7c, 0xcc, 0xb4,
	0xd1, 0x00, 0xe6, 0x4d, 0xeb, 0xd4, 0x7e, 0x49, 0x5c, 0xb1, 0xcc, 0x80, 0x0f, 0x8b, 0x80, 0xaa,
	0x79, 0x6c, 0x99, 0xd6, 0x71, 0xdb, 0x1a, 0x4a, 0x96, 0xe1, 0x8e, 0x1d, 0x6a, 0x58, 0x09, 0x0e,
	0x47, 0xa6, 0xb1, 0x43, 0xc6, 0x1e, 0x8e, 0xa9, 0xd0, 0x06, 0xcc, 0x99, 0x96, 0x13, 0xf8, 0x9e,
	0x58, 0x69, 0x96, 0xa7, 0xf2, 0x26, 0xd2, 0x47, 0x32, 0x80, 0x61, 0x5b, 0x43, 0x16, 0x92, 0x27,
	0xce, 0x32, 0xf4, 0xdd, 0x22, 0x74, 0x27, 0xd6, 0xde, 0x2c, 0x89, 0x1c, 0xce, 0x80, 0xd1, 0x33,
	0xa8, 0x1b, 0xb6, 0xe5, 0x99, 0x43, 0xe2, 0xea, 0x21, 0xdd, 0x1c, 0xa3, 0xbb, 0xf7, 0x01, 0xba,
	0x14, 0x81, 0x73, 0x04, 0xe8, 0x31, 0x54, 0x5d, 0x62, 0x98, 0xbe, 0x3e, 0xf2, 0xc4, 0x79, 0x46,
	0x76, 0xbb, 0x88, 0x0c, 0x87, 0xba, 0x38, 0x01, 0xa1, 0xbb, 0x50, 0xf7, 0xcd, 0x13, 0xe2, 0x69,
	0xe4, 0x15, 0x31, 0x02, 0x9f, 0x0c, 0xc5, 0x6a, 0x93, 0x5b, 0x99, 0xc5, 0x8b, 0x4c, 0x2a, 0x45,
	0x42, 0xb4, 0x05, 0xe0, 0xf9, 0xba, 0xeb, 0x6b, 0x54, 0x2c, 0xf2, 0x6c, 0x61, 0x0a, 0xb3, 0x30,
	0xa0, 0x70, 0x5f, 0x3f, 0x71, 0x30, 0xcf, 0x80, 0x74, 0x8c, 0x44, 0x98, 0x37, 0x6c, 0xcb, 0x27,
	0xaf, 0x7c, 0x11, 0x9a, 0xdc, 0x4a, 0x0d, 0xc7, 0xc3, 0x87, 0x25, 0x91, 0xbb, 0xf5, 0x45, 0x09,
	0xea, 0x93, 0xe5, 0x84, 0x10, 0x54, 0x2c, 0xfd, 0x84, 0xb0, 0x42, 0xe4, 0x31, 0xfb, 0x46, 0xcf,
	0x60, 0xc9, 0x25, 0x9e, 0x1d, 0xb8, 0x06, 0xd1, 0x46, 0xb6, 0xc1, 0x12, 0x11, 0xd5, 0xd8, 0x9d,
	0x22, 0x8f, 0xba, 0x91, 0x2e, 0x16, 0x62, 0x78, 0x2c, 0x41, 0x1d, 0xe0, 0x3d, 0xf3, 0xd8, 0xd2,
	0xfd, 0xc0, 0x25, 0x51, 0xd5, 0xdd, 0xfd, 0x50, 0xd5, 0x31, 0x65, 0x9c, 0xe2, 0xd0, 0x26, 0x54,
	0xfc, 0xb1, 0x43, 0xc4, 0x4a, 0x93, 0x5b, 0xa9, 0xaf, 0xb7, 0xa6, 0xdf, 0x34, 0x83, 0xb1, 0x43,
	0x30, 0xc3, 0xb2, 0x34, 0x98, 0x50, 0xa1, 0x05, 0x78, 0x66, 0xec, 0x32, 0x2c, 0x52, 0x9e, 0xbf,
	0x16, 0x77, 0x8d, 0x4a, 0xe3, 0x11, 0x33, 0xf5, 0x39, 0xf0, 0x49, 0xb5, 0xd2, 0x4a, 0x48, 0x6a,
	0x55, 0xcb, 0x58, 0x5e, 0x4c, 0xa4, 0x3d, 0xea, 0x42, 0x07, 0xe6, 0x5c, 0xe2, 0x05, 0x23, 0x3f,
	0xb2, 0xfd, 0xaf, 0x22, 0xdb, 0x61, 0xfd, 0x50, 0xe3, 0x0c, 0x82, 0x23, 0x28, 0x33, 0xfe, 0x2b,
	0x07, 0x8b, 0x13, 0xc5, 0x8d, 0x56, 0x01, 0x4d, 0x94, 0x77, 0xd6, 0x8b, 0xa5, 0x89, 0x19, 0xe6,
	0xc9, 0x93, 0x64, 0x4f, 0x97, 0x58, 0xe5, 0xaf, 0x14, 0x79, 0xa2, 0xb8, 0xb6, 0x63, 0x7b, 0x64,
	0x38, 0xb1, 0xb7, 0xd3, 0x58, 0xca, 0x1f, 0x17, 0xcb, 0x77, 0x1c, 0xd4, 0xb2, 0x16, 0xce, 0x5c,
	0x3c, 0x04, 0x95, 0x17, 0xba, 0xf7, 0x82, 0xe5, 0x8d, 0xc7, 0xec, 0x1b, 0x5d, 0x07, 0xde, 0x18,
	0xe9, 0x9e, 0xc7, 0x94, 0xcb, 0x6c, 0x22, 0x15, 0xa0, 0x1d, 0xa8, 0x52, 0x57, 0x3c, 0xdf, 0x76,
	0x59, 0x59, 0x2d, 0xac, 0xaf, 0x7d, 0x20, 0xc6, 0x68, 0x0a, 0x93, 0x23, 0xe2, 0x12, 0xfa, 0x91,
	0x10, 0x30, 0x3f, 0xbf, 0x2a, 0xc1, 0xa5, 0x5c, 0x1c, 0x34, 0x8d, 0x76, 0xe0, 0x3b, 0x81, 0x1f,
	0xb5, 0xfb, 0x73, 0xa4, 0x31, 0xc4, 0xa1, 0xa7, 0x13, 0x25, 0x51, 0x2f, 0x76, 0x32, 0x67, 0x9e,
	0x15, 0x7f, 0x04, 0x47, 0xdb, 0xb0, 0xe0, 0x12, 0xc3, 0x76, 0x87, 0x64, 0xa8, 0xe9, 0xfe, 0x34,
	0x3b, 0x31, 0x6d, 0x33, 0x10, 0x23, 0xdb, 0x3e, 0xba, 0x0d, 0x8b, 0xc4, 0x75, 0x6d, 0x57, 0x3b,
	0x21, 0x9e, 0xa7, 0x1f, 0x87, 0x7b, 0x92, 0xc7, 0x35, 0x26, 0xdc, 0x0d, 0x65, 0x2c, 0x1f, 0xbb,
	0x50, 0xc5, 0x71, 0x27, 0x7c, 0x04, 0xf3, 0x8e, 0xee, 0xfa, 0x26, 0xf1, 0x44, 0x6e, 0xfa, 0x4e,
	0x1a, 0x63, 0x18, 0xdd, 0x4f, 0x1c, 0xcc, 0x47, 0x13, 0x34, 0x16, 0xda, 0x1b, 0x88, 0xab, 0xb9,
	0xf6, 0x28, 0x2c, 0x84, 0x7a, 0x71, 0x2c, 0x8a, 0xee, 0xfa, 0x63, 0x96, 0x0f, 0x08, 0x91, 0xd8,
	0x1e, 0x11, 0x84, 0x61, 0x2e, 0x1c, 0x45, 0xfb, 0xed, 0x63, 0x8e, 0xc3, 0x88, 0x89, 0xf6, 0x61,
	0x7d, 0x38, 0x74, 0x89, 0xe7, 0xb1, 0x1c, 0xd7, 0x70, 0x3c, 0x64, 0x51, 0xd8, 0x50, 0x4d, 0x3a,
	0x63, 0x1b, 0xca, 0x2e, 0x39, 0x8a, 0x2a, 0xe3, 0xdc, 0xc5, 0x47, 0xb1, 0x93, 0x25, 0x5e, 0xca,
	0x95, 0x78, 0x9c, 0xb6, 0xe5, 0x33, 0xe0, 0xe8, 0x31, 0x80, 0x67, 0xd8, 0x0e, 0xd1, 0x82, 0xc0,
	0x1c, 0x46, 0x3e, 0x14, 0x1e, 0xdc, 0x7b, 0x7b, 0xf2, 0x16, 0xe6, 0x19, 0x66, 0x2f, 0x30, 0x87,
	0x94, 0xe0, 0xd8, 0xb5, 0x03, 0x27, 0x24, 0x28, 0x4d, 0x4b, 0xc0, 0x30, 0x8c, 0x20, 0xde, 0xb2,
	0xe5, 0xcc, 0x96, 0x8d, 0xb7, 0x76, 0x25, 0xdd, 0xda, 0x2c, 0x8a, 0x03, 0xa8, 0x25, 0xe7, 0x82,
	0x4a, 0x7c, 0x24, 0x01, 0x24, 0x87, 0x43, 0x5c, 0x52, 0x53, 0x9e, 0x2a, 0x19, 0x20, 0xa3, 0xfe,
	0x9e, 0x03, 0x3e, 0x99, 0xa5, 0x0e, 0xe8, 0xa3, 0x63, 0x3b, 0xee, 0x2d, 0xf4, 0x1b, 0x5d, 0x83,
	0x2a, 0x65, 0xa6, 0x0d, 0x32, 0xca, 0x71, 0x32, 0xa6, 0x0b, 0x30, 0x79, 0xba, 0xf1, 0xd9, 0x63,
	0x2b, 0xad, 0xaf, 0xca, 0x45, 0xd5, 0x17, 0xf3, 0xf9, 0x37, 0x0e, 0x1a, 0xc5, 0xea, 0x48, 0x05,
	0xe4, 0x85, 0x1a, 0x9a, 0xc3, 0xa4, 0xda, 0x4b, 0x32, 0x8e, 0xd6, 0xb9, 0x78, 0xa7, 0xc4, 0x1c,
	0x58, 0x88, 0x08, 0x12, 0x09, 0x3a, 0x80, 0x2b, 0x24, 0x31, 0x96, 0xe5, 0x2d, 0x9d, 0x87, 0x77,
	0x99, 0xbc, 0xeb, 0x30, 0x0b, 0xeb, 0x07, 0x0e, 0xf8, 0xd4, 0xd8, 0x0a, 0x08, 0xa9, 0x05, 0xed,
	0x70, 0xec, 0xb3, 0x95, 0xa6, 0x3b, 0xaa, 0xee, 0xc4, 0x4a, 0x9b, 0x54, 0x8a, 0x1e, 0x45, 0xb7,
	0x83, 0xb0, 0x43, 0xde, 0x9b, 0xca, 0x8b, 0xf4, 0x62, 0x80, 0x9e, 0xc0, 0xac, 0x11, 0xb8, 0xa7,
	0xe1, 0xfa, 0xd5, 0x8b, 0xaf, 0xe4, 0x09, 0xbe, 0x43, 0x11, 0x38, 0x04, 0x32, 0xe7, 0x9b, 0x50,
	0xa1, 0x15, 0x8e, 0x2e, 0xc3, 0xec, 0xa9, 0x3e, 0x0a, 0xe2, 0xe3, 0x29, 0x1c, 0x30, 0x8d, 0xc7,
	0xc0, 0x27, 0x2d, 0x95, 0xb6, 0x09, 0x8f, 0xd0, 0xd3, 0x3f, 0x0c, 0xaa, 0x8c, 0xe3, 0x21, 0x25,
	0xb0, 0x74, 0xcb, 0xf6, 0x58, 0x38, 0xb3, 0x38, 0x1c, 0x84, 0xa5, 0x5a, 0x86, 0x5a, 0xfc, 0x9a,
	0x60, 0x57, 0xb8, 0x8b, 0x7c, 0x51, 0xec, 0xc0, 0x02, 0x3b, 0xb9, 0x35, 0xfa, 0x52, 0x88, 0x8f,
	0xfd, 0x73, 0x91, 0x31, 0x38, 0xfd, 0xf4, 0x90, 0x02, 0x42, 0xd4, 0xbb, 0x35, 0xfa, 0x4a, 0x18,
	0x9d, 0x92, 0xa1, 0x58, 0x6e, 0x96, 0xa7, 0xef, 0xd2, 0x97, 0x22, 0xb8, 0x1c, 0xa1, 0x11, 0x86,
	0x4b, 0xe9, 0x0d, 0x2a, 0x74, 0xb1, 0x32, 0xd5, 0x05, 0x7f, 0x98, 0x7a, 0x98, 0xde, 0xc1, 0x42,
	0x2f, 0x3f, 0x83, 0xe5, 0xc9, 0x3b, 0x51, 0xc8, 0x1b, 0xbe, 0x43, 0x56, 0xa7, 0x7e, 0x38, 0x30,
	0xee, 0xc9, 0xdb, 0x15, 0xe3, 0x67, 0x6b, 0xf6, 0x73, 0x78, 0x13, 0x4b, 0xcd, 0xa2, 0x7f, 0x00,
	0x7f, 0x14, 0x58, 0x46, 0xf6, 0x02, 0x56, 0xa5, 0x82, 0x5e, 0x78, 0x2b, 0xb9, 0xc0, 0x55, 0x78,
	0x0a, 0x0b, 0xe1, 0x2d, 0x82, 0xb1, 0x45, 0x47, 0xfe, 0x3f, 0x8b, 0xc8, 0xfa, 0x4c, 0x3d, 0x24,
	0xb2, 0x93, 0x6f, 0x16, 0xc8, 0x37, 0x25, 0x58, 0x7a, 0x27, 0xec, 0xe2, 0x60, 0x30, 0x7b, 0x4d,
	0x38, 0x14, 0x74, 0x38, 0x22, 0x1a, 0x5d, 0xd2, 0x71, 0xb4, 0x49, 0xa7, 0x2c, 0x03, 0x21, 0x83,
	0x67, 0xd2, 0x7c, 0x82, 0xca, 0x17, 0x99, 0xa0, 0xca, 0x47, 0x25, 0x48, 0x01, 0x48, 0x67, 0xd1,
	0xff, 0xa3, 0x07, 0xfa, 0xf9, 0x37, 0x25, 0xc3, 0x51, 0xc6, 0xfb, 0xdf, 0x72, 0x80, 0xde, 0x7d,
	0xce, 0xa0, 0x26, 0x5c, 0xdf, 0x92, 0xb6, 0xe5, 0x9e, 0x3c, 0x90, 0xfb, 0x3d, 0x4d, 0x55, 0xa4,
	0x8e, 0x36, 0x38, 0x50, 0x24, 0x6d, 0xaf, 0xb7, 0xd3, 0xeb, 0x3f, 0xef, 0x09, 0x33, 0xe8, 0x26,
	0xdc, 0x38, 0x53, 0x43, 0xc1, 0x7d, 0xa5, 0xaf, 0x4a, 0x5b, 0x02, 0x87, 0x6e, 0xc0, 0xd5, 0x33,
	0x55, 0xb6, 0xdb, 0x9d, 0x81, 0x50, 0x42, 0xb7, 0xa0, 0xf1, 0xde, 0x69, 0xad, 0x2b, 0xab, 0x03,
	0xa1, 0x7c, 0x8d, 0xba, 0xb8, 0x0a, 0xf5, 0xc9, 0x96, 0x88, 0x16, 0x81, 0x57, 0xa5, 0x8e, 0xb2,
	0xfe, 0xdf, 0xff, 0xed, 0x3c, 0x10, 0x66, 0x50, 0x15, 0x2a, 0xf4, 0x5b, 0xe0, 0x98, 0xfa, 0x4d,
	0x58, 0x9c, 0xe8, 0xc0, 0xa8, 0x06, 0x55, 0xa9, 0xdb, 0x95, 0x95, 0x81, 0xdc, 0x11, 0x66, 0x98,
	0x8a, 0x0f, 0xcb, 0x67, 0x5c, 0x63, 0xd1, 0xdf, 0x61, 0x19, 0x4b, 0xea, 0x5e, 0x77, 0x90, 0x8f,
	0xf5, 0x32, 0x08, 0xd9, 0x09, 0xa5, 0xad, 0xaa, 0x02, 0x97, 0x97, 0xaa, 0x3b, 0xb2, 0x22, 0x94,
	0xf2, 0xd2, 0xed, 0xb6, 0xdc, 0x8d, 0xe2, 0xf8, 0xb1, 0x04, 0x7c, 0x52, 0x76, 0xe8, 0x6f, 0x80,
	0x94, 0x36, 0x1e, 0x1c, 0xe4, 0x6d, 0x5d, 0x85, 0x2b, 0x19, 0x79, 0x1f, 0xcb, 0x4f, 0xe5, 0x5e,
	0x7b, 0xd0, 0xc7, 0x02, 0x47, 0xfd, 0xcb, 0x4c, 0xa9, 0x12, 0xde, 0x97, 0x3b, 0x12, 0x16, 0x4a,
	0xb9, 0x09, 0xb9, 0xb7, 0x2f, 0xa9, 0x14, 0x51, 0x46, 0x22, 0x5c, 0xce, 0x4c, 0x74, 0xf6, 0xd4,
	0x41, 0x7f, 0x4b, 0x6e, 0xf7, 0x84, 0x0a, 0x75, 0x33, 0x6b, 0xe6, 0x79, 0x4f, 0xc2, 0xc2, 0x6c,
	0x4e, 0xbf, 0xbd, 0xbd, 0x2d, 0x77, 0xe5, 0xf6, 0x40, 0x12, 0xe6, 0x72, 0xee, 0xf6, 0x77, 0x7b,
	0xf2, 0xe6, 0x9e, 0x2a, 0xcc, 0xe7, 0xdc, 0x55, 0x70, 0x7f, 0x5f, 0xea, 0xb5, 0x7b, 0x1d, 0x49,
	0xa8, 0xa2, 0x2b, 0xb0, 0x94, 0x99, 0xda, 0x6d, 0xe3, 0x1d, 0x09, 0x0b, 0x7c, 0x0e, 0xd1, 0xe9,
	0xf7, 0x06, 0xb8, 0xdf, 0xed, 0x4a, 0x58, 0x80, 0x9c, 0xf9, 0xfd, 0x76, 0x57, 0xde, 0x62, 0xa1,
	0x2f, 0xd0, 0xfc, 0x6d, 0x7a, 0xbf, 0xbc, 0x69, 0x70, 0xaf, 0xdf, 0x34, 0xb8, 0x3f, 0xde, 0x34,
	0xb8, 0xaf, 0xdf, 0x36, 0x66, 0x5e, 0xbf, 0x6d, 0xcc, 0xfc, 0xfe, 0xb6, 0x31, 0x03, 0x37, 0x4c,
	0xbb, 0xa0, 0xf8, 0x15, 0xee, 0xd3, 0x8d, 0x63, 0xd3, 0x7f, 0x11, 0x1c, 0xb6, 0x0c, 0xfb, 0x64,
	0x2d, 0x55, 0x5c, 0x35, 0xed, 0xcc, 0x68, 0xed, 0x55, 0xfa, 0x07, 0x1c, 0x3d, 0xb3, 0xbd, 0x35,
	0x67, 0x83, 0x1c, 0xce, 0xb1, 0x3f, 0xe0, 0xfe, 0xfd, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x48,
	0xb6, 0x14, 0x83, 0xa8, 0x13, 0x00, 0x00,
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x52
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TimesExecuted != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.TimesExecuted))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Recitals) > 0 {
		for iNdEx := len(m.Recitals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recitals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Considerations) > 0 {
		for iNdEx := len(m.Considerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Considerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Invoker != nil {
		{
			size, err := m.Invoker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefinitionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefinitionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefinitionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ResourceLocation != nil {
		{
			size, err := m.ResourceLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Fact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataLocation != nil {
		{
			size, err := m.DataLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConditionName) > 0 {
		i -= len(m.ConditionName)
		copy(dAtA[i:], m.ConditionName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ConditionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Consideration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Consideration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Consideration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ConsiderationName) > 0 {
		i -= len(m.ConsiderationName)
		copy(dAtA[i:], m.ConsiderationName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ConsiderationName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposedFact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposedFact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposedFact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ancestor != nil {
		{
			size, err := m.Ancestor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if m.RecordedAt != nil {
		{
			size, err := m.RecordedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Recitals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recitals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recitals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parties) > 0 {
		for iNdEx := len(m.Parties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Recital) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recital) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recital) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SignerRole != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.SignerRole))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvenanceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvenanceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvenanceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupUuid != nil {
		{
			size, err := m.GroupUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ScopeUuid != nil {
		{
			size, err := m.ScopeUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Algo) > 0 {
		i -= len(m.Algo)
		copy(dAtA[i:], m.Algo)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Algo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningAndEncryptionPublicKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningAndEncryptionPublicKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningAndEncryptionPublicKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptionPublicKey != nil {
		{
			size, err := m.EncryptionPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SigningPublicKey != nil {
		{
			size, err := m.SigningPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Curve != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Curve))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicKeyBytes) > 0 {
		i -= len(m.PublicKeyBytes)
		copy(dAtA[i:], m.PublicKeyBytes)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.PublicKeyBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsiderationSpecs) > 0 {
		for iNdEx := len(m.ConsiderationSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsiderationSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ConditionSpecs) > 0 {
		for iNdEx := len(m.ConditionSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConditionSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PartiesInvolved) > 0 {
		dAtA21 := make([]byte, len(m.PartiesInvolved)*10)
		var j20 int
		for _, num := range m.PartiesInvolved {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintP8E(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSpec != nil {
		{
			size, err := m.OutputSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FuncName) > 0 {
		i -= len(m.FuncName)
		copy(dAtA[i:], m.FuncName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.FuncName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsiderationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsiderationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsiderationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSpec != nil {
		{
			size, err := m.OutputSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.InputSpecs) > 0 {
		for iNdEx := len(m.InputSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ResponsibleParty != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.ResponsibleParty))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FuncName) > 0 {
		i -= len(m.FuncName)
		copy(dAtA[i:], m.FuncName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.FuncName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintP8E(dAtA []byte, offset int, v uint64) int {
	offset -= sovP8E(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Invoker != nil {
		l = m.Invoker.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Considerations) > 0 {
		for _, e := range m.Considerations {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Recitals) > 0 {
		for _, e := range m.Recitals {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.TimesExecuted != 0 {
		n += 1 + sovP8E(uint64(m.TimesExecuted))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *DefinitionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.ResourceLocation != nil {
		l = m.ResourceLocation.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovP8E(uint64(m.Type))
	}
	return n
}

func (m *Fact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.DataLocation != nil {
		l = m.DataLocation.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConditionName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Consideration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsiderationName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ProposedFact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Ancestor != nil {
		l = m.Ancestor.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ExecutionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovP8E(uint64(m.Result))
	}
	if m.RecordedAt != nil {
		l = m.RecordedAt.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Recitals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parties) > 0 {
		for _, e := range m.Parties {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *Recital) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignerRole != 0 {
		n += 1 + sovP8E(uint64(m.SignerRole))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ProvenanceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopeUuid != nil {
		l = m.ScopeUuid.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.GroupUuid != nil {
		l = m.GroupUuid.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *SignatureSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *SigningAndEncryptionPublicKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningPublicKey != nil {
		l = m.SigningPublicKey.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.EncryptionPublicKey != nil {
		l = m.EncryptionPublicKey.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKeyBytes)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovP8E(uint64(m.Type))
	}
	if m.Curve != 0 {
		n += 1 + sovP8E(uint64(m.Curve))
	}
	return n
}

func (m *UUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovP8E(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovP8E(uint64(m.Nanos))
	}
	return n
}

func (m *ContractSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.PartiesInvolved) > 0 {
		l = 0
		for _, e := range m.PartiesInvolved {
			l += sovP8E(uint64(e))
		}
		n += 1 + sovP8E(uint64(l)) + l
	}
	if len(m.ConditionSpecs) > 0 {
		for _, e := range m.ConditionSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.ConsiderationSpecs) > 0 {
		for _, e := range m.ConsiderationSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *ConditionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.OutputSpec != nil {
		l = m.OutputSpec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ConsiderationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.ResponsibleParty != 0 {
		n += 1 + sovP8E(uint64(m.ResponsibleParty))
	}
	if len(m.InputSpecs) > 0 {
		for _, e := range m.InputSpecs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.OutputSpec != nil {
		l = m.OutputSpec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *OutputSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func sovP8E(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozP8E(x uint64) (n int) {
	return sovP8E(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &DefinitionSpec{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Fact{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoker == nil {
				m.Invoker = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Invoker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &Fact{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Considerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Considerations = append(m.Considerations, &Consideration{})
			if err := m.Considerations[len(m.Considerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recitals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recitals = append(m.Recitals, &Recital{})
			if err := m.Recitals[len(m.Recitals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimesExecuted", wireType)
			}
			m.TimesExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimesExecuted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefinitionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefinitionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefinitionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLocation == nil {
				m.ResourceLocation = &Location{}
			}
			if err := m.ResourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DefinitionSpecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataLocation == nil {
				m.DataLocation = &Location{}
			}
			if err := m.DataLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &ExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Consideration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Consideration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Consideration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &ProposedFact{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &ExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposedFact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposedFact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposedFact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ancestor == nil {
				m.Ancestor = &ProvenanceReference{}
			}
			if err := m.Ancestor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &ProposedFact{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ExecutionResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecordedAt == nil {
				m.RecordedAt = &Timestamp{}
			}
			if err := m.RecordedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recitals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recitals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recitals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parties = append(m.Parties, &Recital{})
			if err := m.Parties[len(m.Parties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recital) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recital: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recital: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerRole", wireType)
			}
			m.SignerRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignerRole |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ProvenanceReference{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvenanceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvenanceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvenanceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeUuid == nil {
				m.ScopeUuid = &UUID{}
			}
			if err := m.ScopeUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupUuid == nil {
				m.GroupUuid = &UUID{}
			}
			if err := m.GroupUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningAndEncryptionPublicKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningPublicKey == nil {
				m.SigningPublicKey = &PublicKey{}
			}
			if err := m.SigningPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionPublicKey == nil {
				m.EncryptionPublicKey = &PublicKey{}
			}
			if err := m.EncryptionPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBytes = append(m.PublicKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyBytes == nil {
				m.PublicKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PublicKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			m.Curve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curve |= PublicKeyCurve(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &DefinitionSpec{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &DefinitionSpec{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v PartyType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowP8E
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PartyType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartiesInvolved = append(m.PartiesInvolved, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowP8E
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthP8E
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthP8E
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PartiesInvolved) == 0 {
					m.PartiesInvolved = make([]PartyType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PartyType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowP8E
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PartyType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartiesInvolved = append(m.PartiesInvolved, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiesInvolved", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionSpecs = append(m.ConditionSpecs, &ConditionSpec{})
			if err := m.ConditionSpecs[len(m.ConditionSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationSpecs = append(m.ConsiderationSpecs, &ConsiderationSpec{})
			if err := m.ConsiderationSpecs[len(m.ConsiderationSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &DefinitionSpec{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSpec == nil {
				m.OutputSpec = &OutputSpec{}
			}
			if err := m.OutputSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsiderationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsiderationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsiderationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsibleParty", wireType)
			}
			m.ResponsibleParty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponsibleParty |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSpecs = append(m.InputSpecs, &DefinitionSpec{})
			if err := m.InputSpecs[len(m.InputSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSpec == nil {
				m.OutputSpec = &OutputSpec{}
			}
			if err := m.OutputSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DefinitionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipP8E(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthP8E
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupP8E
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthP8E
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthP8E        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowP8E          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupP8E = fmt.Errorf("proto: unexpected end of group")
)
