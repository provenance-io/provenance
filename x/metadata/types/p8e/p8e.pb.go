// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/metadata/v1/p8e/p8e.proto

package p8e

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DefinitionSpecType int32

const (
	DefinitionSpecType_DEFINITION_SPEC_TYPE_UNKNOWN   DefinitionSpecType = 0
	DefinitionSpecType_DEFINITION_SPEC_TYPE_PROPOSED  DefinitionSpecType = 1
	DefinitionSpecType_DEFINITION_SPEC_TYPE_FACT      DefinitionSpecType = 2
	DefinitionSpecType_DEFINITION_SPEC_TYPE_FACT_LIST DefinitionSpecType = 3
)

var DefinitionSpecType_name = map[int32]string{
	0: "DEFINITION_SPEC_TYPE_UNKNOWN",
	1: "DEFINITION_SPEC_TYPE_PROPOSED",
	2: "DEFINITION_SPEC_TYPE_FACT",
	3: "DEFINITION_SPEC_TYPE_FACT_LIST",
}

var DefinitionSpecType_value = map[string]int32{
	"DEFINITION_SPEC_TYPE_UNKNOWN":   0,
	"DEFINITION_SPEC_TYPE_PROPOSED":  1,
	"DEFINITION_SPEC_TYPE_FACT":      2,
	"DEFINITION_SPEC_TYPE_FACT_LIST": 3,
}

func (x DefinitionSpecType) String() string {
	return proto.EnumName(DefinitionSpecType_name, int32(x))
}

func (DefinitionSpecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{0}
}

type PublicKeyCurve int32

const (
	PublicKeyCurve_SECP256K1 PublicKeyCurve = 0
	PublicKeyCurve_P256      PublicKeyCurve = 1
)

var PublicKeyCurve_name = map[int32]string{
	0: "SECP256K1",
	1: "P256",
}

var PublicKeyCurve_value = map[string]int32{
	"SECP256K1": 0,
	"P256":      1,
}

func (x PublicKeyCurve) String() string {
	return proto.EnumName(PublicKeyCurve_name, int32(x))
}

func (PublicKeyCurve) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{1}
}

type PublicKeyType int32

const (
	PublicKeyType_ELLIPTIC PublicKeyType = 0
)

var PublicKeyType_name = map[int32]string{
	0: "ELLIPTIC",
}

var PublicKeyType_value = map[string]int32{
	"ELLIPTIC": 0,
}

func (x PublicKeyType) String() string {
	return proto.EnumName(PublicKeyType_name, int32(x))
}

func (PublicKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{2}
}

type ExecutionResultType int32

const (
	ExecutionResultType_RESULT_TYPE_UNKNOWN ExecutionResultType = 0
	ExecutionResultType_RESULT_TYPE_PASS    ExecutionResultType = 1
	// Couldn't process the condition/consideration due to missing facts being generated by other considerations.
	ExecutionResultType_RESULT_TYPE_SKIP ExecutionResultType = 2
	ExecutionResultType_RESULT_TYPE_FAIL ExecutionResultType = 3
)

var ExecutionResultType_name = map[int32]string{
	0: "RESULT_TYPE_UNKNOWN",
	1: "RESULT_TYPE_PASS",
	2: "RESULT_TYPE_SKIP",
	3: "RESULT_TYPE_FAIL",
}

var ExecutionResultType_value = map[string]int32{
	"RESULT_TYPE_UNKNOWN": 0,
	"RESULT_TYPE_PASS":    1,
	"RESULT_TYPE_SKIP":    2,
	"RESULT_TYPE_FAIL":    3,
}

func (x ExecutionResultType) String() string {
	return proto.EnumName(ExecutionResultType_name, int32(x))
}

func (ExecutionResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{3}
}

type PartyType int32

const (
	PartyType_PARTY_TYPE_UNKNOWN    PartyType = 0
	PartyType_PARTY_TYPE_ORIGINATOR PartyType = 1
	PartyType_PARTY_TYPE_SERVICER   PartyType = 2
	PartyType_PARTY_TYPE_INVESTOR   PartyType = 3
	PartyType_PARTY_TYPE_CUSTODIAN  PartyType = 4
	PartyType_PARTY_TYPE_OWNER      PartyType = 5
	PartyType_PARTY_TYPE_AFFILIATE  PartyType = 6
	PartyType_PARTY_TYPE_OMNIBUS    PartyType = 7
	PartyType_PARTY_TYPE_PROVENANCE PartyType = 8
	PartyType_PARTY_TYPE_MARKER     PartyType = 9
)

var PartyType_name = map[int32]string{
	0: "PARTY_TYPE_UNKNOWN",
	1: "PARTY_TYPE_ORIGINATOR",
	2: "PARTY_TYPE_SERVICER",
	3: "PARTY_TYPE_INVESTOR",
	4: "PARTY_TYPE_CUSTODIAN",
	5: "PARTY_TYPE_OWNER",
	6: "PARTY_TYPE_AFFILIATE",
	7: "PARTY_TYPE_OMNIBUS",
	8: "PARTY_TYPE_PROVENANCE",
	9: "PARTY_TYPE_MARKER",
}

var PartyType_value = map[string]int32{
	"PARTY_TYPE_UNKNOWN":    0,
	"PARTY_TYPE_ORIGINATOR": 1,
	"PARTY_TYPE_SERVICER":   2,
	"PARTY_TYPE_INVESTOR":   3,
	"PARTY_TYPE_CUSTODIAN":  4,
	"PARTY_TYPE_OWNER":      5,
	"PARTY_TYPE_AFFILIATE":  6,
	"PARTY_TYPE_OMNIBUS":    7,
	"PARTY_TYPE_PROVENANCE": 8,
	"PARTY_TYPE_MARKER":     9,
}

func (x PartyType) String() string {
	return proto.EnumName(PartyType_name, int32(x))
}

func (PartyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{4}
}

// P8eMsgMemorializeP8eContractRequest is the input for a MemorializeP8eContract call
//
// Deprecated: Do not use.
type P8EMsgMemorializeP8EContractRequest struct {
	// The scope id of the object being add or modified on blockchain.
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id,omitempty"`
	// The uuid of the contract execution.
	GroupId string `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// Unique identifier for determining contract/session execution instance
	ExecutionId string `protobuf:"bytes,3,opt,name=execution_id,json=executionId,proto3" json:"execution_id,omitempty"`
	// The new recitals for the scope.  Used in leu of Contract for direct ownership changes.
	Recitals *Recitals `protobuf:"bytes,4,opt,name=recitals,proto3" json:"recitals,omitempty"`
	// The executed contract.
	Contract *Contract `protobuf:"bytes,5,opt,name=contract,proto3" json:"contract,omitempty"`
	// The contract signatures
	Signatures *SignatureSet `protobuf:"bytes,6,opt,name=signatures,proto3" json:"signatures,omitempty"`
	// The address of the notary (ie the broadcaster of this message).
	Invoker []byte `protobuf:"bytes,7,opt,name=invoker,proto3" json:"invoker,omitempty"`
}

func (m *P8EMsgMemorializeP8EContractRequest) Reset()         { *m = P8EMsgMemorializeP8EContractRequest{} }
func (m *P8EMsgMemorializeP8EContractRequest) String() string { return proto.CompactTextString(m) }
func (*P8EMsgMemorializeP8EContractRequest) ProtoMessage()    {}
func (*P8EMsgMemorializeP8EContractRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{0}
}
func (m *P8EMsgMemorializeP8EContractRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P8EMsgMemorializeP8EContractRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P8EMsgMemorializeP8EContractRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P8EMsgMemorializeP8EContractRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P8EMsgMemorializeP8EContractRequest.Merge(m, src)
}
func (m *P8EMsgMemorializeP8EContractRequest) XXX_Size() int {
	return m.Size()
}
func (m *P8EMsgMemorializeP8EContractRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_P8EMsgMemorializeP8EContractRequest.DiscardUnknown(m)
}

var xxx_messageInfo_P8EMsgMemorializeP8EContractRequest proto.InternalMessageInfo

func (m *P8EMsgMemorializeP8EContractRequest) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *P8EMsgMemorializeP8EContractRequest) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *P8EMsgMemorializeP8EContractRequest) GetExecutionId() string {
	if m != nil {
		return m.ExecutionId
	}
	return ""
}

func (m *P8EMsgMemorializeP8EContractRequest) GetRecitals() *Recitals {
	if m != nil {
		return m.Recitals
	}
	return nil
}

func (m *P8EMsgMemorializeP8EContractRequest) GetContract() *Contract {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *P8EMsgMemorializeP8EContractRequest) GetSignatures() *SignatureSet {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *P8EMsgMemorializeP8EContractRequest) GetInvoker() []byte {
	if m != nil {
		return m.Invoker
	}
	return nil
}

// P8eMsgMemorializeP8eContractResponse is the out for a MemorializeP8eContract call
//
// Deprecated: Do not use.
type P8EMsgMemorializeP8EContractResponse struct {
}

func (m *P8EMsgMemorializeP8EContractResponse) Reset()         { *m = P8EMsgMemorializeP8EContractResponse{} }
func (m *P8EMsgMemorializeP8EContractResponse) String() string { return proto.CompactTextString(m) }
func (*P8EMsgMemorializeP8EContractResponse) ProtoMessage()    {}
func (*P8EMsgMemorializeP8EContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{1}
}
func (m *P8EMsgMemorializeP8EContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P8EMsgMemorializeP8EContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P8EMsgMemorializeP8EContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P8EMsgMemorializeP8EContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P8EMsgMemorializeP8EContractResponse.Merge(m, src)
}
func (m *P8EMsgMemorializeP8EContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *P8EMsgMemorializeP8EContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_P8EMsgMemorializeP8EContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_P8EMsgMemorializeP8EContractResponse proto.InternalMessageInfo

type Contract struct {
	Definition *DefinitionSpec `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
	// Points to the proto for the contractSpec
	Spec *Fact `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	// Invoker of this contract
	Invoker *SigningAndEncryptionPublicKeys `protobuf:"bytes,3,opt,name=invoker,proto3" json:"invoker,omitempty"`
	// Constructor arguments.
	// These are always the output of a previously recorded consideration.
	Inputs         []*Fact          `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Conditions     []*Condition     `protobuf:"bytes,5,rep,name=conditions,proto3" json:"conditions,omitempty"`
	Considerations []*Consideration `protobuf:"bytes,6,rep,name=considerations,proto3" json:"considerations,omitempty"`
	Recitals       []*Recital       `protobuf:"bytes,7,rep,name=recitals,proto3" json:"recitals,omitempty"`
	TimesExecuted  int32            `protobuf:"varint,8,opt,name=times_executed,json=timesExecuted,proto3" json:"times_executed,omitempty"`
	// This is only set once when the contract is initially executed
	StartTime *Timestamp `protobuf:"bytes,9,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{2}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetDefinition() *DefinitionSpec {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *Contract) GetSpec() *Fact {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Contract) GetInvoker() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Invoker
	}
	return nil
}

func (m *Contract) GetInputs() []*Fact {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Contract) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Contract) GetConsiderations() []*Consideration {
	if m != nil {
		return m.Considerations
	}
	return nil
}

func (m *Contract) GetRecitals() []*Recital {
	if m != nil {
		return m.Recitals
	}
	return nil
}

func (m *Contract) GetTimesExecuted() int32 {
	if m != nil {
		return m.TimesExecuted
	}
	return 0
}

func (m *Contract) GetStartTime() *Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

type DefinitionSpec struct {
	Name             string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ResourceLocation *Location          `protobuf:"bytes,2,opt,name=resource_location,json=resourceLocation,proto3" json:"resource_location,omitempty"`
	Signature        *Signature         `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Type             DefinitionSpecType `protobuf:"varint,4,opt,name=type,proto3,enum=provenance.metadata.v1.p8e.DefinitionSpecType" json:"type,omitempty"`
}

func (m *DefinitionSpec) Reset()         { *m = DefinitionSpec{} }
func (m *DefinitionSpec) String() string { return proto.CompactTextString(m) }
func (*DefinitionSpec) ProtoMessage()    {}
func (*DefinitionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{3}
}
func (m *DefinitionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefinitionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefinitionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefinitionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefinitionSpec.Merge(m, src)
}
func (m *DefinitionSpec) XXX_Size() int {
	return m.Size()
}
func (m *DefinitionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DefinitionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DefinitionSpec proto.InternalMessageInfo

func (m *DefinitionSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DefinitionSpec) GetResourceLocation() *Location {
	if m != nil {
		return m.ResourceLocation
	}
	return nil
}

func (m *DefinitionSpec) GetSignature() *Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DefinitionSpec) GetType() DefinitionSpecType {
	if m != nil {
		return m.Type
	}
	return DefinitionSpecType_DEFINITION_SPEC_TYPE_UNKNOWN
}

type Fact struct {
	Name         string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DataLocation *Location `protobuf:"bytes,2,opt,name=data_location,json=dataLocation,proto3" json:"data_location,omitempty"`
}

func (m *Fact) Reset()         { *m = Fact{} }
func (m *Fact) String() string { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()    {}
func (*Fact) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{4}
}
func (m *Fact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fact.Merge(m, src)
}
func (m *Fact) XXX_Size() int {
	return m.Size()
}
func (m *Fact) XXX_DiscardUnknown() {
	xxx_messageInfo_Fact.DiscardUnknown(m)
}

var xxx_messageInfo_Fact proto.InternalMessageInfo

func (m *Fact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Fact) GetDataLocation() *Location {
	if m != nil {
		return m.DataLocation
	}
	return nil
}

type Condition struct {
	ConditionName string           `protobuf:"bytes,1,opt,name=condition_name,json=conditionName,proto3" json:"condition_name,omitempty"`
	Result        *ExecutionResult `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{5}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetConditionName() string {
	if m != nil {
		return m.ConditionName
	}
	return ""
}

func (m *Condition) GetResult() *ExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type Consideration struct {
	ConsiderationName string `protobuf:"bytes,1,opt,name=consideration_name,json=considerationName,proto3" json:"consideration_name,omitempty"`
	// Data pushed to a consideration that will ultimately match the output_spec of the consideration
	Inputs []*ProposedFact  `protobuf:"bytes,2,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Result *ExecutionResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Consideration) Reset()         { *m = Consideration{} }
func (m *Consideration) String() string { return proto.CompactTextString(m) }
func (*Consideration) ProtoMessage()    {}
func (*Consideration) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{6}
}
func (m *Consideration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Consideration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Consideration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Consideration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Consideration.Merge(m, src)
}
func (m *Consideration) XXX_Size() int {
	return m.Size()
}
func (m *Consideration) XXX_DiscardUnknown() {
	xxx_messageInfo_Consideration.DiscardUnknown(m)
}

var xxx_messageInfo_Consideration proto.InternalMessageInfo

func (m *Consideration) GetConsiderationName() string {
	if m != nil {
		return m.ConsiderationName
	}
	return ""
}

func (m *Consideration) GetInputs() []*ProposedFact {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Consideration) GetResult() *ExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type ProposedFact struct {
	Name      string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hash      string               `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Classname string               `protobuf:"bytes,3,opt,name=classname,proto3" json:"classname,omitempty"`
	Ancestor  *ProvenanceReference `protobuf:"bytes,4,opt,name=ancestor,proto3" json:"ancestor,omitempty"`
}

func (m *ProposedFact) Reset()         { *m = ProposedFact{} }
func (m *ProposedFact) String() string { return proto.CompactTextString(m) }
func (*ProposedFact) ProtoMessage()    {}
func (*ProposedFact) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{7}
}
func (m *ProposedFact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposedFact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposedFact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposedFact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposedFact.Merge(m, src)
}
func (m *ProposedFact) XXX_Size() int {
	return m.Size()
}
func (m *ProposedFact) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposedFact.DiscardUnknown(m)
}

var xxx_messageInfo_ProposedFact proto.InternalMessageInfo

func (m *ProposedFact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProposedFact) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProposedFact) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

func (m *ProposedFact) GetAncestor() *ProvenanceReference {
	if m != nil {
		return m.Ancestor
	}
	return nil
}

type ExecutionResult struct {
	Output       *ProposedFact       `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Result       ExecutionResultType `protobuf:"varint,2,opt,name=result,proto3,enum=provenance.metadata.v1.p8e.ExecutionResultType" json:"result,omitempty"`
	RecordedAt   *Timestamp          `protobuf:"bytes,3,opt,name=recorded_at,json=recordedAt,proto3" json:"recorded_at,omitempty"`
	ErrorMessage string              `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *ExecutionResult) Reset()         { *m = ExecutionResult{} }
func (m *ExecutionResult) String() string { return proto.CompactTextString(m) }
func (*ExecutionResult) ProtoMessage()    {}
func (*ExecutionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{8}
}
func (m *ExecutionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionResult.Merge(m, src)
}
func (m *ExecutionResult) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionResult proto.InternalMessageInfo

func (m *ExecutionResult) GetOutput() *ProposedFact {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ExecutionResult) GetResult() ExecutionResultType {
	if m != nil {
		return m.Result
	}
	return ExecutionResultType_RESULT_TYPE_UNKNOWN
}

func (m *ExecutionResult) GetRecordedAt() *Timestamp {
	if m != nil {
		return m.RecordedAt
	}
	return nil
}

func (m *ExecutionResult) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type Recitals struct {
	Parties []*Recital `protobuf:"bytes,1,rep,name=parties,proto3" json:"parties,omitempty"`
}

func (m *Recitals) Reset()         { *m = Recitals{} }
func (m *Recitals) String() string { return proto.CompactTextString(m) }
func (*Recitals) ProtoMessage()    {}
func (*Recitals) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{9}
}
func (m *Recitals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recitals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recitals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recitals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recitals.Merge(m, src)
}
func (m *Recitals) XXX_Size() int {
	return m.Size()
}
func (m *Recitals) XXX_DiscardUnknown() {
	xxx_messageInfo_Recitals.DiscardUnknown(m)
}

var xxx_messageInfo_Recitals proto.InternalMessageInfo

func (m *Recitals) GetParties() []*Recital {
	if m != nil {
		return m.Parties
	}
	return nil
}

type Recital struct {
	SignerRole PartyType                       `protobuf:"varint,1,opt,name=signer_role,json=signerRole,proto3,enum=provenance.metadata.v1.p8e.PartyType" json:"signer_role,omitempty"`
	Signer     *SigningAndEncryptionPublicKeys `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Address    []byte                          `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Recital) Reset()         { *m = Recital{} }
func (m *Recital) String() string { return proto.CompactTextString(m) }
func (*Recital) ProtoMessage()    {}
func (*Recital) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{10}
}
func (m *Recital) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recital) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Recital.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Recital) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recital.Merge(m, src)
}
func (m *Recital) XXX_Size() int {
	return m.Size()
}
func (m *Recital) XXX_DiscardUnknown() {
	xxx_messageInfo_Recital.DiscardUnknown(m)
}

var xxx_messageInfo_Recital proto.InternalMessageInfo

func (m *Recital) GetSignerRole() PartyType {
	if m != nil {
		return m.SignerRole
	}
	return PartyType_PARTY_TYPE_UNKNOWN
}

func (m *Recital) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *Recital) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

type Location struct {
	Ref       *ProvenanceReference `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	Classname string               `protobuf:"bytes,2,opt,name=classname,proto3" json:"classname,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{11}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetRef() *ProvenanceReference {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Location) GetClassname() string {
	if m != nil {
		return m.Classname
	}
	return ""
}

type ProvenanceReference struct {
	// [Req] [Scope.uuid]
	// Scope ID
	ScopeUuid *UUID `protobuf:"bytes,1,opt,name=scope_uuid,json=scopeUuid,proto3" json:"scope_uuid,omitempty"`
	// [Opt] [RecordGroup.group_uuid]
	// require record to be within a specific group
	GroupUuid *UUID `protobuf:"bytes,2,opt,name=group_uuid,json=groupUuid,proto3" json:"group_uuid,omitempty"`
	// [Opt] [Record.result_hash]
	// specify a specific record inside a scope (and group) by result-hash
	Hash string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	// [Opt] [Record.result_name]
	// specify a result-name of a record within a scope
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ProvenanceReference) Reset()         { *m = ProvenanceReference{} }
func (m *ProvenanceReference) String() string { return proto.CompactTextString(m) }
func (*ProvenanceReference) ProtoMessage()    {}
func (*ProvenanceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{12}
}
func (m *ProvenanceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvenanceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvenanceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvenanceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvenanceReference.Merge(m, src)
}
func (m *ProvenanceReference) XXX_Size() int {
	return m.Size()
}
func (m *ProvenanceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvenanceReference.DiscardUnknown(m)
}

var xxx_messageInfo_ProvenanceReference proto.InternalMessageInfo

func (m *ProvenanceReference) GetScopeUuid() *UUID {
	if m != nil {
		return m.ScopeUuid
	}
	return nil
}

func (m *ProvenanceReference) GetGroupUuid() *UUID {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *ProvenanceReference) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProvenanceReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type SignatureSet struct {
	Signatures []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *SignatureSet) Reset()         { *m = SignatureSet{} }
func (m *SignatureSet) String() string { return proto.CompactTextString(m) }
func (*SignatureSet) ProtoMessage()    {}
func (*SignatureSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{13}
}
func (m *SignatureSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureSet.Merge(m, src)
}
func (m *SignatureSet) XXX_Size() int {
	return m.Size()
}
func (m *SignatureSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureSet.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureSet proto.InternalMessageInfo

func (m *SignatureSet) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Signature struct {
	// Signature Detail
	Algo      string `protobuf:"bytes,1,opt,name=algo,proto3" json:"algo,omitempty"`
	Provider  string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	Signature string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Identity of signer
	Signer *SigningAndEncryptionPublicKeys `protobuf:"bytes,4,opt,name=signer,proto3" json:"signer,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{14}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *Signature) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Signature) GetSigner() *SigningAndEncryptionPublicKeys {
	if m != nil {
		return m.Signer
	}
	return nil
}

type SigningAndEncryptionPublicKeys struct {
	SigningPublicKey    *PublicKey `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	EncryptionPublicKey *PublicKey `protobuf:"bytes,2,opt,name=encryption_public_key,json=encryptionPublicKey,proto3" json:"encryption_public_key,omitempty"`
}

func (m *SigningAndEncryptionPublicKeys) Reset()         { *m = SigningAndEncryptionPublicKeys{} }
func (m *SigningAndEncryptionPublicKeys) String() string { return proto.CompactTextString(m) }
func (*SigningAndEncryptionPublicKeys) ProtoMessage()    {}
func (*SigningAndEncryptionPublicKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{15}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningAndEncryptionPublicKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningAndEncryptionPublicKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.Merge(m, src)
}
func (m *SigningAndEncryptionPublicKeys) XXX_Size() int {
	return m.Size()
}
func (m *SigningAndEncryptionPublicKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningAndEncryptionPublicKeys.DiscardUnknown(m)
}

var xxx_messageInfo_SigningAndEncryptionPublicKeys proto.InternalMessageInfo

func (m *SigningAndEncryptionPublicKeys) GetSigningPublicKey() *PublicKey {
	if m != nil {
		return m.SigningPublicKey
	}
	return nil
}

func (m *SigningAndEncryptionPublicKeys) GetEncryptionPublicKey() *PublicKey {
	if m != nil {
		return m.EncryptionPublicKey
	}
	return nil
}

type PublicKey struct {
	PublicKeyBytes []byte         `protobuf:"bytes,1,opt,name=public_key_bytes,json=publicKeyBytes,proto3" json:"public_key_bytes,omitempty"`
	Type           PublicKeyType  `protobuf:"varint,2,opt,name=type,proto3,enum=provenance.metadata.v1.p8e.PublicKeyType" json:"type,omitempty"`
	Curve          PublicKeyCurve `protobuf:"varint,3,opt,name=curve,proto3,enum=provenance.metadata.v1.p8e.PublicKeyCurve" json:"curve,omitempty"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{16}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKeyBytes() []byte {
	if m != nil {
		return m.PublicKeyBytes
	}
	return nil
}

func (m *PublicKey) GetType() PublicKeyType {
	if m != nil {
		return m.Type
	}
	return PublicKeyType_ELLIPTIC
}

func (m *PublicKey) GetCurve() PublicKeyCurve {
	if m != nil {
		return m.Curve
	}
	return PublicKeyCurve_SECP256K1
}

type UUID struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UUID) Reset()         { *m = UUID{} }
func (m *UUID) String() string { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()    {}
func (*UUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{17}
}
func (m *UUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID.Merge(m, src)
}
func (m *UUID) XXX_Size() int {
	return m.Size()
}
func (m *UUID) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID.DiscardUnknown(m)
}

var xxx_messageInfo_UUID proto.InternalMessageInfo

func (m *UUID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A Timestamp represents a point in time using values relative to the epoch.
type Timestamp struct {
	// Represents seconds of UTC time since Unix epoch
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_92e2ab9f03ad9d0c, []int{18}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

func init() {
	proto.RegisterEnum("provenance.metadata.v1.p8e.DefinitionSpecType", DefinitionSpecType_name, DefinitionSpecType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PublicKeyCurve", PublicKeyCurve_name, PublicKeyCurve_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PublicKeyType", PublicKeyType_name, PublicKeyType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.ExecutionResultType", ExecutionResultType_name, ExecutionResultType_value)
	proto.RegisterEnum("provenance.metadata.v1.p8e.PartyType", PartyType_name, PartyType_value)
	proto.RegisterType((*P8EMsgMemorializeP8EContractRequest)(nil), "provenance.metadata.v1.p8e.P8eMsgMemorializeP8eContractRequest")
	proto.RegisterType((*P8EMsgMemorializeP8EContractResponse)(nil), "provenance.metadata.v1.p8e.P8eMsgMemorializeP8eContractResponse")
	proto.RegisterType((*Contract)(nil), "provenance.metadata.v1.p8e.Contract")
	proto.RegisterType((*DefinitionSpec)(nil), "provenance.metadata.v1.p8e.DefinitionSpec")
	proto.RegisterType((*Fact)(nil), "provenance.metadata.v1.p8e.Fact")
	proto.RegisterType((*Condition)(nil), "provenance.metadata.v1.p8e.Condition")
	proto.RegisterType((*Consideration)(nil), "provenance.metadata.v1.p8e.Consideration")
	proto.RegisterType((*ProposedFact)(nil), "provenance.metadata.v1.p8e.ProposedFact")
	proto.RegisterType((*ExecutionResult)(nil), "provenance.metadata.v1.p8e.ExecutionResult")
	proto.RegisterType((*Recitals)(nil), "provenance.metadata.v1.p8e.Recitals")
	proto.RegisterType((*Recital)(nil), "provenance.metadata.v1.p8e.Recital")
	proto.RegisterType((*Location)(nil), "provenance.metadata.v1.p8e.Location")
	proto.RegisterType((*ProvenanceReference)(nil), "provenance.metadata.v1.p8e.ProvenanceReference")
	proto.RegisterType((*SignatureSet)(nil), "provenance.metadata.v1.p8e.SignatureSet")
	proto.RegisterType((*Signature)(nil), "provenance.metadata.v1.p8e.Signature")
	proto.RegisterType((*SigningAndEncryptionPublicKeys)(nil), "provenance.metadata.v1.p8e.SigningAndEncryptionPublicKeys")
	proto.RegisterType((*PublicKey)(nil), "provenance.metadata.v1.p8e.PublicKey")
	proto.RegisterType((*UUID)(nil), "provenance.metadata.v1.p8e.UUID")
	proto.RegisterType((*Timestamp)(nil), "provenance.metadata.v1.p8e.Timestamp")
}

func init() {
	proto.RegisterFile("provenance/metadata/v1/p8e/p8e.proto", fileDescriptor_92e2ab9f03ad9d0c)
}

var fileDescriptor_92e2ab9f03ad9d0c = []byte{
	// 1558 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x6f, 0xdb, 0x46,
	0x16, 0x37, 0x25, 0x59, 0x96, 0x9e, 0x65, 0x2d, 0x33, 0x4e, 0xb2, 0x4a, 0x10, 0x0b, 0x0e, 0x93,
	0x00, 0x8e, 0x17, 0x91, 0x11, 0xef, 0x07, 0x8c, 0x2c, 0x82, 0x58, 0x96, 0xe9, 0x2c, 0xd7, 0xb6,
	0xc4, 0x0c, 0xa5, 0x04, 0xe9, 0x45, 0xa0, 0xc9, 0x89, 0x43, 0x44, 0x26, 0x59, 0x0e, 0xe9, 0xc6,
	0x3d, 0xf5, 0xd0, 0x43, 0x7b, 0xeb, 0x1f, 0xd0, 0x43, 0x7b, 0x2e, 0x7a, 0xed, 0xb5, 0xa7, 0x02,
	0x3d, 0xe6, 0xd8, 0x63, 0x91, 0xf4, 0xd4, 0xbf, 0xa2, 0x98, 0xe1, 0xa7, 0x14, 0x87, 0x52, 0xd2,
	0x1e, 0x0c, 0x70, 0xde, 0x7b, 0xbf, 0xf7, 0x35, 0xef, 0x63, 0x2c, 0xb8, 0xe9, 0x7a, 0xce, 0x29,
	0xb1, 0x75, 0xdb, 0x20, 0x1b, 0x27, 0xc4, 0xd7, 0x4d, 0xdd, 0xd7, 0x37, 0x4e, 0xef, 0x6e, 0xb8,
	0x5b, 0x84, 0xfd, 0xb5, 0x5c, 0xcf, 0xf1, 0x1d, 0x74, 0x35, 0x95, 0x6a, 0xc5, 0x52, 0xad, 0xd3,
	0xbb, 0x2d, 0x77, 0x8b, 0x48, 0xbf, 0x17, 0xe0, 0x86, 0xba, 0x45, 0x0e, 0xe9, 0xf1, 0x21, 0x39,
	0x71, 0x3c, 0x4b, 0x1f, 0x59, 0x9f, 0x12, 0x75, 0x8b, 0x74, 0x1c, 0xdb, 0xf7, 0x74, 0xc3, 0xc7,
	0xe4, 0xe3, 0x80, 0x50, 0x1f, 0x5d, 0x81, 0x0a, 0x35, 0x1c, 0x97, 0x0c, 0x2d, 0xb3, 0x21, 0xac,
	0x0a, 0x6b, 0x55, 0xbc, 0xc0, 0xcf, 0x8a, 0xc9, 0x58, 0xc7, 0x9e, 0x13, 0xb8, 0x8c, 0x55, 0x08,
	0x59, 0xfc, 0xac, 0x98, 0xe8, 0x3a, 0xd4, 0xc8, 0x4b, 0x62, 0x04, 0xbe, 0xe5, 0xd8, 0x8c, 0x5d,
	0xe4, 0xec, 0xc5, 0x84, 0xa6, 0x98, 0x68, 0x1b, 0x2a, 0x1e, 0x31, 0x2c, 0x5f, 0x1f, 0xd1, 0x46,
	0x69, 0x55, 0x58, 0x5b, 0xdc, 0xbc, 0xd9, 0x7a, 0xb7, 0xbf, 0x2d, 0x1c, 0xc9, 0xe2, 0x04, 0xc5,
	0x34, 0x18, 0x91, 0xb7, 0x8d, 0xf9, 0xe9, 0x1a, 0x92, 0xc8, 0x12, 0x14, 0xfa, 0x1f, 0x00, 0xb5,
	0x8e, 0x6d, 0xdd, 0x0f, 0x3c, 0x42, 0x1b, 0x65, 0xae, 0x63, 0x2d, 0x4f, 0x87, 0x16, 0x4b, 0x6b,
	0xc4, 0xc7, 0x19, 0x2c, 0x6a, 0xc0, 0x82, 0x65, 0x9f, 0x3a, 0x2f, 0x88, 0xd7, 0x58, 0x58, 0x15,
	0xd6, 0x6a, 0x38, 0x3e, 0xde, 0x2b, 0x34, 0x04, 0x69, 0x1d, 0x6e, 0xe6, 0xe7, 0x9a, 0xba, 0x8e,
	0x4d, 0x09, 0x97, 0xfd, 0xad, 0x04, 0x95, 0x98, 0x81, 0xfe, 0x0f, 0x60, 0x92, 0x67, 0x96, 0x6d,
	0xb1, 0xa4, 0xf1, 0xfc, 0x2f, 0x6e, 0xae, 0xe7, 0x39, 0xb8, 0x9b, 0x48, 0x6b, 0x2e, 0x31, 0x70,
	0x06, 0x8d, 0xfe, 0x05, 0x25, 0xea, 0x12, 0x83, 0x5f, 0xd5, 0xe2, 0xe6, 0x6a, 0x9e, 0x96, 0x3d,
	0xe6, 0x14, 0x97, 0x46, 0xfd, 0x34, 0xb0, 0x22, 0x07, 0xde, 0x9b, 0x96, 0x1f, 0xcb, 0x3e, 0x6e,
	0xdb, 0xa6, 0x6c, 0x1b, 0xde, 0x99, 0xcb, 0x0c, 0xab, 0xc1, 0xd1, 0xc8, 0x32, 0xf6, 0xc9, 0x19,
	0x4d, 0x92, 0x82, 0xb6, 0xa0, 0x6c, 0xd9, 0x6e, 0xe0, 0xb3, 0xab, 0x2f, 0xce, 0xe4, 0x4d, 0x24,
	0x8f, 0x64, 0x00, 0xc3, 0xb1, 0x4d, 0x1e, 0x12, 0x6d, 0xcc, 0x73, 0xf4, 0xad, 0x29, 0xd7, 0x1e,
	0x4a, 0xe3, 0x0c, 0x10, 0x3d, 0x82, 0xba, 0xe1, 0xd8, 0xd4, 0x32, 0x89, 0xa7, 0x87, 0xaa, 0xca,
	0x5c, 0xd5, 0xed, 0x29, 0xaa, 0x52, 0x04, 0x9e, 0x50, 0x80, 0x1e, 0x64, 0x0a, 0x7a, 0x81, 0x2b,
	0xbb, 0x31, 0x43, 0x41, 0x67, 0xea, 0xf9, 0x16, 0xd4, 0x7d, 0xeb, 0x84, 0xd0, 0x61, 0xd8, 0x26,
	0xc4, 0x6c, 0x54, 0x56, 0x85, 0xb5, 0x79, 0xbc, 0xc4, 0xa9, 0x72, 0x44, 0x44, 0xbb, 0x00, 0xd4,
	0xd7, 0x3d, 0x7f, 0xc8, 0xc8, 0x8d, 0x2a, 0xbf, 0x94, 0xdc, 0x0c, 0xf4, 0x19, 0xdc, 0xd7, 0x4f,
	0x5c, 0x5c, 0xe5, 0x40, 0x76, 0x96, 0x3e, 0x2b, 0x40, 0x7d, 0xbc, 0x58, 0x10, 0x82, 0x92, 0xad,
	0x9f, 0x90, 0xa8, 0xcd, 0xf9, 0x37, 0x7a, 0x04, 0x17, 0x3c, 0x42, 0x9d, 0xc0, 0x33, 0xc8, 0x70,
	0xe4, 0x18, 0x3c, 0xd4, 0xa8, 0x82, 0x72, 0x9b, 0xed, 0x20, 0x92, 0xc5, 0x62, 0x0c, 0x8f, 0x29,
	0xa8, 0x03, 0xd5, 0xa4, 0x71, 0xa2, 0x9a, 0xba, 0x35, 0x53, 0xcf, 0xe1, 0x14, 0x87, 0x76, 0xa0,
	0xe4, 0x9f, 0xb9, 0x84, 0x4f, 0x8e, 0xfa, 0x66, 0x6b, 0xf6, 0x96, 0xe8, 0x9f, 0xb9, 0x04, 0x73,
	0xac, 0x44, 0xa0, 0xc4, 0x4a, 0xeb, 0xdc, 0xb8, 0x15, 0x58, 0x62, 0x3a, 0x3e, 0x2c, 0xe6, 0x1a,
	0xa3, 0xc6, 0x27, 0xe9, 0x13, 0xa8, 0x26, 0x35, 0xc8, 0xee, 0x38, 0xa9, 0xc2, 0x61, 0xc6, 0xea,
	0x52, 0x42, 0xed, 0x32, 0xf3, 0x1d, 0x28, 0x7b, 0x84, 0x06, 0x23, 0x3f, 0xb2, 0xfb, 0x8f, 0x3c,
	0xbb, 0x72, 0x3c, 0x55, 0x31, 0x87, 0xe0, 0x08, 0x2a, 0xfd, 0x24, 0xc0, 0xd2, 0x58, 0xc9, 0xa2,
	0x3b, 0x80, 0xc6, 0x8a, 0x36, 0xeb, 0xc1, 0x85, 0x31, 0x0e, 0xf7, 0x62, 0x3b, 0xe9, 0xd2, 0x02,
	0xaf, 0xe7, 0xdc, 0xd1, 0xa8, 0x7a, 0x8e, 0xeb, 0x50, 0x62, 0x8e, 0x75, 0x6b, 0x1a, 0x47, 0xf1,
	0xc3, 0xe3, 0xf8, 0x56, 0x80, 0x5a, 0x56, 0xfb, 0xb9, 0x17, 0x86, 0xa0, 0xf4, 0x5c, 0xa7, 0xcf,
	0xa3, 0x45, 0xc4, 0xbf, 0xd1, 0x35, 0xa8, 0x1a, 0x23, 0x9d, 0x52, 0x2e, 0x1c, 0xae, 0xa0, 0x94,
	0x80, 0xf6, 0xa1, 0xc2, 0xdc, 0xa0, 0xbe, 0xe3, 0x45, 0x0b, 0x68, 0x63, 0x4a, 0x7c, 0x11, 0x0b,
	0x93, 0x67, 0xc4, 0x23, 0xec, 0x23, 0x51, 0x20, 0x7d, 0x59, 0x80, 0xbf, 0x4d, 0xf8, 0xcf, 0xd2,
	0xe7, 0x04, 0xbe, 0x1b, 0xf8, 0xd1, 0xe0, 0x7e, 0x8f, 0xf4, 0x85, 0x38, 0xf4, 0x70, 0xac, 0x0c,
	0xea, 0xf9, 0x0e, 0x4e, 0x98, 0xe7, 0x85, 0x1e, 0xc1, 0xd1, 0x1e, 0x2c, 0x7a, 0xc4, 0x70, 0x3c,
	0x93, 0x98, 0x43, 0xdd, 0x9f, 0xa5, 0xeb, 0xd2, 0xa1, 0x01, 0x31, 0xb2, 0xed, 0xa3, 0x1b, 0xb0,
	0x44, 0x3c, 0xcf, 0xf1, 0x86, 0x27, 0x84, 0x52, 0xfd, 0x38, 0xec, 0xbf, 0x2a, 0xae, 0x71, 0xe2,
	0x61, 0x48, 0x93, 0x14, 0xa8, 0xc4, 0xdb, 0x1a, 0xdd, 0x87, 0x05, 0x57, 0xf7, 0x7c, 0x8b, 0xd0,
	0x86, 0x30, 0xfb, 0x4c, 0x8c, 0x31, 0xd2, 0x8f, 0x02, 0x2c, 0x44, 0x44, 0x16, 0x03, 0xeb, 0x7f,
	0xe2, 0x0d, 0x3d, 0x67, 0x14, 0x5e, 0x7e, 0x3d, 0x3f, 0x06, 0x55, 0xf7, 0xfc, 0x33, 0x9e, 0x07,
	0x08, 0x91, 0xd8, 0x19, 0x11, 0x84, 0xa1, 0x1c, 0x9e, 0xa2, 0xde, 0xfa, 0x33, 0x0b, 0x2d, 0xd2,
	0xc4, 0xd6, 0xbf, 0x6e, 0x9a, 0x1e, 0xa1, 0x94, 0xe7, 0xb6, 0x86, 0xe3, 0xa3, 0xf4, 0x02, 0x2a,
	0xc9, 0xe4, 0x6b, 0x43, 0xd1, 0x23, 0xcf, 0xa2, 0x6a, 0x78, 0xef, 0x62, 0x63, 0xd8, 0xf1, 0x92,
	0x2e, 0x4c, 0x94, 0x34, 0x4b, 0xd7, 0xf2, 0x39, 0x50, 0xf4, 0x00, 0x20, 0x7c, 0xc4, 0x05, 0x41,
	0xf4, 0x8c, 0x9b, 0xb2, 0x72, 0x07, 0x03, 0x65, 0x17, 0x57, 0x39, 0x66, 0x10, 0x58, 0x26, 0x53,
	0x10, 0x3e, 0xf5, 0xb8, 0x82, 0xc2, 0xac, 0x0a, 0x38, 0x86, 0x2b, 0x88, 0xdb, 0xb3, 0x98, 0x69,
	0xcf, 0xb8, 0x8d, 0x4b, 0x69, 0x1b, 0x4b, 0x03, 0xa8, 0x65, 0xdf, 0x58, 0x6c, 0xdd, 0x67, 0x5e,
	0x68, 0xc2, 0xf4, 0x75, 0x9f, 0x6e, 0x8b, 0x0c, 0x50, 0xfa, 0x5e, 0x80, 0x6a, 0xc2, 0x61, 0x86,
	0xf5, 0xd1, 0xb1, 0x13, 0xcf, 0x0f, 0xf6, 0x8d, 0xae, 0x42, 0x85, 0x69, 0x65, 0x03, 0x30, 0xca,
	0x6b, 0x72, 0x66, 0x49, 0x1f, 0xdf, 0x58, 0xd5, 0xec, 0x2a, 0x4a, 0xeb, 0xa9, 0xf4, 0x57, 0xd5,
	0x93, 0xf4, 0x4a, 0x80, 0x66, 0xbe, 0x28, 0xd2, 0x00, 0xd1, 0x50, 0x62, 0xe8, 0x72, 0xea, 0xf0,
	0x05, 0x39, 0x8b, 0xee, 0x36, 0xbf, 0x2b, 0x62, 0x1d, 0x58, 0x8c, 0x14, 0x24, 0x14, 0xf4, 0x14,
	0x2e, 0x91, 0xc4, 0x58, 0x56, 0x6f, 0xe1, 0x7d, 0xf4, 0x2e, 0x93, 0xb7, 0x1d, 0x96, 0x7e, 0x10,
	0xa0, 0x9a, 0x1a, 0x5a, 0x03, 0x31, 0xd5, 0x3e, 0x3c, 0x3a, 0xf3, 0xf9, 0xed, 0xb2, 0xce, 0xa9,
	0xbb, 0xb1, 0xd0, 0x0e, 0xa3, 0xa2, 0xfb, 0xd1, 0xa6, 0x0f, 0x27, 0xe0, 0xed, 0x99, 0x3c, 0x48,
	0x97, 0x3c, 0xda, 0x86, 0x79, 0x23, 0xf0, 0x4e, 0xc3, 0x7b, 0xab, 0xe7, 0x3f, 0x9e, 0x13, 0x7c,
	0x87, 0x21, 0x70, 0x08, 0x94, 0xae, 0x41, 0x89, 0x55, 0x33, 0xba, 0x08, 0xf3, 0xa7, 0xfa, 0x28,
	0x88, 0xd7, 0x4e, 0x78, 0x90, 0xfe, 0x0b, 0xd5, 0x64, 0x54, 0xb2, 0x31, 0x40, 0x09, 0xdb, 0xe4,
	0x61, 0x30, 0x45, 0x1c, 0x1f, 0x19, 0xd8, 0xd6, 0x6d, 0x87, 0xf2, 0x30, 0xe6, 0x71, 0x78, 0x58,
	0xff, 0x5a, 0x00, 0xf4, 0xf6, 0xf3, 0x04, 0xad, 0xc2, 0xb5, 0x5d, 0x79, 0x4f, 0xe9, 0x2a, 0x7d,
	0xa5, 0xd7, 0x1d, 0x6a, 0xaa, 0xdc, 0x19, 0xf6, 0x9f, 0xaa, 0xf2, 0x70, 0xd0, 0xdd, 0xef, 0xf6,
	0x9e, 0x74, 0xc5, 0x39, 0x74, 0x1d, 0x56, 0xce, 0x95, 0x50, 0x71, 0x4f, 0xed, 0x69, 0xf2, 0xae,
	0x28, 0xa0, 0x15, 0xb8, 0x72, 0xae, 0xc8, 0x5e, 0xbb, 0xd3, 0x17, 0x0b, 0x48, 0x82, 0xe6, 0x3b,
	0xd9, 0xc3, 0x03, 0x45, 0xeb, 0x8b, 0xc5, 0xf5, 0xdb, 0x50, 0x1f, 0x4f, 0x09, 0x5a, 0x82, 0xaa,
	0x26, 0x77, 0xd4, 0xcd, 0x7f, 0xff, 0x67, 0xff, 0xae, 0x38, 0x87, 0x2a, 0x50, 0x62, 0xdf, 0xa2,
	0xb0, 0xbe, 0x02, 0x4b, 0x63, 0xd9, 0x47, 0x35, 0xa8, 0xc8, 0x07, 0x07, 0x8a, 0xda, 0x57, 0x3a,
	0xe2, 0xdc, 0xba, 0x0b, 0xcb, 0xe7, 0xac, 0x27, 0xf4, 0x77, 0x58, 0xc6, 0xb2, 0x36, 0x38, 0xe8,
	0x4f, 0xc6, 0x77, 0x11, 0xc4, 0x2c, 0x43, 0x6d, 0x6b, 0x9a, 0x28, 0x4c, 0x52, 0xb5, 0x7d, 0x45,
	0x15, 0x0b, 0x93, 0xd4, 0xbd, 0xb6, 0x72, 0x20, 0x16, 0xd7, 0x3f, 0x2f, 0x40, 0x35, 0x99, 0xff,
	0xe8, 0x32, 0x20, 0xb5, 0x8d, 0xfb, 0x4f, 0x27, 0xed, 0x5c, 0x81, 0x4b, 0x19, 0x7a, 0x0f, 0x2b,
	0x0f, 0x95, 0x6e, 0xbb, 0xdf, 0xc3, 0xa2, 0xc0, 0x7c, 0xcb, 0xb0, 0x34, 0x19, 0x3f, 0x56, 0x3a,
	0x32, 0x16, 0x0b, 0x13, 0x0c, 0xa5, 0xfb, 0x58, 0xd6, 0x18, 0xa2, 0x88, 0x1a, 0x70, 0x31, 0xc3,
	0xe8, 0x0c, 0xb4, 0x7e, 0x6f, 0x57, 0x69, 0x77, 0xc5, 0x12, 0x73, 0x31, 0x6b, 0xe6, 0x49, 0x57,
	0xc6, 0xe2, 0xfc, 0x84, 0x7c, 0x7b, 0x6f, 0x4f, 0x39, 0x50, 0xda, 0x7d, 0x59, 0x2c, 0x4f, 0xb8,
	0xdb, 0x3b, 0xec, 0x2a, 0x3b, 0x03, 0x4d, 0x5c, 0x98, 0x70, 0x57, 0xc5, 0xbd, 0xc7, 0x72, 0xb7,
	0xdd, 0xed, 0xc8, 0x62, 0x05, 0x5d, 0x82, 0x0b, 0x19, 0xd6, 0x61, 0x1b, 0xef, 0xcb, 0x58, 0xac,
	0x6e, 0x7e, 0x27, 0x40, 0x39, 0xfc, 0xd7, 0x13, 0x7d, 0x23, 0xc0, 0xe5, 0xf3, 0xff, 0xff, 0x44,
	0x0f, 0x72, 0xbb, 0x62, 0xfa, 0xaf, 0x04, 0x57, 0xb7, 0x3f, 0x5c, 0x41, 0xf8, 0xaf, 0xaf, 0x54,
	0xfc, 0xa2, 0x20, 0xec, 0xd0, 0x9f, 0x5f, 0x37, 0x85, 0x57, 0xaf, 0x9b, 0xc2, 0xaf, 0xaf, 0x9b,
	0xc2, 0x57, 0x6f, 0x9a, 0x73, 0xaf, 0xde, 0x34, 0xe7, 0x7e, 0x79, 0xd3, 0x9c, 0x83, 0x15, 0xcb,
	0xc9, 0x31, 0xa1, 0x0a, 0x1f, 0x6d, 0x1d, 0x5b, 0xfe, 0xf3, 0xe0, 0xa8, 0x65, 0x38, 0x27, 0x1b,
	0xa9, 0xe0, 0x1d, 0xcb, 0xc9, 0x9c, 0x36, 0x5e, 0xa6, 0x3f, 0x96, 0xb0, 0xe1, 0x40, 0x37, 0xdc,
	0x2d, 0x72, 0x54, 0xe6, 0x3f, 0x96, 0xfc, 0xf3, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfd, 0xf9,
	0x54, 0x1b, 0x54, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// P8EMsgClient is the client API for P8EMsg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type P8EMsgClient interface {
	// MemorializeContract records the results of a P8e contract execution as a session and set of records in a scope
	MemorializeP8EContract(ctx context.Context, in *P8EMsgMemorializeP8EContractRequest, opts ...grpc.CallOption) (*P8EMsgMemorializeP8EContractResponse, error)
}

type p8EMsgClient struct {
	cc grpc1.ClientConn
}

func NewP8EMsgClient(cc grpc1.ClientConn) P8EMsgClient {
	return &p8EMsgClient{cc}
}

// Deprecated: Do not use.
func (c *p8EMsgClient) MemorializeP8EContract(ctx context.Context, in *P8EMsgMemorializeP8EContractRequest, opts ...grpc.CallOption) (*P8EMsgMemorializeP8EContractResponse, error) {
	out := new(P8EMsgMemorializeP8EContractResponse)
	err := c.cc.Invoke(ctx, "/provenance.metadata.v1.p8e.P8eMsg/MemorializeP8eContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// P8EMsgServer is the server API for P8EMsg service.
type P8EMsgServer interface {
	// MemorializeContract records the results of a P8e contract execution as a session and set of records in a scope
	MemorializeP8EContract(context.Context, *P8EMsgMemorializeP8EContractRequest) (*P8EMsgMemorializeP8EContractResponse, error)
}

// UnimplementedP8EMsgServer can be embedded to have forward compatible implementations.
type UnimplementedP8EMsgServer struct {
}

func (*UnimplementedP8EMsgServer) MemorializeP8EContract(ctx context.Context, req *P8EMsgMemorializeP8EContractRequest) (*P8EMsgMemorializeP8EContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemorializeP8EContract not implemented")
}

func RegisterP8EMsgServer(s grpc1.Server, srv P8EMsgServer) {
	s.RegisterService(&_P8EMsg_serviceDesc, srv)
}

func _P8EMsg_MemorializeP8EContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(P8EMsgMemorializeP8EContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P8EMsgServer).MemorializeP8EContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/provenance.metadata.v1.p8e.P8eMsg/MemorializeP8EContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P8EMsgServer).MemorializeP8EContract(ctx, req.(*P8EMsgMemorializeP8EContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _P8EMsg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "provenance.metadata.v1.p8e.P8eMsg",
	HandlerType: (*P8EMsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MemorializeP8eContract",
			Handler:    _P8EMsg_MemorializeP8EContract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "provenance/metadata/v1/p8e/p8e.proto",
}

func (m *P8EMsgMemorializeP8EContractRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P8EMsgMemorializeP8EContractRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P8EMsgMemorializeP8EContractRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Invoker) > 0 {
		i -= len(m.Invoker)
		copy(dAtA[i:], m.Invoker)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Invoker)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Signatures != nil {
		{
			size, err := m.Signatures.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Contract != nil {
		{
			size, err := m.Contract.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Recitals != nil {
		{
			size, err := m.Recitals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExecutionId) > 0 {
		i -= len(m.ExecutionId)
		copy(dAtA[i:], m.ExecutionId)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ExecutionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P8EMsgMemorializeP8EContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P8EMsgMemorializeP8EContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P8EMsgMemorializeP8EContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TimesExecuted != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.TimesExecuted))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Recitals) > 0 {
		for iNdEx := len(m.Recitals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recitals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Considerations) > 0 {
		for iNdEx := len(m.Considerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Considerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Invoker != nil {
		{
			size, err := m.Invoker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Definition != nil {
		{
			size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefinitionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefinitionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefinitionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ResourceLocation != nil {
		{
			size, err := m.ResourceLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Fact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataLocation != nil {
		{
			size, err := m.DataLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConditionName) > 0 {
		i -= len(m.ConditionName)
		copy(dAtA[i:], m.ConditionName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ConditionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Consideration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Consideration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Consideration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ConsiderationName) > 0 {
		i -= len(m.ConsiderationName)
		copy(dAtA[i:], m.ConsiderationName)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ConsiderationName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposedFact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposedFact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposedFact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ancestor != nil {
		{
			size, err := m.Ancestor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if m.RecordedAt != nil {
		{
			size, err := m.RecordedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Recitals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recitals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recitals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parties) > 0 {
		for iNdEx := len(m.Parties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Recital) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recital) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recital) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SignerRole != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.SignerRole))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Classname) > 0 {
		i -= len(m.Classname)
		copy(dAtA[i:], m.Classname)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Classname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvenanceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvenanceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvenanceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupUuid != nil {
		{
			size, err := m.GroupUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ScopeUuid != nil {
		{
			size, err := m.ScopeUuid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintP8E(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Algo) > 0 {
		i -= len(m.Algo)
		copy(dAtA[i:], m.Algo)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Algo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningAndEncryptionPublicKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningAndEncryptionPublicKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningAndEncryptionPublicKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptionPublicKey != nil {
		{
			size, err := m.EncryptionPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SigningPublicKey != nil {
		{
			size, err := m.SigningPublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintP8E(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Curve != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Curve))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicKeyBytes) > 0 {
		i -= len(m.PublicKeyBytes)
		copy(dAtA[i:], m.PublicKeyBytes)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.PublicKeyBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintP8E(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintP8E(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintP8E(dAtA []byte, offset int, v uint64) int {
	offset -= sovP8E(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *P8EMsgMemorializeP8EContractRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.ExecutionId)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Recitals != nil {
		l = m.Recitals.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Contract != nil {
		l = m.Contract.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signatures != nil {
		l = m.Signatures.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Invoker)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *P8EMsgMemorializeP8EContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Invoker != nil {
		l = m.Invoker.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Considerations) > 0 {
		for _, e := range m.Considerations {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if len(m.Recitals) > 0 {
		for _, e := range m.Recitals {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.TimesExecuted != 0 {
		n += 1 + sovP8E(uint64(m.TimesExecuted))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *DefinitionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.ResourceLocation != nil {
		l = m.ResourceLocation.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovP8E(uint64(m.Type))
	}
	return n
}

func (m *Fact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.DataLocation != nil {
		l = m.DataLocation.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConditionName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Consideration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsiderationName)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ProposedFact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Ancestor != nil {
		l = m.Ancestor.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ExecutionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovP8E(uint64(m.Result))
	}
	if m.RecordedAt != nil {
		l = m.RecordedAt.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Recitals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parties) > 0 {
		for _, e := range m.Parties {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *Recital) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignerRole != 0 {
		n += 1 + sovP8E(uint64(m.SignerRole))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Classname)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *ProvenanceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopeUuid != nil {
		l = m.ScopeUuid.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.GroupUuid != nil {
		l = m.GroupUuid.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *SignatureSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovP8E(uint64(l))
		}
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *SigningAndEncryptionPublicKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningPublicKey != nil {
		l = m.SigningPublicKey.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.EncryptionPublicKey != nil {
		l = m.EncryptionPublicKey.Size()
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKeyBytes)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovP8E(uint64(m.Type))
	}
	if m.Curve != 0 {
		n += 1 + sovP8E(uint64(m.Curve))
	}
	return n
}

func (m *UUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovP8E(uint64(l))
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovP8E(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovP8E(uint64(m.Nanos))
	}
	return n
}

func sovP8E(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozP8E(x uint64) (n int) {
	return sovP8E(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *P8EMsgMemorializeP8EContractRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P8eMsgMemorializeP8eContractRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P8eMsgMemorializeP8eContractRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recitals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recitals == nil {
				m.Recitals = &Recitals{}
			}
			if err := m.Recitals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contract == nil {
				m.Contract = &Contract{}
			}
			if err := m.Contract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatures == nil {
				m.Signatures = &SignatureSet{}
			}
			if err := m.Signatures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invoker = append(m.Invoker[:0], dAtA[iNdEx:postIndex]...)
			if m.Invoker == nil {
				m.Invoker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P8EMsgMemorializeP8EContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P8eMsgMemorializeP8eContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P8eMsgMemorializeP8eContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &DefinitionSpec{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Fact{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoker == nil {
				m.Invoker = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Invoker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &Fact{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Considerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Considerations = append(m.Considerations, &Consideration{})
			if err := m.Considerations[len(m.Considerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recitals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recitals = append(m.Recitals, &Recital{})
			if err := m.Recitals[len(m.Recitals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimesExecuted", wireType)
			}
			m.TimesExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimesExecuted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefinitionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefinitionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefinitionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLocation == nil {
				m.ResourceLocation = &Location{}
			}
			if err := m.ResourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DefinitionSpecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataLocation == nil {
				m.DataLocation = &Location{}
			}
			if err := m.DataLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &ExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Consideration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Consideration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Consideration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsiderationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsiderationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &ProposedFact{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &ExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposedFact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposedFact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposedFact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ancestor == nil {
				m.Ancestor = &ProvenanceReference{}
			}
			if err := m.Ancestor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &ProposedFact{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ExecutionResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecordedAt == nil {
				m.RecordedAt = &Timestamp{}
			}
			if err := m.RecordedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recitals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recitals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recitals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parties = append(m.Parties, &Recital{})
			if err := m.Parties[len(m.Parties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recital) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recital: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recital: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerRole", wireType)
			}
			m.SignerRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignerRole |= PartyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ProvenanceReference{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvenanceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvenanceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvenanceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeUuid == nil {
				m.ScopeUuid = &UUID{}
			}
			if err := m.ScopeUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUuid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupUuid == nil {
				m.GroupUuid = &UUID{}
			}
			if err := m.GroupUuid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &SigningAndEncryptionPublicKeys{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningAndEncryptionPublicKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningAndEncryptionPublicKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningPublicKey == nil {
				m.SigningPublicKey = &PublicKey{}
			}
			if err := m.SigningPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionPublicKey == nil {
				m.EncryptionPublicKey = &PublicKey{}
			}
			if err := m.EncryptionPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBytes = append(m.PublicKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyBytes == nil {
				m.PublicKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PublicKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			m.Curve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curve |= PublicKeyCurve(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthP8E
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthP8E
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipP8E(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthP8E
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipP8E(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowP8E
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowP8E
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthP8E
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupP8E
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthP8E
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthP8E        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowP8E          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupP8E = fmt.Errorf("proto: unexpected end of group")
)
