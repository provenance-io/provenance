// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/ledger/v1/ledger.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Day Count Conventions used in interest calculations.
type DayCountConvention int32

const (
	// Unspecified day count convention.
	//
	// This value is never a field's actual value, it just indicates that, for a given request, the day count convention
	// is not being provided. E.g. if this value is provided in a MsgUpdateInterestRateRequest, it indicates that the day
	// count convention is not being provided, and so should not be updated.
	//
	// DAY_COUNT_CONVENTION_UNSPECIFIED indicates that the day count convention is not being provided.
	// DAY_COUNT_CONVENTION_NOT_DEFINED indicates that the day count convention of the entry does not have a value.
	DAY_COUNT_CONVENTION_UNSPECIFIED DayCountConvention = 0
	// Actual/365: Uses the actual number of days in the period with a fixed denominator of 365
	// (or sometimes 365.25 to adjust for leap years).
	DAY_COUNT_CONVENTION_ACTUAL_365 DayCountConvention = 1
	// Actual/360: Uses the actual number of days in the period but divides by 360.
	DAY_COUNT_CONVENTION_ACTUAL_360 DayCountConvention = 2
	// 30/360: Assumes each month has 30 days and the year has 360 days.
	DAY_COUNT_CONVENTION_THIRTY_360 DayCountConvention = 3
	// Actual/Actual: Uses the actual number of days in the period and the actual days in the year
	// (365 or 366, depending on the year).
	DAY_COUNT_CONVENTION_ACTUAL_ACTUAL DayCountConvention = 4
	// 365/365: Always uses 365 days in the denominator regardless of leap years.
	DAY_COUNT_CONVENTION_DAYS_365 DayCountConvention = 5
	// 360/360: Always uses 360 days in both the numerator and denominator.
	DAY_COUNT_CONVENTION_DAYS_360 DayCountConvention = 6
	// Not Defined: The day count convention is not defined.
	//
	// This value indicates that the day count convention should be on record as not having a value. It could mean that
	// the day count convention is not one of the other values in this enum, or it could mean that it doesn't make sense
	// for the entry to have a day count convention. It could also just mean that the day count convention has not yet
	// been defined for the entry.
	//
	// DAY_COUNT_CONVENTION_UNSPECIFIED indicates that the day count convention is not being provided.
	// DAY_COUNT_CONVENTION_NOT_DEFINED indicates that the day count convention of the entry does not have a value.
	DAY_COUNT_CONVENTION_NOT_DEFINED DayCountConvention = 7
)

var DayCountConvention_name = map[int32]string{
	0: "DAY_COUNT_CONVENTION_UNSPECIFIED",
	1: "DAY_COUNT_CONVENTION_ACTUAL_365",
	2: "DAY_COUNT_CONVENTION_ACTUAL_360",
	3: "DAY_COUNT_CONVENTION_THIRTY_360",
	4: "DAY_COUNT_CONVENTION_ACTUAL_ACTUAL",
	5: "DAY_COUNT_CONVENTION_DAYS_365",
	6: "DAY_COUNT_CONVENTION_DAYS_360",
	7: "DAY_COUNT_CONVENTION_NOT_DEFINED",
}

var DayCountConvention_value = map[string]int32{
	"DAY_COUNT_CONVENTION_UNSPECIFIED":   0,
	"DAY_COUNT_CONVENTION_ACTUAL_365":    1,
	"DAY_COUNT_CONVENTION_ACTUAL_360":    2,
	"DAY_COUNT_CONVENTION_THIRTY_360":    3,
	"DAY_COUNT_CONVENTION_ACTUAL_ACTUAL": 4,
	"DAY_COUNT_CONVENTION_DAYS_365":      5,
	"DAY_COUNT_CONVENTION_DAYS_360":      6,
	"DAY_COUNT_CONVENTION_NOT_DEFINED":   7,
}

func (x DayCountConvention) String() string {
	return proto.EnumName(DayCountConvention_name, int32(x))
}

func (DayCountConvention) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}

// Interest Accrual Methods describing how interest is calculated over time.
type InterestAccrualMethod int32

const (
	// Unspecified interest accrual method.
	//
	// This value is never a field's actual value, it just indicates that, for a given request, the interest accrual
	// method is not being provided. E.g. if this value is provided in a MsgUpdateInterestRateRequest, it indicates that
	// the interest accrual method is not being provided, and so should not be updated.
	//
	// INTEREST_ACCRUAL_METHOD_UNSPECIFIED indicates that the interest accrual method is not being provided.
	// INTEREST_ACCRUAL_METHOD_NOT_DEFINED indicates that the interest accrual method of the entry does not have a value.
	INTEREST_ACCRUAL_METHOD_UNSPECIFIED InterestAccrualMethod = 0
	// Simple Interest: Calculated only on the principal amount.
	INTEREST_ACCRUAL_METHOD_SIMPLE_INTEREST InterestAccrualMethod = 1
	// Compound Interest: Calculated on both the principal and on previously accumulated interest.
	INTEREST_ACCRUAL_METHOD_COMPOUND_INTEREST InterestAccrualMethod = 2
	// Daily Compounding: Interest is compounded on a daily basis.
	INTEREST_ACCRUAL_METHOD_DAILY_COMPOUNDING InterestAccrualMethod = 3
	// Monthly Compounding: Interest is compounded each month.
	INTEREST_ACCRUAL_METHOD_MONTHLY_COMPOUNDING InterestAccrualMethod = 4
	// Quarterly Compounding: Interest is compounded every quarter.
	INTEREST_ACCRUAL_METHOD_QUARTERLY_COMPOUNDING InterestAccrualMethod = 5
	// Annually Compounding: Interest is compounded once per year.
	INTEREST_ACCRUAL_METHOD_ANNUAL_COMPOUNDING InterestAccrualMethod = 6
	// Continuous Compounding: The theoretical limit of compounding frequency where interest is compounded continuously.
	INTEREST_ACCRUAL_METHOD_CONTINUOUS_COMPOUNDING InterestAccrualMethod = 7
	// Not Defined: The interest accrual method is not defined.
	//
	// This value indicates that the interest accrual method should be on record as not having a value. It could mean that
	// the interest accrual method is not one of the other values in this enum, or it could mean that it doesn't make
	// sense for the entry to have an interest accrual method. It could also just mean that the interest accrual method
	// has not yet been defined for the entry.
	//
	// INTEREST_ACCRUAL_METHOD_UNSPECIFIED indicates that the interest accrual method is not being provided.
	// INTEREST_ACCRUAL_METHOD_NOT_DEFINED indicates that the interest accrual method of the entry does not have a value.
	INTEREST_ACCRUAL_METHOD_NOT_DEFINED InterestAccrualMethod = 8
)

var InterestAccrualMethod_name = map[int32]string{
	0: "INTEREST_ACCRUAL_METHOD_UNSPECIFIED",
	1: "INTEREST_ACCRUAL_METHOD_SIMPLE_INTEREST",
	2: "INTEREST_ACCRUAL_METHOD_COMPOUND_INTEREST",
	3: "INTEREST_ACCRUAL_METHOD_DAILY_COMPOUNDING",
	4: "INTEREST_ACCRUAL_METHOD_MONTHLY_COMPOUNDING",
	5: "INTEREST_ACCRUAL_METHOD_QUARTERLY_COMPOUNDING",
	6: "INTEREST_ACCRUAL_METHOD_ANNUAL_COMPOUNDING",
	7: "INTEREST_ACCRUAL_METHOD_CONTINUOUS_COMPOUNDING",
	8: "INTEREST_ACCRUAL_METHOD_NOT_DEFINED",
}

var InterestAccrualMethod_value = map[string]int32{
	"INTEREST_ACCRUAL_METHOD_UNSPECIFIED":            0,
	"INTEREST_ACCRUAL_METHOD_SIMPLE_INTEREST":        1,
	"INTEREST_ACCRUAL_METHOD_COMPOUND_INTEREST":      2,
	"INTEREST_ACCRUAL_METHOD_DAILY_COMPOUNDING":      3,
	"INTEREST_ACCRUAL_METHOD_MONTHLY_COMPOUNDING":    4,
	"INTEREST_ACCRUAL_METHOD_QUARTERLY_COMPOUNDING":  5,
	"INTEREST_ACCRUAL_METHOD_ANNUAL_COMPOUNDING":     6,
	"INTEREST_ACCRUAL_METHOD_CONTINUOUS_COMPOUNDING": 7,
	"INTEREST_ACCRUAL_METHOD_NOT_DEFINED":            8,
}

func (x InterestAccrualMethod) String() string {
	return proto.EnumName(InterestAccrualMethod_name, int32(x))
}

func (InterestAccrualMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}

// Payment frequencies for loan repayments.
type PaymentFrequency int32

const (
	// Unspecified payment frequency.
	//
	// This value is never a field's actual value, it just indicates that, for a given request, the payment frequency is
	// not being provided. E.g. if this value is provided in a MsgUpdatePaymentRequest, it indicates that the payment
	// frequency is not being provided, and so should not be updated.
	//
	// PAYMENT_FREQUENCY_UNSPECIFIED indicates that the payment frequency is not being provided.
	// PAYMENT_FREQUENCY_NOT_DEFINED indicates that the payment frequency of the entry does not have a value.
	PAYMENT_FREQUENCY_UNSPECIFIED PaymentFrequency = 0
	// Daily payments.
	PAYMENT_FREQUENCY_DAILY PaymentFrequency = 1
	// Weekly or biweekly payments.
	PAYMENT_FREQUENCY_WEEKLY PaymentFrequency = 2
	// Monthly payments (most common for consumer loans and mortgages).
	PAYMENT_FREQUENCY_MONTHLY PaymentFrequency = 3
	// Quarterly payments.
	PAYMENT_FREQUENCY_QUARTERLY PaymentFrequency = 4
	// Annual payments.
	PAYMENT_FREQUENCY_ANNUALLY PaymentFrequency = 5
	// Not Defined: The payment frequency is not defined.
	//
	// This value indicates that the payment frequency should be on record as not having a value. It could mean that the
	// payment frequency is not one of the other values in this enum, or it could mean that it doesn't make sense for the
	// entry to have a payment frequency. It could also just mean that the payment frequency has not yet been defined for
	// the entry.
	//
	// PAYMENT_FREQUENCY_UNSPECIFIED indicates that the payment frequency is not being provided.
	// PAYMENT_FREQUENCY_NOT_DEFINED indicates that the payment frequency of the entry does not have a value.
	PAYMENT_FREQUENCY_NOT_DEFINED PaymentFrequency = 6
)

var PaymentFrequency_name = map[int32]string{
	0: "PAYMENT_FREQUENCY_UNSPECIFIED",
	1: "PAYMENT_FREQUENCY_DAILY",
	2: "PAYMENT_FREQUENCY_WEEKLY",
	3: "PAYMENT_FREQUENCY_MONTHLY",
	4: "PAYMENT_FREQUENCY_QUARTERLY",
	5: "PAYMENT_FREQUENCY_ANNUALLY",
	6: "PAYMENT_FREQUENCY_NOT_DEFINED",
}

var PaymentFrequency_value = map[string]int32{
	"PAYMENT_FREQUENCY_UNSPECIFIED": 0,
	"PAYMENT_FREQUENCY_DAILY":       1,
	"PAYMENT_FREQUENCY_WEEKLY":      2,
	"PAYMENT_FREQUENCY_MONTHLY":     3,
	"PAYMENT_FREQUENCY_QUARTERLY":   4,
	"PAYMENT_FREQUENCY_ANNUALLY":    5,
	"PAYMENT_FREQUENCY_NOT_DEFINED": 6,
}

func (x PaymentFrequency) String() string {
	return proto.EnumName(PaymentFrequency_name, int32(x))
}

func (PaymentFrequency) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}

// LedgerClass contains the configuration for a ledger related to a particular class of asset. The asset class
// is defined by the either a scope spec `x/metadata`, or nft class `x/nft`. Ultimately, the configuration will
// assist in verifying the types that are associated with particular ledger entries.
type LedgerClass struct {
	// Unique ID for the ledger class (eg. 1, 2, 3, etc.).
	// This is necessary since the nft class does not have an owner.
	LedgerClassId string `protobuf:"bytes,1,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledgerClassId,omitempty"`
	// Scope Specification ID or NFT Class ID.
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"assetClassId,omitempty"`
	// Denom that this class of asset will be ledgered in.
	Denom string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty"`
	// Address of the maintainer for the ledger class.
	MaintainerAddress string `protobuf:"bytes,4,opt,name=maintainer_address,json=maintainerAddress,proto3" json:"maintainerAddress,omitempty"`
}

func (m *LedgerClass) Reset()         { *m = LedgerClass{} }
func (m *LedgerClass) String() string { return proto.CompactTextString(m) }
func (*LedgerClass) ProtoMessage()    {}
func (*LedgerClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}
func (m *LedgerClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClass.Merge(m, src)
}
func (m *LedgerClass) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClass) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClass.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClass proto.InternalMessageInfo

func (m *LedgerClass) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *LedgerClass) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *LedgerClass) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *LedgerClass) GetMaintainerAddress() string {
	if m != nil {
		return m.MaintainerAddress
	}
	return ""
}

// LedgerClassEntryType defines the types of possible ledger entries for a given asset class. These type codes allow
// for minimal data storage while providing a human readable description of the entry type.
type LedgerClassEntryType struct {
	// Unique ID for the entry type (eg. 1, 2, 3, etc.).
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the entry type (eg. "DISBURSEMENT", "PAYMENT", "ADJUSTMENT", "INTEREST", "FEE", "OTHER").
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the entry type (eg. "Disbursement", "Payment", "Adjustment", "Interest", "Fee", "Other").
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassEntryType) Reset()         { *m = LedgerClassEntryType{} }
func (m *LedgerClassEntryType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassEntryType) ProtoMessage()    {}
func (*LedgerClassEntryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}
func (m *LedgerClassEntryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassEntryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassEntryType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassEntryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassEntryType.Merge(m, src)
}
func (m *LedgerClassEntryType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassEntryType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassEntryType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassEntryType proto.InternalMessageInfo

func (m *LedgerClassEntryType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassEntryType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassEntryType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerClassStatusType defines the status types for a ledger class.
// These status types are used to track the status of underlying loan throughout the loan life cycle.
type LedgerClassStatusType struct {
	// Unique ID for the status type (eg. 1, 2, 3, etc.).
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the status type (eg. "IN_REPAYMENT", "IN_FORECLOSURE", "FORBEARANCE", "DEFERMENT", "BANKRUPTCY",
	// "CLOSED", "CANCELLED", "SUSPENDED", "OTHER").
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the status type (eg. "In Repayment", "In Foreclosure", "Forbearance", "Deferment", "Bankruptcy",
	// "Closed", "Cancelled", "Suspended", "Other").
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassStatusType) Reset()         { *m = LedgerClassStatusType{} }
func (m *LedgerClassStatusType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassStatusType) ProtoMessage()    {}
func (*LedgerClassStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}
func (m *LedgerClassStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassStatusType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassStatusType.Merge(m, src)
}
func (m *LedgerClassStatusType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassStatusType proto.InternalMessageInfo

func (m *LedgerClassStatusType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassStatusType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassStatusType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerKey is used as the unique key for an asset's ledger in the keeper.
type LedgerKey struct {
	// Identifier for the nft that this ledger is linked to.
	// This could be a `x/metadata` scope id or an `x/nft` nft id.
	// In order to create a ledger for an nft, the nft class must be registered in the ledger module as a LedgerClass.
	NftId string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nftId,omitempty"`
	// Scope Specification ID or NFT Class ID.
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"assetClassId,omitempty"`
}

func (m *LedgerKey) Reset()      { *m = LedgerKey{} }
func (*LedgerKey) ProtoMessage() {}
func (*LedgerKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{3}
}
func (m *LedgerKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerKey.Merge(m, src)
}
func (m *LedgerKey) XXX_Size() int {
	return m.Size()
}
func (m *LedgerKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerKey.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerKey proto.InternalMessageInfo

func (m *LedgerKey) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *LedgerKey) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

// Ledger defines an servicing ledger for an asset.
type Ledger struct {
	// The ledger key identifying the ledger.
	Key *LedgerKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The ledger class ID for the ledger.
	LedgerClassId string `protobuf:"bytes,2,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledgerClassId,omitempty"`
	// The status of the ledger.
	StatusTypeId int32 `protobuf:"varint,3,opt,name=status_type_id,json=statusTypeId,proto3" json:"statusTypeId,omitempty"`
	// The next payment date (days since epoch).
	NextPmtDate int32 `protobuf:"varint,4,opt,name=next_pmt_date,json=nextPmtDate,proto3" json:"nextPmtDate,omitempty"`
	// The next payment amount.
	// The units of this field are defined by the denom field in this ledger's class.
	NextPmtAmt cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=next_pmt_amt,json=nextPmtAmt,proto3,customtype=cosmossdk.io/math.Int" json:"nextPmtAmt,omitempty"`
	// The interest rate. Min = 0, Max = 100,000,000 = 100%, e.g. 4,321,987 = 4.321987%.
	InterestRate int32 `protobuf:"varint,6,opt,name=interest_rate,json=interestRate,proto3" json:"interestRate,omitempty"`
	// The maturity date (days since epoch).
	MaturityDate int32 `protobuf:"varint,7,opt,name=maturity_date,json=maturityDate,proto3" json:"maturityDate,omitempty"`
	// The day count convention for interest calculations.
	InterestDayCountConvention DayCountConvention `protobuf:"varint,8,opt,name=interest_day_count_convention,json=interestDayCountConvention,proto3,enum=provenance.ledger.v1.DayCountConvention,casttype=DayCountConvention" json:"interestDayCountConvention,omitempty"`
	// The interest accrual method for interest calculations.
	InterestAccrualMethod InterestAccrualMethod `protobuf:"varint,9,opt,name=interest_accrual_method,json=interestAccrualMethod,proto3,enum=provenance.ledger.v1.InterestAccrualMethod,casttype=InterestAccrualMethod" json:"interestAccrualMethod,omitempty"`
	// The payment frequency.
	PaymentFrequency PaymentFrequency `protobuf:"varint,10,opt,name=payment_frequency,json=paymentFrequency,proto3,enum=provenance.ledger.v1.PaymentFrequency,casttype=PaymentFrequency" json:"paymentFrequency,omitempty"`
}

func (m *Ledger) Reset()         { *m = Ledger{} }
func (m *Ledger) String() string { return proto.CompactTextString(m) }
func (*Ledger) ProtoMessage()    {}
func (*Ledger) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{4}
}
func (m *Ledger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ledger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ledger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ledger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ledger.Merge(m, src)
}
func (m *Ledger) XXX_Size() int {
	return m.Size()
}
func (m *Ledger) XXX_DiscardUnknown() {
	xxx_messageInfo_Ledger.DiscardUnknown(m)
}

var xxx_messageInfo_Ledger proto.InternalMessageInfo

func (m *Ledger) GetKey() *LedgerKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Ledger) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *Ledger) GetStatusTypeId() int32 {
	if m != nil {
		return m.StatusTypeId
	}
	return 0
}

func (m *Ledger) GetNextPmtDate() int32 {
	if m != nil {
		return m.NextPmtDate
	}
	return 0
}

func (m *Ledger) GetInterestRate() int32 {
	if m != nil {
		return m.InterestRate
	}
	return 0
}

func (m *Ledger) GetMaturityDate() int32 {
	if m != nil {
		return m.MaturityDate
	}
	return 0
}

func (m *Ledger) GetInterestDayCountConvention() DayCountConvention {
	if m != nil {
		return m.InterestDayCountConvention
	}
	return DAY_COUNT_CONVENTION_UNSPECIFIED
}

func (m *Ledger) GetInterestAccrualMethod() InterestAccrualMethod {
	if m != nil {
		return m.InterestAccrualMethod
	}
	return INTEREST_ACCRUAL_METHOD_UNSPECIFIED
}

func (m *Ledger) GetPaymentFrequency() PaymentFrequency {
	if m != nil {
		return m.PaymentFrequency
	}
	return PAYMENT_FREQUENCY_UNSPECIFIED
}

// LedgerClassBucketType represents a bucket type for a ledger class.
type LedgerClassBucketType struct {
	// Unique ID for the bucket type (eg. 1, 2, 3, etc.).
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the bucket type (eg. "PRINCIPAL", "INTEREST", "FEE", "OTHER").
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the bucket type (eg. "Principal", "Interest", "Fee", "Other").
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassBucketType) Reset()         { *m = LedgerClassBucketType{} }
func (m *LedgerClassBucketType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassBucketType) ProtoMessage()    {}
func (*LedgerClassBucketType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{5}
}
func (m *LedgerClassBucketType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassBucketType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassBucketType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassBucketType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassBucketType.Merge(m, src)
}
func (m *LedgerClassBucketType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassBucketType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassBucketType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassBucketType proto.InternalMessageInfo

func (m *LedgerClassBucketType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassBucketType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassBucketType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerEntry is an single entry in the ledger. An entry would be a payment, disbursement, adjustment, etc...
type LedgerEntry struct {
	// The correlation ID for tracking ledger entries with external systems (max 50 characters).
	CorrelationId string `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlationId,omitempty"`
	// If this entry reverses another entry, the correlation ID of the entry it reverses.
	ReversesCorrelationId string `protobuf:"bytes,2,opt,name=reverses_correlation_id,json=reversesCorrelationId,proto3" json:"reversesCorrelationId,omitempty"`
	// If true, this entry is a void and should not be included in the ledger balance calculations.
	IsVoid bool `protobuf:"varint,3,opt,name=is_void,json=isVoid,proto3" json:"isVoid,omitempty"`
	// Sequence number of the ledger entry (less than 300). This field is used to maintain the correct
	// order of entries when multiple entries share the same effective date. Entries are sorted first
	// by effective date, then by sequence.
	Sequence uint32 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// The type of ledger entry specified by the LedgerClassEntryType.id.
	EntryTypeId int32 `protobuf:"varint,5,opt,name=entry_type_id,json=entryTypeId,proto3" json:"entryTypeId,omitempty"`
	// The posted date (days since epoch).
	PostedDate int32 `protobuf:"varint,6,opt,name=posted_date,json=postedDate,proto3" json:"postedDate,omitempty"`
	// The effective date (days since epoch).
	EffectiveDate int32 `protobuf:"varint,7,opt,name=effective_date,json=effectiveDate,proto3" json:"effectiveDate,omitempty"`
	// The total amount of the ledger entry.
	// The units of this field are defined by the denom field in this ledger's class.
	TotalAmt cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=total_amt,json=totalAmt,proto3,customtype=cosmossdk.io/math.Int" json:"totalAmt,omitempty"`
	// Applied amounts represent how the entry affects different buckets.
	AppliedAmounts []*LedgerBucketAmount `protobuf:"bytes,9,rep,name=applied_amounts,json=appliedAmounts,proto3" json:"appliedAmounts,omitempty"`
	// Bucket balances represent the current state of funds in each bucket.
	BalanceAmounts []*BucketBalance `protobuf:"bytes,10,rep,name=balance_amounts,json=balanceAmounts,proto3" json:"balanceAmounts,omitempty"`
}

func (m *LedgerEntry) Reset()         { *m = LedgerEntry{} }
func (m *LedgerEntry) String() string { return proto.CompactTextString(m) }
func (*LedgerEntry) ProtoMessage()    {}
func (*LedgerEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{6}
}
func (m *LedgerEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerEntry.Merge(m, src)
}
func (m *LedgerEntry) XXX_Size() int {
	return m.Size()
}
func (m *LedgerEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerEntry proto.InternalMessageInfo

func (m *LedgerEntry) GetCorrelationId() string {
	if m != nil {
		return m.CorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetReversesCorrelationId() string {
	if m != nil {
		return m.ReversesCorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetIsVoid() bool {
	if m != nil {
		return m.IsVoid
	}
	return false
}

func (m *LedgerEntry) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *LedgerEntry) GetEntryTypeId() int32 {
	if m != nil {
		return m.EntryTypeId
	}
	return 0
}

func (m *LedgerEntry) GetPostedDate() int32 {
	if m != nil {
		return m.PostedDate
	}
	return 0
}

func (m *LedgerEntry) GetEffectiveDate() int32 {
	if m != nil {
		return m.EffectiveDate
	}
	return 0
}

func (m *LedgerEntry) GetAppliedAmounts() []*LedgerBucketAmount {
	if m != nil {
		return m.AppliedAmounts
	}
	return nil
}

func (m *LedgerEntry) GetBalanceAmounts() []*BucketBalance {
	if m != nil {
		return m.BalanceAmounts
	}
	return nil
}

// LedgerBucketAmount is the amount applied to a bucket. Applications to a bucket increase or
// decrease the balance of the bucket.
type LedgerBucketAmount struct {
	// The bucket type specified by the LedgerClassBucketType.id.
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucketTypeId,omitempty"`
	// The amount applied to the bucket.
	// The units of this field are defined by the denom field in this ledger's class.
	AppliedAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=applied_amt,json=appliedAmt,proto3,customtype=cosmossdk.io/math.Int" json:"appliedAmt,omitempty"`
}

func (m *LedgerBucketAmount) Reset()         { *m = LedgerBucketAmount{} }
func (m *LedgerBucketAmount) String() string { return proto.CompactTextString(m) }
func (*LedgerBucketAmount) ProtoMessage()    {}
func (*LedgerBucketAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{7}
}
func (m *LedgerBucketAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerBucketAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerBucketAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerBucketAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerBucketAmount.Merge(m, src)
}
func (m *LedgerBucketAmount) XXX_Size() int {
	return m.Size()
}
func (m *LedgerBucketAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerBucketAmount.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerBucketAmount proto.InternalMessageInfo

func (m *LedgerBucketAmount) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// BucketBalance represents the balance for a specific bucket type.
type BucketBalance struct {
	// The bucket type specified by the LedgerClassBucketType.id.
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucketTypeId,omitempty"`
	// The balance of the bucket.
	// The units of this field are defined by the denom field in this ledger's class.
	BalanceAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=balance_amt,json=balanceAmt,proto3,customtype=cosmossdk.io/math.Int" json:"balanceAmt,omitempty"`
}

func (m *BucketBalance) Reset()         { *m = BucketBalance{} }
func (m *BucketBalance) String() string { return proto.CompactTextString(m) }
func (*BucketBalance) ProtoMessage()    {}
func (*BucketBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{8}
}
func (m *BucketBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketBalance.Merge(m, src)
}
func (m *BucketBalance) XXX_Size() int {
	return m.Size()
}
func (m *BucketBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BucketBalance proto.InternalMessageInfo

func (m *BucketBalance) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// LedgerAndEntries represents a ledger with its associated entries.
type LedgerAndEntries struct {
	// The ledger key identifying the ledger.
	LedgerKey *LedgerKey `protobuf:"bytes,1,opt,name=ledger_key,json=ledgerKey,proto3" json:"ledgerKey,omitempty"`
	// The ledger data.
	Ledger *Ledger `protobuf:"bytes,2,opt,name=ledger,proto3" json:"ledger,omitempty"`
	// The ledger entries.
	Entries []*LedgerEntry `protobuf:"bytes,3,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *LedgerAndEntries) Reset()         { *m = LedgerAndEntries{} }
func (m *LedgerAndEntries) String() string { return proto.CompactTextString(m) }
func (*LedgerAndEntries) ProtoMessage()    {}
func (*LedgerAndEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{9}
}
func (m *LedgerAndEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerAndEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerAndEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerAndEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerAndEntries.Merge(m, src)
}
func (m *LedgerAndEntries) XXX_Size() int {
	return m.Size()
}
func (m *LedgerAndEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerAndEntries.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerAndEntries proto.InternalMessageInfo

func (m *LedgerAndEntries) GetLedgerKey() *LedgerKey {
	if m != nil {
		return m.LedgerKey
	}
	return nil
}

func (m *LedgerAndEntries) GetLedger() *Ledger {
	if m != nil {
		return m.Ledger
	}
	return nil
}

func (m *LedgerAndEntries) GetEntries() []*LedgerEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.ledger.v1.DayCountConvention", DayCountConvention_name, DayCountConvention_value)
	proto.RegisterEnum("provenance.ledger.v1.InterestAccrualMethod", InterestAccrualMethod_name, InterestAccrualMethod_value)
	proto.RegisterEnum("provenance.ledger.v1.PaymentFrequency", PaymentFrequency_name, PaymentFrequency_value)
	proto.RegisterType((*LedgerClass)(nil), "provenance.ledger.v1.LedgerClass")
	proto.RegisterType((*LedgerClassEntryType)(nil), "provenance.ledger.v1.LedgerClassEntryType")
	proto.RegisterType((*LedgerClassStatusType)(nil), "provenance.ledger.v1.LedgerClassStatusType")
	proto.RegisterType((*LedgerKey)(nil), "provenance.ledger.v1.LedgerKey")
	proto.RegisterType((*Ledger)(nil), "provenance.ledger.v1.Ledger")
	proto.RegisterType((*LedgerClassBucketType)(nil), "provenance.ledger.v1.LedgerClassBucketType")
	proto.RegisterType((*LedgerEntry)(nil), "provenance.ledger.v1.LedgerEntry")
	proto.RegisterType((*LedgerBucketAmount)(nil), "provenance.ledger.v1.LedgerBucketAmount")
	proto.RegisterType((*BucketBalance)(nil), "provenance.ledger.v1.BucketBalance")
	proto.RegisterType((*LedgerAndEntries)(nil), "provenance.ledger.v1.LedgerAndEntries")
}

func init() { proto.RegisterFile("provenance/ledger/v1/ledger.proto", fileDescriptor_dee508b012fc2213) }

var fileDescriptor_dee508b012fc2213 = []byte{
	// 1579 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6f, 0x1b, 0xd5,
	0x17, 0xce, 0xd8, 0xb1, 0x93, 0x5c, 0xe7, 0x31, 0xb9, 0x4d, 0x1a, 0x37, 0x69, 0x3d, 0xa9, 0x53,
	0xb5, 0x69, 0xfa, 0x8b, 0xd3, 0xa6, 0xfa, 0x81, 0x78, 0xe3, 0xc7, 0x84, 0x9a, 0x26, 0xe3, 0xd4,
	0xb1, 0x5b, 0x19, 0x24, 0x46, 0x13, 0xcf, 0x4d, 0x3a, 0xc4, 0x33, 0x63, 0x66, 0x6e, 0xa2, 0x7a,
	0xc5, 0x12, 0x24, 0x58, 0xb0, 0x64, 0x03, 0x02, 0x81, 0x04, 0x12, 0x5b, 0x24, 0x36, 0xac, 0xa1,
	0xcb, 0x8a, 0x15, 0xb0, 0x18, 0xa1, 0x76, 0x37, 0x7f, 0x02, 0x12, 0x12, 0x9a, 0x7b, 0xc7, 0xf3,
	0xb0, 0xc7, 0x0e, 0xaf, 0x45, 0x57, 0xc9, 0x3d, 0xdf, 0xf7, 0x9d, 0x7b, 0xce, 0xb9, 0xe7, 0x9e,
	0x3b, 0x32, 0xb8, 0xd8, 0x36, 0xf4, 0x13, 0xa4, 0x49, 0x5a, 0x13, 0x6d, 0xb4, 0x90, 0x7c, 0x88,
	0x8c, 0x8d, 0x93, 0x1b, 0xee, 0x7f, 0xb9, 0xb6, 0xa1, 0x63, 0x1d, 0xce, 0xf9, 0x94, 0x9c, 0x0b,
	0x9c, 0xdc, 0x58, 0x9c, 0x3b, 0xd4, 0x0f, 0x75, 0x42, 0xd8, 0x70, 0xfe, 0xa3, 0xdc, 0xc5, 0x73,
	0x4d, 0xdd, 0x54, 0x75, 0x53, 0xa4, 0x00, 0x5d, 0x50, 0x28, 0xfb, 0x55, 0x0c, 0xa4, 0xb6, 0x89,
	0xbc, 0xd8, 0x92, 0x4c, 0x13, 0x16, 0xc1, 0x0c, 0xf5, 0x26, 0x36, 0x9d, 0xb5, 0xa8, 0xc8, 0x69,
	0x66, 0x99, 0x59, 0x9d, 0x28, 0x2c, 0xd9, 0x16, 0xb7, 0xd0, 0xf2, 0x99, 0x65, 0xf9, 0x7f, 0xba,
	0xaa, 0x60, 0xa4, 0xb6, 0x71, 0xa7, 0x3a, 0x15, 0x02, 0xe0, 0xab, 0x60, 0x5a, 0x32, 0x4d, 0x84,
	0x7d, 0x1f, 0x31, 0xe2, 0x63, 0xd1, 0xb6, 0xb8, 0xb3, 0x04, 0xe9, 0x77, 0x31, 0x19, 0xb4, 0xc3,
	0xab, 0x20, 0x21, 0x23, 0x4d, 0x57, 0xd3, 0x71, 0x22, 0x3c, 0x63, 0x5b, 0xdc, 0x0c, 0x31, 0x04,
	0x14, 0x94, 0x01, 0x0f, 0x00, 0x54, 0x25, 0x45, 0xc3, 0x92, 0xa2, 0x21, 0x43, 0x94, 0x64, 0xd9,
	0x40, 0xa6, 0x99, 0x1e, 0x25, 0xba, 0x67, 0x6d, 0x8b, 0x5b, 0xf2, 0xd1, 0x3c, 0x05, 0x7d, 0x1f,
	0x3f, 0x7d, 0xbb, 0x3e, 0xe7, 0x96, 0xc3, 0xc5, 0xf6, 0xb0, 0xa1, 0x68, 0x87, 0xd5, 0xd9, 0x3e,
	0x51, 0xf6, 0x13, 0x06, 0xcc, 0x05, 0x2a, 0xc5, 0x6b, 0xd8, 0xe8, 0xd4, 0x3a, 0x6d, 0x04, 0x97,
	0x41, 0xcc, 0xad, 0x52, 0xa2, 0xc0, 0xda, 0x16, 0x37, 0xa9, 0x04, 0xf3, 0x8a, 0x29, 0x32, 0xbc,
	0x0c, 0x46, 0x9b, 0xba, 0x8c, 0xdc, 0x2a, 0x40, 0xdb, 0xe2, 0xa6, 0x9d, 0x75, 0x80, 0x45, 0x70,
	0xf8, 0x02, 0x48, 0xc9, 0xc8, 0x6c, 0x1a, 0x4a, 0x1b, 0x2b, 0xba, 0xe6, 0xe6, 0x7e, 0xce, 0xb6,
	0xb8, 0xf9, 0x80, 0x39, 0xa0, 0x0a, 0xb2, 0xb3, 0x9f, 0x32, 0x60, 0x3e, 0x10, 0xdf, 0x1e, 0x96,
	0xf0, 0xb1, 0xf9, 0x34, 0x05, 0xf8, 0x2e, 0x98, 0xa0, 0xf1, 0xdd, 0x46, 0x1d, 0xb8, 0x06, 0x92,
	0xda, 0x01, 0xf6, 0xdb, 0x8b, 0x9c, 0xb0, 0x76, 0x80, 0x43, 0x3d, 0x91, 0x20, 0x86, 0x7f, 0xdf,
	0x4e, 0xcf, 0x8f, 0x7e, 0xfc, 0x19, 0x37, 0x92, 0xfd, 0x65, 0x0c, 0x24, 0x69, 0x04, 0xb0, 0x04,
	0xe2, 0x47, 0xa8, 0x43, 0xf6, 0x4e, 0x6d, 0x72, 0xb9, 0xa8, 0xbb, 0x94, 0xf3, 0x82, 0x2d, 0xcc,
	0xda, 0x16, 0x37, 0x75, 0x84, 0x3a, 0x01, 0xff, 0x8e, 0x3c, 0xea, 0xb2, 0xc4, 0xfe, 0xc9, 0x65,
	0x31, 0xc9, 0x59, 0x89, 0xb8, 0xd3, 0x46, 0x8e, 0x8f, 0x38, 0x39, 0x29, 0x92, 0x9d, 0xe9, 0x9d,
	0x62, 0x38, 0xbb, 0xa0, 0x1d, 0xbe, 0x04, 0xa6, 0x34, 0xf4, 0x00, 0x8b, 0x6d, 0x15, 0x8b, 0xb2,
	0x84, 0x11, 0x69, 0xfe, 0x04, 0x3d, 0x17, 0x07, 0xd8, 0x55, 0x71, 0x49, 0xc2, 0xc1, 0xd3, 0x4c,
	0x05, 0xcc, 0x10, 0x81, 0x49, 0x4f, 0x2e, 0xa9, 0x38, 0x9d, 0x20, 0x29, 0x14, 0x1f, 0x5a, 0xdc,
	0xc8, 0xaf, 0x16, 0x37, 0x4f, 0xef, 0x87, 0x29, 0x1f, 0xe5, 0x14, 0x7d, 0x43, 0x95, 0xf0, 0xfd,
	0x5c, 0x59, 0xc3, 0xb6, 0xc5, 0xcd, 0xb9, 0x3e, 0xf2, 0x2a, 0x0e, 0x5d, 0x28, 0xe0, 0x5e, 0xa8,
	0xb2, 0x86, 0xab, 0xc0, 0xe7, 0xc0, 0x57, 0xc0, 0x94, 0xa2, 0x61, 0x64, 0x20, 0x13, 0x8b, 0x86,
	0x13, 0x65, 0xd2, 0x4f, 0xb3, 0x0b, 0x54, 0xc3, 0x61, 0x4e, 0x06, 0xed, 0x8e, 0x03, 0x55, 0xc2,
	0xc7, 0x86, 0x82, 0x3b, 0x34, 0xcd, 0x31, 0xdf, 0x41, 0x17, 0xe8, 0xc9, 0x73, 0x32, 0x68, 0x87,
	0xdf, 0x30, 0xe0, 0x82, 0x17, 0x82, 0x2c, 0x75, 0xc4, 0xa6, 0x7e, 0xac, 0x61, 0xb1, 0xa9, 0x6b,
	0x27, 0x48, 0x23, 0x0d, 0x3d, 0xbe, 0xcc, 0xac, 0x4e, 0x6f, 0xae, 0x46, 0xf7, 0x43, 0x49, 0xea,
	0x14, 0x1d, 0x41, 0xd1, 0xe3, 0x17, 0x5e, 0xb6, 0x2d, 0xee, 0x52, 0xd7, 0x65, 0x3f, 0xee, 0x47,
	0xf2, 0xbb, 0xc5, 0xc1, 0x7e, 0xbc, 0xba, 0x38, 0x58, 0x0b, 0x3f, 0x67, 0xc0, 0x82, 0x17, 0xad,
	0xd4, 0x6c, 0x1a, 0xc7, 0x52, 0x4b, 0x54, 0x11, 0xbe, 0xaf, 0xcb, 0xe9, 0x09, 0x12, 0xe7, 0xb5,
	0xe8, 0x38, 0xcb, 0xae, 0x28, 0x4f, 0x35, 0x3b, 0x44, 0x52, 0x78, 0xd1, 0xb6, 0x38, 0x4e, 0x89,
	0x82, 0x42, 0x51, 0xce, 0x47, 0xaa, 0xab, 0xf3, 0x91, 0x4a, 0xf8, 0x1e, 0x03, 0x66, 0xdb, 0x52,
	0x47, 0x45, 0x1a, 0x16, 0x0f, 0x0c, 0xf4, 0xce, 0x31, 0xd2, 0x9a, 0x9d, 0x34, 0x20, 0xd1, 0x5d,
	0x8e, 0x8e, 0x6e, 0x97, 0xd2, 0xb7, 0xba, 0xec, 0xc2, 0xa6, 0x6d, 0x71, 0x8b, 0xed, 0x1e, 0x6b,
	0x28, 0x26, 0xb6, 0x57, 0x53, 0x65, 0x7b, 0xf9, 0xbd, 0xd3, 0xaf, 0x70, 0xdc, 0x3c, 0x42, 0xf8,
	0x69, 0x9a, 0x7e, 0x1f, 0x26, 0xbb, 0x0f, 0x2d, 0x79, 0x39, 0x60, 0x01, 0x4c, 0x37, 0x75, 0xc3,
	0x40, 0x2d, 0xc9, 0x81, 0x7b, 0xde, 0xd9, 0x00, 0x12, 0x1e, 0x1d, 0x21, 0x00, 0xbe, 0x09, 0x16,
	0x0c, 0x74, 0x82, 0x0c, 0x13, 0x99, 0x62, 0x8f, 0x33, 0x9a, 0xcb, 0x8a, 0x73, 0xe8, 0x5d, 0x4a,
	0x71, 0x80, 0xd3, 0xf9, 0x48, 0x02, 0x5c, 0x07, 0x63, 0x8a, 0x29, 0x9e, 0xe8, 0xee, 0x40, 0x1a,
	0x2f, 0xcc, 0xd9, 0x16, 0xc7, 0x2a, 0xe6, 0x5d, 0x3d, 0x54, 0xc0, 0x24, 0xb5, 0xc0, 0x4d, 0x30,
	0x6e, 0xd2, 0xc3, 0xa0, 0xf3, 0x67, 0xaa, 0x70, 0xd6, 0xb6, 0x38, 0xd8, 0xb5, 0x05, 0x14, 0x1e,
	0xcf, 0x19, 0x5c, 0xc8, 0x29, 0x86, 0x37, 0xf9, 0x12, 0xfe, 0xe0, 0x42, 0xdd, 0xf7, 0x35, 0x14,
	0x6b, 0x2a, 0x60, 0x86, 0xcf, 0x81, 0x54, 0x5b, 0x37, 0x31, 0x92, 0xe9, 0x38, 0xa0, 0xf3, 0x24,
	0xed, 0x8c, 0x26, 0x6a, 0xee, 0x19, 0x06, 0xc0, 0xb7, 0x3a, 0xd5, 0x47, 0x07, 0x07, 0xa8, 0x89,
	0x95, 0x13, 0x14, 0x1c, 0x26, 0xa4, 0xfa, 0x1e, 0xd2, 0xe3, 0x60, 0x2a, 0x04, 0xc0, 0xb7, 0xc0,
	0x04, 0xd6, 0xb1, 0xd4, 0x22, 0x43, 0x73, 0x9c, 0xd4, 0x3b, 0x7f, 0xda, 0xd0, 0x84, 0x44, 0x31,
	0x6c, 0x64, 0x8e, 0x77, 0x19, 0x50, 0x07, 0x33, 0x52, 0xbb, 0xdd, 0x52, 0x90, 0x2c, 0x4a, 0xaa,
	0x33, 0x1c, 0xcc, 0xf4, 0xc4, 0x72, 0x7c, 0x35, 0x35, 0x68, 0x3e, 0xd1, 0xee, 0xa2, 0x9d, 0x9f,
	0x27, 0x82, 0xc2, 0x79, 0xdb, 0xe2, 0xd2, 0xae, 0x13, 0x6a, 0x0a, 0x7c, 0xfc, 0x54, 0xa7, 0xc3,
	0x08, 0x7c, 0x1b, 0xcc, 0xec, 0x4b, 0x2d, 0xc7, 0xab, 0xb7, 0x21, 0x20, 0x1b, 0xae, 0x44, 0x6f,
	0x48, 0xb7, 0x2a, 0x50, 0x09, 0xdd, 0xcb, 0xd5, 0x47, 0xec, 0x15, 0x46, 0xb2, 0xdf, 0x33, 0x00,
	0xf6, 0x07, 0xec, 0x3c, 0x86, 0xfb, 0x64, 0xed, 0xb5, 0x04, 0xe3, 0x0f, 0xf9, 0x7d, 0xef, 0x52,
	0x87, 0x1f, 0xc3, 0xa0, 0x1d, 0xca, 0x20, 0xe5, 0x57, 0x0d, 0xbb, 0xf7, 0xe0, 0xf4, 0xc7, 0xcc,
	0x2b, 0xc5, 0x90, 0xc7, 0xcc, 0xe7, 0x64, 0xbf, 0x63, 0xc0, 0x54, 0x28, 0xfd, 0xff, 0x26, 0x72,
	0xbf, 0xfc, 0x7f, 0x3d, 0x72, 0xaf, 0xb0, 0x43, 0x22, 0xf7, 0x39, 0xd9, 0x0f, 0x62, 0x80, 0xa5,
	0x85, 0xcf, 0x6b, 0xb2, 0x33, 0x8a, 0x14, 0x64, 0xc2, 0x7b, 0x00, 0xb8, 0x1f, 0x32, 0x7f, 0xe3,
	0xab, 0x68, 0xc1, 0xb6, 0xb8, 0x33, 0xad, 0xee, 0x32, 0x90, 0xd6, 0x84, 0x67, 0x84, 0xaf, 0x83,
	0x24, 0x5d, 0x90, 0x74, 0x52, 0x9b, 0xe7, 0x87, 0xb6, 0x2e, 0x99, 0x30, 0xd4, 0x1a, 0x9c, 0x30,
	0xd4, 0x02, 0xab, 0x60, 0x0c, 0xd1, 0x78, 0xd3, 0x71, 0xd2, 0x96, 0x17, 0x87, 0x39, 0x23, 0x53,
	0xb6, 0x30, 0x6f, 0x5b, 0xdc, 0xac, 0xab, 0x0a, 0xb8, 0xec, 0x3a, 0x5a, 0xfb, 0x31, 0x06, 0x22,
	0xde, 0x65, 0x78, 0x09, 0x2c, 0x97, 0xf2, 0x0d, 0xb1, 0x58, 0xa9, 0x0b, 0x35, 0xb1, 0x58, 0x11,
	0xee, 0xf2, 0x42, 0xad, 0x5c, 0x11, 0xc4, 0xba, 0xb0, 0xb7, 0xcb, 0x17, 0xcb, 0x5b, 0x65, 0xbe,
	0xc4, 0x8e, 0xc0, 0x15, 0xc0, 0x45, 0xb2, 0xf2, 0xc5, 0x5a, 0x3d, 0xbf, 0x2d, 0xde, 0x7c, 0xe6,
	0xff, 0x2c, 0x73, 0x3a, 0xe9, 0x3a, 0x1b, 0x1b, 0x48, 0xaa, 0xdd, 0x2a, 0x57, 0x6b, 0x0d, 0x42,
	0x8a, 0xc3, 0xcb, 0x20, 0x3b, 0xcc, 0x13, 0xfd, 0xc3, 0x8e, 0xc2, 0x8b, 0xe0, 0x42, 0x24, 0xaf,
	0x94, 0x6f, 0xec, 0x91, 0xa0, 0x12, 0xa7, 0x51, 0xae, 0xb3, 0xc9, 0x81, 0x25, 0x10, 0x2a, 0x35,
	0xb1, 0xc4, 0x6f, 0x95, 0x05, 0xbe, 0xc4, 0x8e, 0x2d, 0x8e, 0xbf, 0xff, 0x45, 0x66, 0xe4, 0xeb,
	0x2f, 0x33, 0xcc, 0xda, 0x0f, 0x71, 0x10, 0xfd, 0xed, 0x00, 0xaf, 0x80, 0x95, 0xb2, 0x50, 0xe3,
	0xab, 0xfc, 0x5e, 0x4d, 0xcc, 0x17, 0x8b, 0x55, 0x27, 0xd8, 0x1d, 0xbe, 0x76, 0xab, 0x52, 0xea,
	0xa9, 0xe7, 0x35, 0x70, 0x65, 0x10, 0x71, 0xaf, 0xbc, 0xb3, 0xbb, 0xcd, 0x8b, 0x5d, 0x98, 0x65,
	0xe0, 0x3a, 0xb8, 0x3a, 0x88, 0x5c, 0xac, 0xec, 0xec, 0x56, 0xea, 0x42, 0xc9, 0xa7, 0xc7, 0x86,
	0xd1, 0x4b, 0xf9, 0xf2, 0x76, 0xc3, 0x13, 0x95, 0x85, 0xd7, 0xd8, 0x38, 0xdc, 0x00, 0xd7, 0x06,
	0xd1, 0x77, 0x2a, 0x42, 0xed, 0x56, 0x8f, 0x60, 0x14, 0xde, 0x00, 0xeb, 0x83, 0x04, 0x77, 0xea,
	0xf9, 0x6a, 0x8d, 0xaf, 0xf6, 0x48, 0x12, 0x30, 0x07, 0xd6, 0x06, 0x49, 0xf2, 0x82, 0xe0, 0xac,
	0x82, 0xfc, 0x24, 0xdc, 0x04, 0xb9, 0xc1, 0x19, 0x0b, 0xb5, 0xb2, 0x50, 0xaf, 0xd4, 0xf7, 0x42,
	0x9a, 0xb1, 0x61, 0xb5, 0x0f, 0x1e, 0xe4, 0x78, 0xe0, 0x20, 0xff, 0x60, 0x40, 0xdf, 0x07, 0x97,
	0xd3, 0x30, 0xbb, 0xf9, 0xc6, 0x0e, 0x2f, 0xd4, 0xc4, 0xad, 0x2a, 0x7f, 0xa7, 0xce, 0x0b, 0xc5,
	0x46, 0xcf, 0xe9, 0x2d, 0x81, 0x85, 0x7e, 0x0a, 0xa9, 0x2d, 0xcb, 0xc0, 0xf3, 0x20, 0xdd, 0x0f,
	0xde, 0xe3, 0xf9, 0xdb, 0xdb, 0x0d, 0x36, 0x06, 0x2f, 0x80, 0x73, 0xfd, 0xa8, 0x5b, 0x67, 0x36,
	0x0e, 0x39, 0xb0, 0xd4, 0x0f, 0x7b, 0x55, 0x65, 0x47, 0x61, 0x06, 0x2c, 0xf6, 0x13, 0x68, 0x0d,
	0xb7, 0x1b, 0xb4, 0xdd, 0xfb, 0xf1, 0x60, 0xfe, 0x49, 0x3f, 0xff, 0xc2, 0xe1, 0xc3, 0xc7, 0x19,
	0xe6, 0xd1, 0xe3, 0x0c, 0xf3, 0xdb, 0xe3, 0x0c, 0xf3, 0xd1, 0x93, 0xcc, 0xc8, 0xa3, 0x27, 0x99,
	0x91, 0x9f, 0x9f, 0x64, 0x46, 0xc0, 0x82, 0xa2, 0x47, 0x4e, 0x9c, 0x5d, 0xe6, 0x8d, 0xcd, 0x43,
	0x05, 0xdf, 0x3f, 0xde, 0xcf, 0x35, 0x75, 0x75, 0xc3, 0xa7, 0xac, 0x2b, 0x7a, 0x60, 0xb5, 0xf1,
	0xa0, 0xfb, 0x5b, 0x8e, 0xf3, 0x42, 0x98, 0xfb, 0x49, 0xf2, 0x0b, 0xcc, 0xcd, 0x3f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0xcc, 0x21, 0x99, 0xa0, 0xed, 0x11, 0x00, 0x00,
}

func (m *LedgerClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaintainerAddress) > 0 {
		i -= len(m.MaintainerAddress)
		copy(dAtA[i:], m.MaintainerAddress)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.MaintainerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassEntryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassEntryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassEntryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ledger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ledger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ledger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PaymentFrequency != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PaymentFrequency))
		i--
		dAtA[i] = 0x50
	}
	if m.InterestAccrualMethod != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestAccrualMethod))
		i--
		dAtA[i] = 0x48
	}
	if m.InterestDayCountConvention != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestDayCountConvention))
		i--
		dAtA[i] = 0x40
	}
	if m.MaturityDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.MaturityDate))
		i--
		dAtA[i] = 0x38
	}
	if m.InterestRate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestRate))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.NextPmtAmt.Size()
		i -= size
		if _, err := m.NextPmtAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.NextPmtDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtDate))
		i--
		dAtA[i] = 0x20
	}
	if m.StatusTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.StatusTypeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassBucketType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassBucketType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassBucketType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BalanceAmounts) > 0 {
		for iNdEx := len(m.BalanceAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BalanceAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AppliedAmounts) > 0 {
		for iNdEx := len(m.AppliedAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppliedAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size := m.TotalAmt.Size()
		i -= size
		if _, err := m.TotalAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.EffectiveDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EffectiveDate))
		i--
		dAtA[i] = 0x38
	}
	if m.PostedDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PostedDate))
		i--
		dAtA[i] = 0x30
	}
	if m.EntryTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EntryTypeId))
		i--
		dAtA[i] = 0x28
	}
	if m.Sequence != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if m.IsVoid {
		i--
		if m.IsVoid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReversesCorrelationId) > 0 {
		i -= len(m.ReversesCorrelationId)
		copy(dAtA[i:], m.ReversesCorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.ReversesCorrelationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CorrelationId) > 0 {
		i -= len(m.CorrelationId)
		copy(dAtA[i:], m.CorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.CorrelationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerBucketAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerBucketAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerBucketAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AppliedAmt.Size()
		i -= size
		if _, err := m.AppliedAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BalanceAmt.Size()
		i -= size
		if _, err := m.BalanceAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerAndEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerAndEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerAndEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ledger != nil {
		{
			size, err := m.Ledger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LedgerKey != nil {
		{
			size, err := m.LedgerKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLedger(dAtA []byte, offset int, v uint64) int {
	offset -= sovLedger(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LedgerClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.MaintainerAddress)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassEntryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *Ledger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.StatusTypeId != 0 {
		n += 1 + sovLedger(uint64(m.StatusTypeId))
	}
	if m.NextPmtDate != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtDate))
	}
	l = m.NextPmtAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	if m.InterestRate != 0 {
		n += 1 + sovLedger(uint64(m.InterestRate))
	}
	if m.MaturityDate != 0 {
		n += 1 + sovLedger(uint64(m.MaturityDate))
	}
	if m.InterestDayCountConvention != 0 {
		n += 1 + sovLedger(uint64(m.InterestDayCountConvention))
	}
	if m.InterestAccrualMethod != 0 {
		n += 1 + sovLedger(uint64(m.InterestAccrualMethod))
	}
	if m.PaymentFrequency != 0 {
		n += 1 + sovLedger(uint64(m.PaymentFrequency))
	}
	return n
}

func (m *LedgerClassBucketType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.ReversesCorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.IsVoid {
		n += 2
	}
	if m.Sequence != 0 {
		n += 1 + sovLedger(uint64(m.Sequence))
	}
	if m.EntryTypeId != 0 {
		n += 1 + sovLedger(uint64(m.EntryTypeId))
	}
	if m.PostedDate != 0 {
		n += 1 + sovLedger(uint64(m.PostedDate))
	}
	if m.EffectiveDate != 0 {
		n += 1 + sovLedger(uint64(m.EffectiveDate))
	}
	l = m.TotalAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	if len(m.AppliedAmounts) > 0 {
		for _, e := range m.AppliedAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.BalanceAmounts) > 0 {
		for _, e := range m.BalanceAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *LedgerBucketAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.AppliedAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *BucketBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.BalanceAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *LedgerAndEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerKey != nil {
		l = m.LedgerKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Ledger != nil {
		l = m.Ledger.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func sovLedger(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLedger(x uint64) (n int) {
	return sovLedger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LedgerClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintainerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassEntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassEntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassEntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ledger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ledger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ledger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LedgerKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusTypeId", wireType)
			}
			m.StatusTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtDate", wireType)
			}
			m.NextPmtDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextPmtAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestRate", wireType)
			}
			m.InterestRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaturityDate", wireType)
			}
			m.MaturityDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaturityDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestDayCountConvention", wireType)
			}
			m.InterestDayCountConvention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestDayCountConvention |= DayCountConvention(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestAccrualMethod", wireType)
			}
			m.InterestAccrualMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestAccrualMethod |= InterestAccrualMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentFrequency", wireType)
			}
			m.PaymentFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentFrequency |= PaymentFrequency(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassBucketType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassBucketType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassBucketType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReversesCorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReversesCorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVoid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVoid = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryTypeId", wireType)
			}
			m.EntryTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostedDate", wireType)
			}
			m.PostedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostedDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveDate", wireType)
			}
			m.EffectiveDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppliedAmounts = append(m.AppliedAmounts, &LedgerBucketAmount{})
			if err := m.AppliedAmounts[len(m.AppliedAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceAmounts = append(m.BalanceAmounts, &BucketBalance{})
			if err := m.BalanceAmounts[len(m.BalanceAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerBucketAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerBucketAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerBucketAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BalanceAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerAndEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerAndEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerAndEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerKey == nil {
				m.LedgerKey = &LedgerKey{}
			}
			if err := m.LedgerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ledger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ledger == nil {
				m.Ledger = &Ledger{}
			}
			if err := m.Ledger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &LedgerEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLedger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLedger
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLedger
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLedger
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLedger        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLedger          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLedger = fmt.Errorf("proto: unexpected end of group")
)
