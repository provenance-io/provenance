// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/ledger/v1/ledger.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Day Count Conventions used in interest calculations
type DayCount int32

const (
	// Unspecified day count convention.
	DAY_COUNT_UNSPECIFIED DayCount = 0
	// Actual/365: Uses the actual number of days in the period with a fixed denominator of 365
	// (or sometimes 365.25 to adjust for leap years).
	DAY_COUNT_ACTUAL_365 DayCount = 1
	// Actual/360: Uses the actual number of days in the period but divides by 360.
	DAY_COUNT_ACTUAL_360 DayCount = 2
	// 30/360: Assumes each month has 30 days and the year has 360 days.
	DAY_COUNT_THIRTY_360 DayCount = 3
	// Actual/Actual: Uses the actual number of days in the period and the actual days in the year
	// (365 or 366, depending on the year).
	DAY_COUNT_ACTUAL_ACTUAL DayCount = 4
	// 365/365: Always uses 365 days in the denominator regardless of leap years.
	DAY_COUNT_DAYS_365 DayCount = 5
	// 360/360: Always uses 360 days in both the numerator and denominator.
	DAY_COUNT_DAYS_360 DayCount = 6
)

var DayCount_name = map[int32]string{
	0: "DAY_COUNT_UNSPECIFIED",
	1: "DAY_COUNT_ACTUAL_365",
	2: "DAY_COUNT_ACTUAL_360",
	3: "DAY_COUNT_THIRTY_360",
	4: "DAY_COUNT_ACTUAL_ACTUAL",
	5: "DAY_COUNT_DAYS_365",
	6: "DAY_COUNT_DAYS_360",
}

var DayCount_value = map[string]int32{
	"DAY_COUNT_UNSPECIFIED":   0,
	"DAY_COUNT_ACTUAL_365":    1,
	"DAY_COUNT_ACTUAL_360":    2,
	"DAY_COUNT_THIRTY_360":    3,
	"DAY_COUNT_ACTUAL_ACTUAL": 4,
	"DAY_COUNT_DAYS_365":      5,
	"DAY_COUNT_DAYS_360":      6,
}

func (x DayCount) String() string {
	return proto.EnumName(DayCount_name, int32(x))
}

func (DayCount) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}

// Interest Accrual Methods describing how interest is calculated over time
type InterestAccrual int32

const (
	// Unspecified interest accrual method.
	INTEREST_ACCRUAL_UNSPECIFIED InterestAccrual = 0
	// Simple Interest: Calculated only on the principal amount.
	INTEREST_ACCRUAL_SIMPLE_INTEREST InterestAccrual = 1
	// Compound Interest: Calculated on both the principal and on previously accumulated interest.
	INTEREST_ACCRUAL_COMPOUND_INTEREST InterestAccrual = 2
	// Daily Compounding: Interest is compounded on a daily basis.
	INTEREST_ACCRUAL_DAILY_COMPOUNDING InterestAccrual = 3
	// Monthly Compounding: Interest is compounded each month.
	INTEREST_ACCRUAL_MONTHLY_COMPOUNDING InterestAccrual = 4
	// Quarterly Compounding: Interest is compounded every quarter.
	INTEREST_ACCRUAL_QUARTERLY_COMPOUNDING InterestAccrual = 5
	// Annually Compounding: Interest is compounded once per year.
	INTEREST_ACCRUAL_ANNUAL_COMPOUNDING InterestAccrual = 6
	// Continuous Compounding: The theoretical limit of compounding frequency where interest is compounded continuously.
	INTEREST_ACCRUAL_CONTINUOUS_COMPOUNDING InterestAccrual = 7
)

var InterestAccrual_name = map[int32]string{
	0: "INTEREST_ACCRUAL_UNSPECIFIED",
	1: "INTEREST_ACCRUAL_SIMPLE_INTEREST",
	2: "INTEREST_ACCRUAL_COMPOUND_INTEREST",
	3: "INTEREST_ACCRUAL_DAILY_COMPOUNDING",
	4: "INTEREST_ACCRUAL_MONTHLY_COMPOUNDING",
	5: "INTEREST_ACCRUAL_QUARTERLY_COMPOUNDING",
	6: "INTEREST_ACCRUAL_ANNUAL_COMPOUNDING",
	7: "INTEREST_ACCRUAL_CONTINUOUS_COMPOUNDING",
}

var InterestAccrual_value = map[string]int32{
	"INTEREST_ACCRUAL_UNSPECIFIED":            0,
	"INTEREST_ACCRUAL_SIMPLE_INTEREST":        1,
	"INTEREST_ACCRUAL_COMPOUND_INTEREST":      2,
	"INTEREST_ACCRUAL_DAILY_COMPOUNDING":      3,
	"INTEREST_ACCRUAL_MONTHLY_COMPOUNDING":    4,
	"INTEREST_ACCRUAL_QUARTERLY_COMPOUNDING":  5,
	"INTEREST_ACCRUAL_ANNUAL_COMPOUNDING":     6,
	"INTEREST_ACCRUAL_CONTINUOUS_COMPOUNDING": 7,
}

func (x InterestAccrual) String() string {
	return proto.EnumName(InterestAccrual_name, int32(x))
}

func (InterestAccrual) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}

// Payment frequencies for loan repayments
type PaymentFrequency int32

const (
	// Unspecified payment frequency.
	PAYMENT_FREQUENCY_UNSPECIFIED PaymentFrequency = 0
	// Daily payments.
	PAYMENT_FREQUENCY_DAILY PaymentFrequency = 1
	// Weekly or biweekly payments.
	PAYMENT_FREQUENCY_WEEKLY PaymentFrequency = 2
	// Monthly payments (most common for consumer loans and mortgages).
	PAYMENT_FREQUENCY_MONTHLY PaymentFrequency = 3
	// Quarterly payments.
	PAYMENT_FREQUENCY_QUARTERLY PaymentFrequency = 4
	// Annual payments.
	PAYMENT_FREQUENCY_ANNUALLY PaymentFrequency = 5
)

var PaymentFrequency_name = map[int32]string{
	0: "PAYMENT_FREQUENCY_UNSPECIFIED",
	1: "PAYMENT_FREQUENCY_DAILY",
	2: "PAYMENT_FREQUENCY_WEEKLY",
	3: "PAYMENT_FREQUENCY_MONTHLY",
	4: "PAYMENT_FREQUENCY_QUARTERLY",
	5: "PAYMENT_FREQUENCY_ANNUALLY",
}

var PaymentFrequency_value = map[string]int32{
	"PAYMENT_FREQUENCY_UNSPECIFIED": 0,
	"PAYMENT_FREQUENCY_DAILY":       1,
	"PAYMENT_FREQUENCY_WEEKLY":      2,
	"PAYMENT_FREQUENCY_MONTHLY":     3,
	"PAYMENT_FREQUENCY_QUARTERLY":   4,
	"PAYMENT_FREQUENCY_ANNUALLY":    5,
}

func (x PaymentFrequency) String() string {
	return proto.EnumName(PaymentFrequency_name, int32(x))
}

func (PaymentFrequency) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}

// LedgerClass contains the configuration for a ledger related to a particular class of asset. The asset class
// is defined by the either a scope spec `x/metadata`, or nft class `x/nft`. Ultimately, the configuration will
// assist in verifying the types that are associated with particular ledger entries.
type LedgerClass struct {
	// Unique ID for the ledger class (eg. 1, 2, 3, etc.)
	// This is necessary since the nft class does not have an owner.
	LedgerClassId string `protobuf:"bytes,1,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledgerClassId,omitempty"`
	// Scope Specification ID or NFT Class ID
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"assetClassId,omitempty"`
	// Denom that this class of asset will be ledgered in
	Denom string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty"`
	// Address of the maintainer for the ledger class
	MaintainerAddress string `protobuf:"bytes,4,opt,name=maintainer_address,json=maintainerAddress,proto3" json:"maintainerAddress,omitempty"`
}

func (m *LedgerClass) Reset()         { *m = LedgerClass{} }
func (m *LedgerClass) String() string { return proto.CompactTextString(m) }
func (*LedgerClass) ProtoMessage()    {}
func (*LedgerClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}
func (m *LedgerClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClass.Merge(m, src)
}
func (m *LedgerClass) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClass) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClass.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClass proto.InternalMessageInfo

func (m *LedgerClass) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *LedgerClass) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *LedgerClass) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *LedgerClass) GetMaintainerAddress() string {
	if m != nil {
		return m.MaintainerAddress
	}
	return ""
}

// LedgerClassEntryType defines the types of possible ledger entries for a given asset class. These type codes allow
// for minimal data storage while providing a human readable description of the entry type.
type LedgerClassEntryType struct {
	// Unique ID for the entry type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the entry type (eg. "DISBURSEMENT", "PAYMENT", "ADJUSTMENT", "INTEREST", "FEE", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the entry type (eg. "Disbursement", "Payment", "Adjustment", "Interest", "Fee", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassEntryType) Reset()         { *m = LedgerClassEntryType{} }
func (m *LedgerClassEntryType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassEntryType) ProtoMessage()    {}
func (*LedgerClassEntryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}
func (m *LedgerClassEntryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassEntryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassEntryType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassEntryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassEntryType.Merge(m, src)
}
func (m *LedgerClassEntryType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassEntryType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassEntryType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassEntryType proto.InternalMessageInfo

func (m *LedgerClassEntryType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassEntryType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassEntryType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerClassStatusType defines the types of possible status values for a given asset class. These type codes allow
// for minimal data storage while providing a human readable description of the status type.
type LedgerClassStatusType struct {
	// Unique ID for the status type (eg. 1, 2, 3, etc.).
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the status type (eg. "IN_REPAYMENT", "IN_FORECLOSURE", "FORBEARANCE", "DEFERMENT", "BANKRUPTCY",
	// "CLOSED", "CANCELLED", "SUSPENDED", "OTHER").
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the status type (eg. "In Repayment", "In Foreclosure", "Forbearance", "Deferment", "Bankruptcy",
	// "Closed", "Cancelled", "Suspended", "Other").
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassStatusType) Reset()         { *m = LedgerClassStatusType{} }
func (m *LedgerClassStatusType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassStatusType) ProtoMessage()    {}
func (*LedgerClassStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}
func (m *LedgerClassStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassStatusType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassStatusType.Merge(m, src)
}
func (m *LedgerClassStatusType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassStatusType proto.InternalMessageInfo

func (m *LedgerClassStatusType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassStatusType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassStatusType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerKey represents a unique key to identify an NFT/Asset for ledger transactions.
type LedgerKey struct {
	// Identifier for the nft that this ledger is linked to.
	// This could be a `x/metadata` scope id or an `x/nft` nft id.
	// In order to create a ledger for an nft, the nft class must be registered in the ledger module as a LedgerClass.
	NftId string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nftId,omitempty"`
	// Scope Specification ID or NFT Class ID
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"assetClassId,omitempty"`
}

func (m *LedgerKey) Reset()         { *m = LedgerKey{} }
func (m *LedgerKey) String() string { return proto.CompactTextString(m) }
func (*LedgerKey) ProtoMessage()    {}
func (*LedgerKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{3}
}
func (m *LedgerKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerKey.Merge(m, src)
}
func (m *LedgerKey) XXX_Size() int {
	return m.Size()
}
func (m *LedgerKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerKey.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerKey proto.InternalMessageInfo

func (m *LedgerKey) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *LedgerKey) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

// Ledger represents a ledger for tracking financial transactions and balances for a specific NFT.
type Ledger struct {
	// The ledger key identifying the ledger.
	Key *LedgerKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The ledger class ID for the ledger.
	LedgerClassId string `protobuf:"bytes,2,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledgerClassId,omitempty"`
	// The status of the ledger.
	StatusTypeId int32 `protobuf:"varint,3,opt,name=status_type_id,json=statusTypeId,proto3" json:"statusTypeId,omitempty"`
	// The next payment date (days since epoch).
	NextPmtDate int32 `protobuf:"varint,4,opt,name=next_pmt_date,json=nextPmtDate,proto3" json:"nextPmtDate,omitempty"`
	// The next payment amount.
	NextPmtAmt int64 `protobuf:"varint,5,opt,name=next_pmt_amt,json=nextPmtAmt,proto3" json:"nextPmtAmt,omitempty"`
	// The interest rate (10000000 = 10.000000%) - 6 decimal places.
	InterestRate int32 `protobuf:"varint,6,opt,name=interest_rate,json=interestRate,proto3" json:"interestRate,omitempty"`
	// The maturity date (days since epoch).
	MaturityDate int32 `protobuf:"varint,7,opt,name=maturity_date,json=maturityDate,proto3" json:"maturityDate,omitempty"`
	// The day count convention for interest calculations.
	InterestDayCount DayCount `protobuf:"varint,8,opt,name=interest_day_count,json=interestDayCount,proto3,enum=provenance.ledger.v1.DayCount,casttype=DayCount" json:"interestDayCount,omitempty"`
	// The interest accrual method for interest calculations.
	InterestAccrual InterestAccrual `protobuf:"varint,9,opt,name=interest_accrual,json=interestAccrual,proto3,enum=provenance.ledger.v1.InterestAccrual,casttype=InterestAccrual" json:"interestAccrual,omitempty"`
	// The payment frequency.
	PaymentFrequency PaymentFrequency `protobuf:"varint,10,opt,name=payment_frequency,json=paymentFrequency,proto3,enum=provenance.ledger.v1.PaymentFrequency,casttype=PaymentFrequency" json:"paymentFrequency,omitempty"`
}

func (m *Ledger) Reset()         { *m = Ledger{} }
func (m *Ledger) String() string { return proto.CompactTextString(m) }
func (*Ledger) ProtoMessage()    {}
func (*Ledger) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{4}
}
func (m *Ledger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ledger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ledger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ledger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ledger.Merge(m, src)
}
func (m *Ledger) XXX_Size() int {
	return m.Size()
}
func (m *Ledger) XXX_DiscardUnknown() {
	xxx_messageInfo_Ledger.DiscardUnknown(m)
}

var xxx_messageInfo_Ledger proto.InternalMessageInfo

func (m *Ledger) GetKey() *LedgerKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Ledger) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *Ledger) GetStatusTypeId() int32 {
	if m != nil {
		return m.StatusTypeId
	}
	return 0
}

func (m *Ledger) GetNextPmtDate() int32 {
	if m != nil {
		return m.NextPmtDate
	}
	return 0
}

func (m *Ledger) GetNextPmtAmt() int64 {
	if m != nil {
		return m.NextPmtAmt
	}
	return 0
}

func (m *Ledger) GetInterestRate() int32 {
	if m != nil {
		return m.InterestRate
	}
	return 0
}

func (m *Ledger) GetMaturityDate() int32 {
	if m != nil {
		return m.MaturityDate
	}
	return 0
}

func (m *Ledger) GetInterestDayCount() DayCount {
	if m != nil {
		return m.InterestDayCount
	}
	return DAY_COUNT_UNSPECIFIED
}

func (m *Ledger) GetInterestAccrual() InterestAccrual {
	if m != nil {
		return m.InterestAccrual
	}
	return INTEREST_ACCRUAL_UNSPECIFIED
}

func (m *Ledger) GetPaymentFrequency() PaymentFrequency {
	if m != nil {
		return m.PaymentFrequency
	}
	return PAYMENT_FREQUENCY_UNSPECIFIED
}

// LedgerClassBucketType represents a bucket type for a ledger class
type LedgerClassBucketType struct {
	// Unique ID for the bucket type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the bucket type (eg. "PRINCIPAL", "INTEREST", "FEE", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the bucket type (eg. "Principal", "Interest", "Fee", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassBucketType) Reset()         { *m = LedgerClassBucketType{} }
func (m *LedgerClassBucketType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassBucketType) ProtoMessage()    {}
func (*LedgerClassBucketType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{5}
}
func (m *LedgerClassBucketType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassBucketType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassBucketType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassBucketType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassBucketType.Merge(m, src)
}
func (m *LedgerClassBucketType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassBucketType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassBucketType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassBucketType proto.InternalMessageInfo

func (m *LedgerClassBucketType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassBucketType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassBucketType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerEntry represents a single entry in a ledger for tracking financial transactions.
type LedgerEntry struct {
	// The correlation ID for tracking ledger entries with external systems (max 50 characters).
	CorrelationId string `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlationId,omitempty"`
	// If this entry reverses another entry, the correlation ID of the entry it reverses.
	ReversesCorrelationId string `protobuf:"bytes,2,opt,name=reverses_correlation_id,json=reversesCorrelationId,proto3" json:"reversesCorrelationId,omitempty"`
	// If true, this entry is a void and should not be included in the ledger balance calculations.
	IsVoid bool `protobuf:"varint,3,opt,name=is_void,json=isVoid,proto3" json:"isVoid,omitempty"`
	// The sequence number of the ledger entry (less than 100).
	// This field is used to maintain the correct order of entries when multiple entries
	// share the same effective date. Entries are sorted first by effective date, then by sequence.
	Sequence uint32 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// The type of ledger entry specified by the LedgerClassEntryType.id.
	EntryTypeId int32 `protobuf:"varint,5,opt,name=entry_type_id,json=entryTypeId,proto3" json:"entryTypeId,omitempty"`
	// The posted date (days since epoch).
	PostedDate int32 `protobuf:"varint,7,opt,name=posted_date,json=postedDate,proto3" json:"postedDate,omitempty"`
	// The effective date (days since epoch).
	EffectiveDate int32 `protobuf:"varint,8,opt,name=effective_date,json=effectiveDate,proto3" json:"effectiveDate,omitempty"`
	// The total amount of the ledger entry.
	TotalAmt cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=total_amt,json=totalAmt,proto3,customtype=cosmossdk.io/math.Int" json:"totalAmt,omitempty"`
	// The applied amounts for each bucket.
	AppliedAmounts []*LedgerBucketAmount `protobuf:"bytes,10,rep,name=applied_amounts,json=appliedAmounts,proto3" json:"appliedAmounts,omitempty"`
	// The balances for each bucket.
	BalanceAmounts []*BucketBalance `protobuf:"bytes,11,rep,name=balance_amounts,json=balanceAmounts,proto3" json:"balanceAmounts,omitempty"`
}

func (m *LedgerEntry) Reset()         { *m = LedgerEntry{} }
func (m *LedgerEntry) String() string { return proto.CompactTextString(m) }
func (*LedgerEntry) ProtoMessage()    {}
func (*LedgerEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{6}
}
func (m *LedgerEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerEntry.Merge(m, src)
}
func (m *LedgerEntry) XXX_Size() int {
	return m.Size()
}
func (m *LedgerEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerEntry proto.InternalMessageInfo

func (m *LedgerEntry) GetCorrelationId() string {
	if m != nil {
		return m.CorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetReversesCorrelationId() string {
	if m != nil {
		return m.ReversesCorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetIsVoid() bool {
	if m != nil {
		return m.IsVoid
	}
	return false
}

func (m *LedgerEntry) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *LedgerEntry) GetEntryTypeId() int32 {
	if m != nil {
		return m.EntryTypeId
	}
	return 0
}

func (m *LedgerEntry) GetPostedDate() int32 {
	if m != nil {
		return m.PostedDate
	}
	return 0
}

func (m *LedgerEntry) GetEffectiveDate() int32 {
	if m != nil {
		return m.EffectiveDate
	}
	return 0
}

func (m *LedgerEntry) GetAppliedAmounts() []*LedgerBucketAmount {
	if m != nil {
		return m.AppliedAmounts
	}
	return nil
}

func (m *LedgerEntry) GetBalanceAmounts() []*BucketBalance {
	if m != nil {
		return m.BalanceAmounts
	}
	return nil
}

// LedgerBucketAmount represents the amount applied to a specific bucket in a ledger entry.
type LedgerBucketAmount struct {
	// The bucket type specified by the LedgerClassBucketType.id.
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucketTypeId,omitempty"`
	// The amount applied to the bucket.
	AppliedAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=applied_amt,json=appliedAmt,proto3,customtype=cosmossdk.io/math.Int" json:"appliedAmt,omitempty"`
}

func (m *LedgerBucketAmount) Reset()         { *m = LedgerBucketAmount{} }
func (m *LedgerBucketAmount) String() string { return proto.CompactTextString(m) }
func (*LedgerBucketAmount) ProtoMessage()    {}
func (*LedgerBucketAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{7}
}
func (m *LedgerBucketAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerBucketAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerBucketAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerBucketAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerBucketAmount.Merge(m, src)
}
func (m *LedgerBucketAmount) XXX_Size() int {
	return m.Size()
}
func (m *LedgerBucketAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerBucketAmount.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerBucketAmount proto.InternalMessageInfo

func (m *LedgerBucketAmount) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// Balances represents the current balances for principal, interest, and other amounts.
type Balances struct {
	// The bucket balances.
	BucketBalances []*BucketBalance `protobuf:"bytes,1,rep,name=bucket_balances,json=bucketBalances,proto3" json:"bucketBalances,omitempty"`
}

func (m *Balances) Reset()         { *m = Balances{} }
func (m *Balances) String() string { return proto.CompactTextString(m) }
func (*Balances) ProtoMessage()    {}
func (*Balances) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{8}
}
func (m *Balances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Balances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Balances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Balances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Balances.Merge(m, src)
}
func (m *Balances) XXX_Size() int {
	return m.Size()
}
func (m *Balances) XXX_DiscardUnknown() {
	xxx_messageInfo_Balances.DiscardUnknown(m)
}

var xxx_messageInfo_Balances proto.InternalMessageInfo

func (m *Balances) GetBucketBalances() []*BucketBalance {
	if m != nil {
		return m.BucketBalances
	}
	return nil
}

// BucketBalance represents the balance for a specific bucket.
type BucketBalance struct {
	// The bucket type specified by the LedgerClassBucketType.id.
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucketTypeId,omitempty"`
	// The balance of the bucket.
	BalanceAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=balance_amt,json=balanceAmt,proto3,customtype=cosmossdk.io/math.Int" json:"balanceAmt,omitempty"`
}

func (m *BucketBalance) Reset()         { *m = BucketBalance{} }
func (m *BucketBalance) String() string { return proto.CompactTextString(m) }
func (*BucketBalance) ProtoMessage()    {}
func (*BucketBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{9}
}
func (m *BucketBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketBalance.Merge(m, src)
}
func (m *BucketBalance) XXX_Size() int {
	return m.Size()
}
func (m *BucketBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BucketBalance proto.InternalMessageInfo

func (m *BucketBalance) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// Ledgers represents a collection of ledgers with their entries, used for conversion and bulk operations.
type Ledgers struct {
	// The ledgers with their entries.
	LedgerToEntries []*LedgerToEntries `protobuf:"bytes,1,rep,name=ledger_to_entries,json=ledgerToEntries,proto3" json:"ledgerToEntries,omitempty"`
}

func (m *Ledgers) Reset()         { *m = Ledgers{} }
func (m *Ledgers) String() string { return proto.CompactTextString(m) }
func (*Ledgers) ProtoMessage()    {}
func (*Ledgers) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{10}
}
func (m *Ledgers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ledgers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ledgers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ledgers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ledgers.Merge(m, src)
}
func (m *Ledgers) XXX_Size() int {
	return m.Size()
}
func (m *Ledgers) XXX_DiscardUnknown() {
	xxx_messageInfo_Ledgers.DiscardUnknown(m)
}

var xxx_messageInfo_Ledgers proto.InternalMessageInfo

func (m *Ledgers) GetLedgerToEntries() []*LedgerToEntries {
	if m != nil {
		return m.LedgerToEntries
	}
	return nil
}

// LedgerToEntries represents a ledger with its associated entries.
type LedgerToEntries struct {
	// The ledger key identifying the ledger.
	LedgerKey *LedgerKey `protobuf:"bytes,1,opt,name=ledger_key,json=ledgerKey,proto3" json:"ledgerKey,omitempty"`
	// The ledger data.
	Ledger *Ledger `protobuf:"bytes,2,opt,name=ledger,proto3" json:"ledger,omitempty"`
	// The ledger entries.
	Entries []*LedgerEntry `protobuf:"bytes,3,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *LedgerToEntries) Reset()         { *m = LedgerToEntries{} }
func (m *LedgerToEntries) String() string { return proto.CompactTextString(m) }
func (*LedgerToEntries) ProtoMessage()    {}
func (*LedgerToEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{11}
}
func (m *LedgerToEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerToEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerToEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerToEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerToEntries.Merge(m, src)
}
func (m *LedgerToEntries) XXX_Size() int {
	return m.Size()
}
func (m *LedgerToEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerToEntries.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerToEntries proto.InternalMessageInfo

func (m *LedgerToEntries) GetLedgerKey() *LedgerKey {
	if m != nil {
		return m.LedgerKey
	}
	return nil
}

func (m *LedgerToEntries) GetLedger() *Ledger {
	if m != nil {
		return m.Ledger
	}
	return nil
}

func (m *LedgerToEntries) GetEntries() []*LedgerEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.ledger.v1.DayCount", DayCount_name, DayCount_value)
	proto.RegisterEnum("provenance.ledger.v1.InterestAccrual", InterestAccrual_name, InterestAccrual_value)
	proto.RegisterEnum("provenance.ledger.v1.PaymentFrequency", PaymentFrequency_name, PaymentFrequency_value)
	proto.RegisterType((*LedgerClass)(nil), "provenance.ledger.v1.LedgerClass")
	proto.RegisterType((*LedgerClassEntryType)(nil), "provenance.ledger.v1.LedgerClassEntryType")
	proto.RegisterType((*LedgerClassStatusType)(nil), "provenance.ledger.v1.LedgerClassStatusType")
	proto.RegisterType((*LedgerKey)(nil), "provenance.ledger.v1.LedgerKey")
	proto.RegisterType((*Ledger)(nil), "provenance.ledger.v1.Ledger")
	proto.RegisterType((*LedgerClassBucketType)(nil), "provenance.ledger.v1.LedgerClassBucketType")
	proto.RegisterType((*LedgerEntry)(nil), "provenance.ledger.v1.LedgerEntry")
	proto.RegisterType((*LedgerBucketAmount)(nil), "provenance.ledger.v1.LedgerBucketAmount")
	proto.RegisterType((*Balances)(nil), "provenance.ledger.v1.Balances")
	proto.RegisterType((*BucketBalance)(nil), "provenance.ledger.v1.BucketBalance")
	proto.RegisterType((*Ledgers)(nil), "provenance.ledger.v1.Ledgers")
	proto.RegisterType((*LedgerToEntries)(nil), "provenance.ledger.v1.LedgerToEntries")
}

func init() { proto.RegisterFile("provenance/ledger/v1/ledger.proto", fileDescriptor_dee508b012fc2213) }

var fileDescriptor_dee508b012fc2213 = []byte{
	// 1691 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6f, 0xe3, 0xc6,
	0x19, 0x36, 0x25, 0x4b, 0xb6, 0x5f, 0xf9, 0x83, 0x9e, 0xd8, 0xb1, 0xcc, 0xdd, 0x15, 0xb9, 0xda,
	0x64, 0xe3, 0xba, 0x5d, 0xdb, 0x71, 0xfa, 0x99, 0x7e, 0x45, 0x94, 0xb4, 0x8d, 0x12, 0xaf, 0xec,
	0xc8, 0x72, 0x52, 0xb7, 0x40, 0x09, 0x5a, 0x1a, 0x3b, 0xec, 0x4a, 0xa2, 0x4a, 0x8e, 0x8d, 0x15,
	0x7a, 0x29, 0x7a, 0x69, 0x41, 0xf4, 0xd0, 0x63, 0x2f, 0xec, 0x25, 0x05, 0xda, 0x1f, 0x10, 0xa0,
	0x97, 0xfe, 0x80, 0x1c, 0x83, 0x9c, 0x8a, 0x16, 0x20, 0x8a, 0xdd, 0x1b, 0x7f, 0x42, 0x4f, 0x05,
	0x67, 0x28, 0x7e, 0x4a, 0x8a, 0xd3, 0xf6, 0x90, 0x93, 0xcd, 0xe7, 0x79, 0xde, 0x8f, 0x79, 0xdf,
	0x99, 0x77, 0x06, 0x82, 0xfb, 0x43, 0x43, 0xbf, 0xc1, 0x03, 0x75, 0xd0, 0xc1, 0xfb, 0x3d, 0xdc,
	0xbd, 0xc2, 0xc6, 0xfe, 0xcd, 0xeb, 0xfe, 0x7f, 0x7b, 0x43, 0x43, 0x27, 0x3a, 0xda, 0x08, 0x25,
	0x7b, 0x3e, 0x71, 0xf3, 0xba, 0xb0, 0x71, 0xa5, 0x5f, 0xe9, 0x54, 0xb0, 0xef, 0xfd, 0xc7, 0xb4,
	0xc2, 0x76, 0x47, 0x37, 0xfb, 0xba, 0xa9, 0x30, 0x82, 0x7d, 0x30, 0xaa, 0xfc, 0xe7, 0x0c, 0x14,
	0x8e, 0xa8, 0x79, 0xb5, 0xa7, 0x9a, 0x26, 0xaa, 0xc2, 0x1a, 0xf3, 0xa6, 0x74, 0xbc, 0x6f, 0x45,
	0xeb, 0x16, 0x39, 0x89, 0xdb, 0x59, 0x92, 0xef, 0xb8, 0x8e, 0xb8, 0xd5, 0x0b, 0x95, 0x8d, 0xee,
	0xd7, 0xf4, 0xbe, 0x46, 0x70, 0x7f, 0x48, 0x46, 0xad, 0x95, 0x18, 0x81, 0xde, 0x82, 0x55, 0xd5,
	0x34, 0x31, 0x09, 0x7d, 0x64, 0xa8, 0x0f, 0xc1, 0x75, 0xc4, 0x97, 0x29, 0x93, 0x76, 0xb1, 0x1c,
	0xc5, 0xd1, 0x57, 0x20, 0xd7, 0xc5, 0x03, 0xbd, 0x5f, 0xcc, 0x52, 0xc3, 0x97, 0x5c, 0x47, 0x5c,
	0xa3, 0x40, 0xc4, 0x82, 0x29, 0xd0, 0x25, 0xa0, 0xbe, 0xaa, 0x0d, 0x88, 0xaa, 0x0d, 0xb0, 0xa1,
	0xa8, 0xdd, 0xae, 0x81, 0x4d, 0xb3, 0x38, 0x4f, 0xed, 0xbe, 0xe5, 0x3a, 0xe2, 0x9d, 0x90, 0xad,
	0x30, 0x32, 0xf4, 0xf1, 0xd9, 0xc7, 0x8f, 0x36, 0xfc, 0x72, 0xf8, 0xdc, 0x29, 0x31, 0xb4, 0xc1,
	0x55, 0x6b, 0x3d, 0x65, 0x54, 0xb6, 0x39, 0xd8, 0x88, 0x54, 0xaa, 0x3e, 0x20, 0xc6, 0xa8, 0x3d,
	0x1a, 0x62, 0x24, 0x41, 0xc6, 0xaf, 0x52, 0x4e, 0xe6, 0x5d, 0x47, 0x5c, 0xd6, 0xa2, 0xeb, 0xca,
	0x68, 0x5d, 0xf4, 0x10, 0xe6, 0x3b, 0x7a, 0x17, 0xfb, 0x55, 0x40, 0xae, 0x23, 0xae, 0x7a, 0xdf,
	0x11, 0x15, 0xe5, 0xd1, 0x77, 0xa1, 0xd0, 0xc5, 0x66, 0xc7, 0xd0, 0x86, 0x44, 0xd3, 0x07, 0xfe,
	0xda, 0xb7, 0x5d, 0x47, 0xdc, 0x8c, 0xc0, 0x11, 0xab, 0xa8, 0xba, 0xfc, 0x47, 0x0e, 0x36, 0x23,
	0xf9, 0x9d, 0x12, 0x95, 0x5c, 0x9b, 0x5f, 0xa6, 0x04, 0x47, 0xb0, 0xc4, 0xf2, 0x7b, 0x17, 0x8f,
	0xd0, 0x2e, 0xe4, 0x07, 0x97, 0x24, 0xdc, 0x5e, 0xb4, 0xc3, 0x83, 0x4b, 0x12, 0xdb, 0x13, 0x39,
	0x0a, 0xfc, 0xef, 0xdb, 0xa9, 0xfc, 0xcf, 0x3c, 0xe4, 0x59, 0x6c, 0x54, 0x83, 0xec, 0x53, 0x3c,
	0xa2, 0x51, 0x0b, 0x87, 0xe2, 0xde, 0xa4, 0x53, 0xb4, 0x17, 0xa4, 0x29, 0xaf, 0xbb, 0x8e, 0xb8,
	0xf2, 0x14, 0x8f, 0x22, 0x9e, 0x3d, 0xf3, 0x49, 0xc7, 0x24, 0xf3, 0xdf, 0x1c, 0x13, 0x93, 0x76,
	0x49, 0x21, 0xa3, 0x21, 0xf6, 0x7c, 0x64, 0x69, 0x8f, 0xe8, 0xba, 0xcc, 0xa0, 0x7f, 0xf1, 0x75,
	0x45, 0x71, 0xf4, 0x7d, 0x58, 0x19, 0xe0, 0x67, 0x44, 0x19, 0xf6, 0x89, 0xd2, 0x55, 0x09, 0xa6,
	0xdb, 0x3e, 0xc7, 0x3a, 0xe2, 0x11, 0x27, 0x7d, 0x52, 0x53, 0x49, 0xb4, 0x8f, 0x85, 0x08, 0x8c,
	0xde, 0x84, 0xe5, 0xc0, 0x5c, 0xed, 0x93, 0x62, 0x4e, 0xe2, 0x76, 0xb2, 0x72, 0xd1, 0x75, 0xc4,
	0x0d, 0x5f, 0x56, 0xe9, 0x93, 0x88, 0x31, 0x84, 0x28, 0xfa, 0x21, 0xac, 0x68, 0x03, 0x82, 0x0d,
	0x6c, 0x12, 0xc5, 0xf0, 0x42, 0xe7, 0xc3, 0xdc, 0xc7, 0x44, 0x2b, 0x1e, 0x7b, 0x39, 0x8a, 0x7b,
	0x0e, 0xfa, 0x2a, 0xb9, 0x36, 0x34, 0x32, 0x62, 0xb9, 0x2f, 0x84, 0x0e, 0xc6, 0x44, 0x22, 0xf9,
	0xe5, 0x28, 0x8e, 0x9e, 0x01, 0x0a, 0x32, 0xe8, 0xaa, 0x23, 0xa5, 0xa3, 0x5f, 0x0f, 0x48, 0x71,
	0x51, 0xe2, 0x76, 0x56, 0x0f, 0x4b, 0x93, 0x1b, 0x5b, 0x53, 0x47, 0x55, 0x4f, 0x25, 0xef, 0xba,
	0x8e, 0x28, 0x8c, 0xad, 0xc7, 0x68, 0x18, 0xe9, 0xdf, 0x8e, 0xb8, 0x38, 0x46, 0x5b, 0x7c, 0x52,
	0x87, 0x7e, 0xcd, 0x41, 0x00, 0x2a, 0x6a, 0xa7, 0x63, 0x5c, 0xab, 0xbd, 0xe2, 0x12, 0x0d, 0xfc,
	0xea, 0xe4, 0xc0, 0x0d, 0x5f, 0x5d, 0x61, 0x62, 0xf9, 0xc0, 0x75, 0xc4, 0x6d, 0x2d, 0x0e, 0xc6,
	0xc2, 0xaf, 0x25, 0x2c, 0x5a, 0x6b, 0x09, 0x35, 0xfa, 0x0d, 0x07, 0xeb, 0x43, 0x75, 0xd4, 0xc7,
	0x03, 0xa2, 0x5c, 0x1a, 0xf8, 0x17, 0xd7, 0x78, 0xd0, 0x19, 0x15, 0x81, 0x66, 0xf1, 0x70, 0x72,
	0x16, 0x27, 0x4c, 0xfe, 0x78, 0xac, 0x96, 0x0f, 0xbd, 0x32, 0x0c, 0x13, 0x68, 0x2c, 0x0f, 0x3e,
	0x69, 0xd3, 0xe2, 0x93, 0xfa, 0xe4, 0xe4, 0x91, 0xaf, 0x3b, 0x4f, 0x31, 0xf9, 0x32, 0x4d, 0x9e,
	0xdf, 0xe5, 0xc7, 0x97, 0x1c, 0x9d, 0xda, 0x48, 0x86, 0xd5, 0x8e, 0x6e, 0x18, 0xb8, 0xa7, 0x7a,
	0x74, 0xe2, 0x8e, 0x8b, 0x30, 0xf1, 0xc3, 0x1b, 0x23, 0xd0, 0x4f, 0x61, 0xcb, 0xc0, 0x37, 0xd8,
	0x30, 0xb1, 0xa9, 0x24, 0x9c, 0xb1, 0xb5, 0x3c, 0x70, 0x1d, 0x51, 0x1c, 0x4b, 0xaa, 0x53, 0x9c,
	0x6e, 0x4e, 0x14, 0xa0, 0x47, 0xb0, 0xa0, 0x99, 0xca, 0x8d, 0xee, 0x8f, 0x84, 0x45, 0x79, 0xc3,
	0x75, 0x44, 0x5e, 0x33, 0xdf, 0xd7, 0x63, 0x05, 0xcc, 0x33, 0x04, 0x1d, 0xc2, 0xa2, 0xc9, 0x9a,
	0xc1, 0x26, 0xc0, 0x8a, 0xfc, 0xb2, 0xeb, 0x88, 0x68, 0x8c, 0x45, 0x2c, 0x02, 0x9d, 0x37, 0x3a,
	0xb0, 0x57, 0x8c, 0x60, 0xf6, 0xe4, 0xc2, 0xd1, 0x81, 0xc7, 0x77, 0x5b, 0x2c, 0xd7, 0x42, 0x04,
	0x46, 0xdf, 0x81, 0xc2, 0x50, 0x37, 0x09, 0xee, 0x46, 0xcf, 0x2e, 0x9d, 0x1c, 0x0c, 0x4e, 0x9c,
	0x5c, 0x08, 0x51, 0xaf, 0xfa, 0xf8, 0xf2, 0x12, 0x77, 0x88, 0x76, 0x83, 0x99, 0xf5, 0x22, 0xb5,
	0xa6, 0xd5, 0x0f, 0x98, 0x84, 0x83, 0x95, 0x18, 0x81, 0x7e, 0x06, 0x4b, 0x44, 0x27, 0x6a, 0x8f,
	0x8e, 0xad, 0x25, 0x5a, 0xef, 0xca, 0x27, 0x8e, 0x38, 0xf7, 0x0f, 0x47, 0xdc, 0x64, 0x17, 0xba,
	0xd9, 0x7d, 0xba, 0xa7, 0xe9, 0xfb, 0x7d, 0x95, 0x7c, 0xe8, 0x9d, 0x3e, 0xaf, 0x1e, 0xd4, 0x22,
	0x36, 0xd1, 0x3e, 0xfb, 0xf8, 0x11, 0xf8, 0xf7, 0x7f, 0x63, 0x40, 0x5a, 0x8b, 0x63, 0x05, 0xd2,
	0x61, 0x4d, 0x1d, 0x0e, 0x7b, 0x1a, 0xee, 0x2a, 0x6a, 0xdf, 0x3b, 0xf3, 0x66, 0x11, 0xa4, 0xec,
	0x4e, 0xe1, 0x70, 0x67, 0xd6, 0x8d, 0xc1, 0x76, 0x7e, 0x85, 0x1a, 0xc8, 0x77, 0x5d, 0x47, 0x2c,
	0xfa, 0x4e, 0x18, 0x14, 0x79, 0x78, 0xb4, 0x56, 0xe3, 0x0c, 0xfa, 0x39, 0xac, 0x5d, 0xa8, 0x3d,
	0xcf, 0x6b, 0x10, 0xb0, 0x40, 0x03, 0x3e, 0x98, 0x1c, 0x90, 0x85, 0x92, 0x99, 0x09, 0x8b, 0xe5,
	0xdb, 0x4f, 0x88, 0x15, 0x67, 0xca, 0x7f, 0xe3, 0x00, 0xa5, 0x13, 0xf6, 0xae, 0xa3, 0x0b, 0xfa,
	0x1d, 0x6c, 0x09, 0x2e, 0x9c, 0xc8, 0x17, 0xc1, 0xa1, 0x8e, 0x5f, 0x47, 0x51, 0x1c, 0x75, 0xa1,
	0x10, 0x56, 0x8d, 0xf8, 0xe7, 0xa0, 0xfa, 0x79, 0x7d, 0xd9, 0x08, 0x4a, 0x31, 0xbd, 0x33, 0x10,
	0x6a, 0xca, 0x37, 0xb0, 0xe8, 0xaf, 0x9b, 0x95, 0x8d, 0xe5, 0xec, 0xaf, 0xd1, 0x2c, 0x72, 0x5f,
	0xb4, 0x6c, 0x51, 0x28, 0x5e, 0xb6, 0x18, 0x53, 0xfe, 0x2b, 0x07, 0x2b, 0x31, 0xfb, 0xff, 0x4f,
	0xc5, 0xc2, 0xb6, 0xdf, 0xbe, 0x62, 0x41, 0x43, 0x67, 0x54, 0x2c, 0xd4, 0x94, 0x7f, 0x09, 0x0b,
	0xac, 0xdf, 0x26, 0x1a, 0xc2, 0xba, 0xff, 0x70, 0x21, 0xba, 0xe2, 0x1d, 0x68, 0x2d, 0x28, 0xd9,
	0xab, 0xb3, 0xb6, 0x76, 0x5b, 0xaf, 0x33, 0xb1, 0x7c, 0xcf, 0xbb, 0xba, 0x7a, 0x71, 0x30, 0xb2,
	0xbe, 0xb5, 0x04, 0x55, 0xb6, 0x32, 0xb0, 0x96, 0xf0, 0x81, 0x3e, 0x00, 0xf0, 0xb3, 0xf8, 0x02,
	0x6f, 0xb1, 0x2d, 0xd7, 0x11, 0x5f, 0xea, 0x8d, 0x3f, 0x23, 0x21, 0x97, 0x02, 0x10, 0xbd, 0x03,
	0x79, 0xf6, 0x41, 0x4b, 0x59, 0x38, 0xbc, 0x3b, 0xf3, 0xb8, 0xd2, 0xa9, 0xca, 0xd0, 0xe8, 0x54,
	0x65, 0x08, 0x6a, 0xc1, 0xc2, 0xb8, 0x40, 0x59, 0x5a, 0xa0, 0xfb, 0xb3, 0x9c, 0xd1, 0x9b, 0x45,
	0xde, 0x74, 0x1d, 0x71, 0x1d, 0xa7, 0x8a, 0x32, 0x76, 0xb4, 0xfb, 0xab, 0x2c, 0x04, 0x0f, 0x0b,
	0xf4, 0x75, 0xd8, 0xac, 0x55, 0xce, 0x95, 0xea, 0xf1, 0x59, 0xb3, 0xad, 0x9c, 0x35, 0x4f, 0x4f,
	0xea, 0xd5, 0xc6, 0xe3, 0x46, 0xbd, 0xc6, 0xcf, 0x09, 0xdb, 0x96, 0x2d, 0x4d, 0x26, 0xd1, 0x21,
	0x6c, 0x84, 0x44, 0xa5, 0xda, 0x3e, 0xab, 0x1c, 0x29, 0x6f, 0x7c, 0xf3, 0x1b, 0x3c, 0x27, 0x14,
	0x2d, 0x5b, 0x9a, 0xc8, 0x4d, 0xb1, 0x39, 0xe0, 0x33, 0x53, 0x6d, 0x0e, 0xe2, 0x36, 0xed, 0xb7,
	0x1b, 0xad, 0xf6, 0x39, 0xb5, 0xc9, 0x26, 0x6d, 0x42, 0x0e, 0x7d, 0x1b, 0xb6, 0x52, 0xbe, 0xd8,
	0x1f, 0x7e, 0x5e, 0xb8, 0x63, 0xd9, 0xd2, 0x34, 0x1a, 0xed, 0x01, 0x0a, 0xa9, 0x5a, 0xe5, 0xfc,
	0x94, 0xae, 0x29, 0x27, 0xbc, 0x6c, 0xd9, 0xd2, 0x04, 0x66, 0xa2, 0xfe, 0x80, 0xcf, 0x4f, 0xd1,
	0x1f, 0x08, 0x8b, 0xbf, 0xfd, 0xa8, 0x34, 0xf7, 0x97, 0x3f, 0x95, 0xb8, 0xdd, 0x8f, 0x72, 0x90,
	0x7c, 0x5c, 0x21, 0x19, 0xee, 0x36, 0x9a, 0xed, 0x7a, 0xab, 0x7e, 0xea, 0xe5, 0x55, 0x6d, 0x79,
	0x89, 0xc5, 0x1b, 0x22, 0x59, 0xb6, 0x34, 0x53, 0x83, 0xde, 0x01, 0x29, 0xc5, 0x9f, 0x36, 0x9e,
	0x9c, 0x1c, 0xd5, 0x95, 0x31, 0xce, 0x73, 0xc2, 0x2b, 0x96, 0x2d, 0x7d, 0xae, 0x0e, 0x35, 0xa1,
	0x9c, 0xd2, 0x54, 0x8f, 0x9f, 0x9c, 0x1c, 0x9f, 0x35, 0x6b, 0xa1, 0xb7, 0x8c, 0xf0, 0xd0, 0xb2,
	0xa5, 0x5b, 0x28, 0x27, 0xfa, 0xab, 0x55, 0x1a, 0x47, 0xe7, 0x81, 0xb6, 0xd1, 0xfc, 0x11, 0x9f,
	0x9d, 0xe2, 0x2f, 0xa5, 0x44, 0x2d, 0x78, 0x25, 0xa5, 0x7a, 0x72, 0xdc, 0x6c, 0xbf, 0x9d, 0xf0,
	0x38, 0x2f, 0xec, 0x58, 0xb6, 0x74, 0x2b, 0x2d, 0x7a, 0x1f, 0x1e, 0xa6, 0x74, 0xef, 0x9d, 0x55,
	0x5a, 0xed, 0x7a, 0x2b, 0xe1, 0x35, 0x27, 0xec, 0x5a, 0xb6, 0x74, 0x4b, 0x35, 0x3a, 0x81, 0x07,
	0x29, 0x65, 0xa5, 0xd9, 0x8c, 0x16, 0xca, 0x73, 0x9a, 0x17, 0x5e, 0xb3, 0x6c, 0xe9, 0x36, 0x52,
	0xf4, 0x63, 0x78, 0x6d, 0x42, 0xcd, 0x9b, 0xed, 0x46, 0xf3, 0xec, 0xf8, 0xec, 0x34, 0xe6, 0x75,
	0x41, 0xf8, 0xaa, 0x65, 0x4b, 0xb7, 0x95, 0x47, 0x76, 0xe9, 0x1f, 0xb2, 0x90, 0x7a, 0x7a, 0xa3,
	0x1a, 0xdc, 0x3b, 0xa9, 0x9c, 0x3f, 0xa9, 0x37, 0xdb, 0xca, 0xe3, 0x56, 0xfd, 0xbd, 0xb3, 0x7a,
	0xb3, 0x7a, 0x9e, 0xd8, 0xa7, 0xf7, 0x2d, 0x5b, 0x9a, 0x2d, 0xf2, 0x0e, 0x69, 0x5a, 0x40, 0x7b,
	0xcc, 0x73, 0xec, 0x90, 0x4e, 0xa1, 0xd1, 0x9b, 0x50, 0x4c, 0x53, 0x1f, 0xd4, 0xeb, 0xef, 0x1e,
	0x9d, 0xf3, 0x19, 0xe1, 0xae, 0x65, 0x4b, 0x53, 0x79, 0xf4, 0x3d, 0xd8, 0x4e, 0x73, 0xfe, 0x3e,
	0xe0, 0xb3, 0xc2, 0x3d, 0xcb, 0x96, 0xa6, 0x0b, 0xd0, 0x5b, 0x70, 0x27, 0x4d, 0x06, 0xfd, 0xe6,
	0xe7, 0x05, 0xd1, 0xb2, 0xa5, 0x59, 0x12, 0xf4, 0x03, 0x10, 0xd2, 0x34, 0x6b, 0xee, 0xd1, 0x39,
	0x9f, 0x13, 0x4a, 0x96, 0x2d, 0xcd, 0x50, 0x84, 0xad, 0x91, 0xaf, 0x3e, 0x79, 0x5e, 0xe2, 0x3e,
	0x7d, 0x5e, 0xe2, 0xfe, 0xf5, 0xbc, 0xc4, 0xfd, 0xfe, 0x45, 0x69, 0xee, 0xd3, 0x17, 0xa5, 0xb9,
	0xbf, 0xbf, 0x28, 0xcd, 0xc1, 0x96, 0xa6, 0x4f, 0xbc, 0x22, 0x4e, 0xb8, 0x9f, 0x1c, 0x5e, 0x69,
	0xe4, 0xc3, 0xeb, 0x8b, 0xbd, 0x8e, 0xde, 0xdf, 0x0f, 0x25, 0x8f, 0x34, 0x3d, 0xf2, 0xb5, 0xff,
	0x6c, 0xfc, 0x63, 0x9f, 0xf7, 0x9c, 0x30, 0x2f, 0xf2, 0xf4, 0x27, 0xba, 0x37, 0xfe, 0x13, 0x00,
	0x00, 0xff, 0xff, 0x8f, 0x51, 0x29, 0x6f, 0x0e, 0x14, 0x00, 0x00,
}

func (m *LedgerClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaintainerAddress) > 0 {
		i -= len(m.MaintainerAddress)
		copy(dAtA[i:], m.MaintainerAddress)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.MaintainerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassEntryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassEntryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassEntryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ledger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ledger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ledger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PaymentFrequency != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PaymentFrequency))
		i--
		dAtA[i] = 0x50
	}
	if m.InterestAccrual != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestAccrual))
		i--
		dAtA[i] = 0x48
	}
	if m.InterestDayCount != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestDayCount))
		i--
		dAtA[i] = 0x40
	}
	if m.MaturityDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.MaturityDate))
		i--
		dAtA[i] = 0x38
	}
	if m.InterestRate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestRate))
		i--
		dAtA[i] = 0x30
	}
	if m.NextPmtAmt != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtAmt))
		i--
		dAtA[i] = 0x28
	}
	if m.NextPmtDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtDate))
		i--
		dAtA[i] = 0x20
	}
	if m.StatusTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.StatusTypeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassBucketType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassBucketType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassBucketType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BalanceAmounts) > 0 {
		for iNdEx := len(m.BalanceAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BalanceAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.AppliedAmounts) > 0 {
		for iNdEx := len(m.AppliedAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppliedAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size := m.TotalAmt.Size()
		i -= size
		if _, err := m.TotalAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.EffectiveDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EffectiveDate))
		i--
		dAtA[i] = 0x40
	}
	if m.PostedDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PostedDate))
		i--
		dAtA[i] = 0x38
	}
	if m.EntryTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EntryTypeId))
		i--
		dAtA[i] = 0x28
	}
	if m.Sequence != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if m.IsVoid {
		i--
		if m.IsVoid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReversesCorrelationId) > 0 {
		i -= len(m.ReversesCorrelationId)
		copy(dAtA[i:], m.ReversesCorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.ReversesCorrelationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CorrelationId) > 0 {
		i -= len(m.CorrelationId)
		copy(dAtA[i:], m.CorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.CorrelationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerBucketAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerBucketAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerBucketAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AppliedAmt.Size()
		i -= size
		if _, err := m.AppliedAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Balances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Balances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Balances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BucketBalances) > 0 {
		for iNdEx := len(m.BucketBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BucketBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BucketBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BalanceAmt.Size()
		i -= size
		if _, err := m.BalanceAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ledgers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ledgers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ledgers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LedgerToEntries) > 0 {
		for iNdEx := len(m.LedgerToEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LedgerToEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LedgerToEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerToEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerToEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ledger != nil {
		{
			size, err := m.Ledger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LedgerKey != nil {
		{
			size, err := m.LedgerKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLedger(dAtA []byte, offset int, v uint64) int {
	offset -= sovLedger(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LedgerClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.MaintainerAddress)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassEntryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *Ledger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.StatusTypeId != 0 {
		n += 1 + sovLedger(uint64(m.StatusTypeId))
	}
	if m.NextPmtDate != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtDate))
	}
	if m.NextPmtAmt != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtAmt))
	}
	if m.InterestRate != 0 {
		n += 1 + sovLedger(uint64(m.InterestRate))
	}
	if m.MaturityDate != 0 {
		n += 1 + sovLedger(uint64(m.MaturityDate))
	}
	if m.InterestDayCount != 0 {
		n += 1 + sovLedger(uint64(m.InterestDayCount))
	}
	if m.InterestAccrual != 0 {
		n += 1 + sovLedger(uint64(m.InterestAccrual))
	}
	if m.PaymentFrequency != 0 {
		n += 1 + sovLedger(uint64(m.PaymentFrequency))
	}
	return n
}

func (m *LedgerClassBucketType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.ReversesCorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.IsVoid {
		n += 2
	}
	if m.Sequence != 0 {
		n += 1 + sovLedger(uint64(m.Sequence))
	}
	if m.EntryTypeId != 0 {
		n += 1 + sovLedger(uint64(m.EntryTypeId))
	}
	if m.PostedDate != 0 {
		n += 1 + sovLedger(uint64(m.PostedDate))
	}
	if m.EffectiveDate != 0 {
		n += 1 + sovLedger(uint64(m.EffectiveDate))
	}
	l = m.TotalAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	if len(m.AppliedAmounts) > 0 {
		for _, e := range m.AppliedAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.BalanceAmounts) > 0 {
		for _, e := range m.BalanceAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *LedgerBucketAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.AppliedAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *Balances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BucketBalances) > 0 {
		for _, e := range m.BucketBalances {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *BucketBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.BalanceAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *Ledgers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LedgerToEntries) > 0 {
		for _, e := range m.LedgerToEntries {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *LedgerToEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerKey != nil {
		l = m.LedgerKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Ledger != nil {
		l = m.Ledger.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func sovLedger(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLedger(x uint64) (n int) {
	return sovLedger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LedgerClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintainerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassEntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassEntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassEntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ledger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ledger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ledger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LedgerKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusTypeId", wireType)
			}
			m.StatusTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtDate", wireType)
			}
			m.NextPmtDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtAmt", wireType)
			}
			m.NextPmtAmt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtAmt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestRate", wireType)
			}
			m.InterestRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaturityDate", wireType)
			}
			m.MaturityDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaturityDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestDayCount", wireType)
			}
			m.InterestDayCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestDayCount |= DayCount(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestAccrual", wireType)
			}
			m.InterestAccrual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestAccrual |= InterestAccrual(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentFrequency", wireType)
			}
			m.PaymentFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentFrequency |= PaymentFrequency(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassBucketType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassBucketType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassBucketType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReversesCorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReversesCorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVoid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVoid = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryTypeId", wireType)
			}
			m.EntryTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostedDate", wireType)
			}
			m.PostedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostedDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveDate", wireType)
			}
			m.EffectiveDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppliedAmounts = append(m.AppliedAmounts, &LedgerBucketAmount{})
			if err := m.AppliedAmounts[len(m.AppliedAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceAmounts = append(m.BalanceAmounts, &BucketBalance{})
			if err := m.BalanceAmounts[len(m.BalanceAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerBucketAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerBucketAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerBucketAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Balances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketBalances = append(m.BucketBalances, &BucketBalance{})
			if err := m.BucketBalances[len(m.BucketBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BalanceAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ledgers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ledgers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ledgers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerToEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerToEntries = append(m.LedgerToEntries, &LedgerToEntries{})
			if err := m.LedgerToEntries[len(m.LedgerToEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerToEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerToEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerToEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerKey == nil {
				m.LedgerKey = &LedgerKey{}
			}
			if err := m.LedgerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ledger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ledger == nil {
				m.Ledger = &Ledger{}
			}
			if err := m.Ledger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &LedgerEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLedger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLedger
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLedger
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLedger
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLedger        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLedger          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLedger = fmt.Errorf("proto: unexpected end of group")
)
