// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/ledger/v1/ledger.proto

package ledger

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Day Count Conventions used in interest calculations
type DayCountConvention int32

const (
	// Unspecified day count convention.
	DayCountConvention_LEDGER_DAY_COUNT_UNSPECIFIED DayCountConvention = 0
	// Actual/365: Uses the actual number of days in the period with a fixed denominator of 365
	// (or sometimes 365.25 to adjust for leap years).
	DayCountConvention_LEDGER_DAY_COUNT_ACTUAL_365 DayCountConvention = 1
	// Actual/360: Uses the actual number of days in the period but divides by 360.
	DayCountConvention_LEDGER_DAY_COUNT_ACTUAL_360 DayCountConvention = 2
	// 30/360: Assumes each month has 30 days and the year has 360 days.
	DayCountConvention_LEDGER_DAY_COUNT_THIRTY_360 DayCountConvention = 3
	// Actual/Actual: Uses the actual number of days in the period and the actual days in the year
	// (365 or 366, depending on the year).
	DayCountConvention_LEDGER_DAY_COUNT_ACTUAL_ACTUAL DayCountConvention = 4
	// 365/365: Always uses 365 days in the denominator regardless of leap years.
	DayCountConvention_LEDGER_DAY_COUNT_DAYS_365 DayCountConvention = 5
	// 360/360: Always uses 360 days in both the numerator and denominator.
	DayCountConvention_LEDGER_DAY_COUNT_DAYS_360 DayCountConvention = 6
)

var DayCountConvention_name = map[int32]string{
	0: "LEDGER_DAY_COUNT_UNSPECIFIED",
	1: "LEDGER_DAY_COUNT_ACTUAL_365",
	2: "LEDGER_DAY_COUNT_ACTUAL_360",
	3: "LEDGER_DAY_COUNT_THIRTY_360",
	4: "LEDGER_DAY_COUNT_ACTUAL_ACTUAL",
	5: "LEDGER_DAY_COUNT_DAYS_365",
	6: "LEDGER_DAY_COUNT_DAYS_360",
}

var DayCountConvention_value = map[string]int32{
	"LEDGER_DAY_COUNT_UNSPECIFIED":   0,
	"LEDGER_DAY_COUNT_ACTUAL_365":    1,
	"LEDGER_DAY_COUNT_ACTUAL_360":    2,
	"LEDGER_DAY_COUNT_THIRTY_360":    3,
	"LEDGER_DAY_COUNT_ACTUAL_ACTUAL": 4,
	"LEDGER_DAY_COUNT_DAYS_365":      5,
	"LEDGER_DAY_COUNT_DAYS_360":      6,
}

func (x DayCountConvention) String() string {
	return proto.EnumName(DayCountConvention_name, int32(x))
}

func (DayCountConvention) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}

// Interest Accrual Methods describing how interest is calculated over time
type InterestAccrualMethod int32

const (
	// Unspecified interest accrual method.
	InterestAccrualMethod_LEDGER_ACCRUAL_UNSPECIFIED InterestAccrualMethod = 0
	// Simple Interest: Calculated only on the principal amount.
	InterestAccrualMethod_LEDGER_ACCRUAL_SIMPLE_INTEREST InterestAccrualMethod = 1
	// Compound Interest: Calculated on both the principal and on previously accumulated interest.
	InterestAccrualMethod_LEDGER_ACCRUAL_COMPOUND_INTEREST InterestAccrualMethod = 2
	// Daily Compounding: Interest is compounded on a daily basis.
	InterestAccrualMethod_LEDGER_ACCRUAL_DAILY_COMPOUNDING InterestAccrualMethod = 3
	// Monthly Compounding: Interest is compounded each month.
	InterestAccrualMethod_LEDGER_ACCRUAL_MONTHLY_COMPOUNDING InterestAccrualMethod = 4
	// Quarterly Compounding: Interest is compounded every quarter.
	InterestAccrualMethod_LEDGER_ACCRUAL_QUARTERLY_COMPOUNDING InterestAccrualMethod = 5
	// Annually Compounding: Interest is compounded once per year.
	InterestAccrualMethod_LEDGER_ACCRUAL_ANNUAL_COMPOUNDING InterestAccrualMethod = 6
	// Continuous Compounding: The theoretical limit of compounding frequency where interest is compounded continuously.
	InterestAccrualMethod_LEDGER_ACCRUAL_CONTINUOUS_COMPOUNDING InterestAccrualMethod = 7
)

var InterestAccrualMethod_name = map[int32]string{
	0: "LEDGER_ACCRUAL_UNSPECIFIED",
	1: "LEDGER_ACCRUAL_SIMPLE_INTEREST",
	2: "LEDGER_ACCRUAL_COMPOUND_INTEREST",
	3: "LEDGER_ACCRUAL_DAILY_COMPOUNDING",
	4: "LEDGER_ACCRUAL_MONTHLY_COMPOUNDING",
	5: "LEDGER_ACCRUAL_QUARTERLY_COMPOUNDING",
	6: "LEDGER_ACCRUAL_ANNUAL_COMPOUNDING",
	7: "LEDGER_ACCRUAL_CONTINUOUS_COMPOUNDING",
}

var InterestAccrualMethod_value = map[string]int32{
	"LEDGER_ACCRUAL_UNSPECIFIED":            0,
	"LEDGER_ACCRUAL_SIMPLE_INTEREST":        1,
	"LEDGER_ACCRUAL_COMPOUND_INTEREST":      2,
	"LEDGER_ACCRUAL_DAILY_COMPOUNDING":      3,
	"LEDGER_ACCRUAL_MONTHLY_COMPOUNDING":    4,
	"LEDGER_ACCRUAL_QUARTERLY_COMPOUNDING":  5,
	"LEDGER_ACCRUAL_ANNUAL_COMPOUNDING":     6,
	"LEDGER_ACCRUAL_CONTINUOUS_COMPOUNDING": 7,
}

func (x InterestAccrualMethod) String() string {
	return proto.EnumName(InterestAccrualMethod_name, int32(x))
}

func (InterestAccrualMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}

// Payment frequencies for loan repayments
type PaymentFrequency int32

const (
	// Unspecified payment frequency.
	PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_UNSPECIFIED PaymentFrequency = 0
	// Daily payments.
	PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_DAILY PaymentFrequency = 1
	// Weekly or biweekly payments.
	PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_WEEKLY PaymentFrequency = 2
	// Monthly payments (most common for consumer loans and mortgages).
	PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_MONTHLY PaymentFrequency = 3
	// Quarterly payments.
	PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_QUARTERLY PaymentFrequency = 4
	// Annual payments.
	PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_ANNUALLY PaymentFrequency = 5
)

var PaymentFrequency_name = map[int32]string{
	0: "LEDGER_PAYMENT_FREQUENCY_UNSPECIFIED",
	1: "LEDGER_PAYMENT_FREQUENCY_DAILY",
	2: "LEDGER_PAYMENT_FREQUENCY_WEEKLY",
	3: "LEDGER_PAYMENT_FREQUENCY_MONTHLY",
	4: "LEDGER_PAYMENT_FREQUENCY_QUARTERLY",
	5: "LEDGER_PAYMENT_FREQUENCY_ANNUALLY",
}

var PaymentFrequency_value = map[string]int32{
	"LEDGER_PAYMENT_FREQUENCY_UNSPECIFIED": 0,
	"LEDGER_PAYMENT_FREQUENCY_DAILY":       1,
	"LEDGER_PAYMENT_FREQUENCY_WEEKLY":      2,
	"LEDGER_PAYMENT_FREQUENCY_MONTHLY":     3,
	"LEDGER_PAYMENT_FREQUENCY_QUARTERLY":   4,
	"LEDGER_PAYMENT_FREQUENCY_ANNUALLY":    5,
}

func (x PaymentFrequency) String() string {
	return proto.EnumName(PaymentFrequency_name, int32(x))
}

func (PaymentFrequency) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}

// LedgerClass contains the configuration for a ledger related to a particular class of asset. The asset class
// is defined by the either a scope spec `x/metadata`, or nft class `x/nft`. Ultimately, the configuration will
// assist in verifying the types that are associated with particular ledger entries.
type LedgerClass struct {
	// Unique ID for the ledger class (eg. 1, 2, 3, etc.)
	// This is necessary since the nft class does not have an owner.
	LedgerClassId string `protobuf:"bytes,1,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledger_class_id,omitempty"`
	// Scope Specification ID or NFT Class ID
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
	// Denom that this class of asset will be ledgered in
	Denom string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty"`
	// Address of the maintainer for the ledger class
	MaintainerAddress string `protobuf:"bytes,4,opt,name=maintainer_address,json=maintainerAddress,proto3" json:"maintainer_address,omitempty"`
}

func (m *LedgerClass) Reset()         { *m = LedgerClass{} }
func (m *LedgerClass) String() string { return proto.CompactTextString(m) }
func (*LedgerClass) ProtoMessage()    {}
func (*LedgerClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}
func (m *LedgerClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClass.Merge(m, src)
}
func (m *LedgerClass) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClass) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClass.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClass proto.InternalMessageInfo

func (m *LedgerClass) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *LedgerClass) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *LedgerClass) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *LedgerClass) GetMaintainerAddress() string {
	if m != nil {
		return m.MaintainerAddress
	}
	return ""
}

// LedgerClassEntryType defines the types of possible ledger entries for a given asset class. These type codes allow
// for minimal data storage while providing a human readable description of the entry type.
type LedgerClassEntryType struct {
	// Unique ID for the entry type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the entry type (eg. "DISBURSEMENT", "PAYMENT", "ADJUSTMENT", "INTEREST", "FEE", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the entry type (eg. "Disbursement", "Payment", "Adjustment", "Interest", "Fee", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassEntryType) Reset()         { *m = LedgerClassEntryType{} }
func (m *LedgerClassEntryType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassEntryType) ProtoMessage()    {}
func (*LedgerClassEntryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}
func (m *LedgerClassEntryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassEntryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassEntryType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassEntryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassEntryType.Merge(m, src)
}
func (m *LedgerClassEntryType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassEntryType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassEntryType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassEntryType proto.InternalMessageInfo

func (m *LedgerClassEntryType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassEntryType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassEntryType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LedgerClassStatusType struct {
	// Unique ID for the status type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the status type (eg. "IN_REPAYMENT", "IN_FORECLOSURE", "FORBEARANCE", "DEFERMENT", "BANKRUPTCY""CLOSED",
	// "CANCELLED", "SUSPENDED", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the status type (eg. "In Repayment", "In Foreclosure", "Forbearance", "Deferment", "Bankruptcy",
	// "Closed", "Cancelled", "Suspended", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassStatusType) Reset()         { *m = LedgerClassStatusType{} }
func (m *LedgerClassStatusType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassStatusType) ProtoMessage()    {}
func (*LedgerClassStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}
func (m *LedgerClassStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassStatusType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassStatusType.Merge(m, src)
}
func (m *LedgerClassStatusType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassStatusType proto.InternalMessageInfo

func (m *LedgerClassStatusType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassStatusType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassStatusType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LedgerKey struct {
	// Identifier for the nft that this ledger is linked to.
	// This could be a `x/metadata` scope id or an `x/nft` nft id.
	// In order to create a ledger for an nft, the nft class must be registered in the ledger module as a LedgerClass.
	NftId string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	// Scope Specification ID or NFT Class ID
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
}

func (m *LedgerKey) Reset()         { *m = LedgerKey{} }
func (m *LedgerKey) String() string { return proto.CompactTextString(m) }
func (*LedgerKey) ProtoMessage()    {}
func (*LedgerKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{3}
}
func (m *LedgerKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerKey.Merge(m, src)
}
func (m *LedgerKey) XXX_Size() int {
	return m.Size()
}
func (m *LedgerKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerKey.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerKey proto.InternalMessageInfo

func (m *LedgerKey) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *LedgerKey) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

// Ledger
type Ledger struct {
	Key *LedgerKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Ledger class id for the ledger
	LedgerClassId string `protobuf:"bytes,2,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledger_class_id,omitempty"`
	// Status of the ledger
	StatusTypeId int32 `protobuf:"varint,3,opt,name=status_type_id,json=statusTypeId,proto3" json:"status_type_id,omitempty"`
	// Next payment date days since epoch
	NextPmtDate int32 `protobuf:"varint,4,opt,name=next_pmt_date,json=nextPmtDate,proto3" json:"next_pmt_date,omitempty"`
	// Next payment amount
	NextPmtAmt int64 `protobuf:"varint,5,opt,name=next_pmt_amt,json=nextPmtAmt,proto3" json:"next_pmt_amt,omitempty"`
	// Interest rate (10000000 = 10.000000%) - 6 decimal places
	InterestRate int32 `protobuf:"varint,6,opt,name=interest_rate,json=interestRate,proto3" json:"interest_rate,omitempty"`
	// Maturity date days since epoch
	MaturityDate int32 `protobuf:"varint,7,opt,name=maturity_date,json=maturityDate,proto3" json:"maturity_date,omitempty"`
	// Day count convention for interest
	InterestDayCountConvention DayCountConvention `protobuf:"varint,8,opt,name=interest_day_count_convention,json=interestDayCountConvention,proto3,enum=provenance.ledger.v1.DayCountConvention" json:"interest_day_count_convention,omitempty"`
	// Interest accrual method for interest
	InterestAccrualMethod InterestAccrualMethod `protobuf:"varint,9,opt,name=interest_accrual_method,json=interestAccrualMethod,proto3,enum=provenance.ledger.v1.InterestAccrualMethod" json:"interest_accrual_method,omitempty"`
	// Payment frequency
	PaymentFrequency PaymentFrequency `protobuf:"varint,10,opt,name=payment_frequency,json=paymentFrequency,proto3,enum=provenance.ledger.v1.PaymentFrequency" json:"payment_frequency,omitempty"`
}

func (m *Ledger) Reset()         { *m = Ledger{} }
func (m *Ledger) String() string { return proto.CompactTextString(m) }
func (*Ledger) ProtoMessage()    {}
func (*Ledger) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{4}
}
func (m *Ledger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ledger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ledger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ledger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ledger.Merge(m, src)
}
func (m *Ledger) XXX_Size() int {
	return m.Size()
}
func (m *Ledger) XXX_DiscardUnknown() {
	xxx_messageInfo_Ledger.DiscardUnknown(m)
}

var xxx_messageInfo_Ledger proto.InternalMessageInfo

func (m *Ledger) GetKey() *LedgerKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Ledger) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *Ledger) GetStatusTypeId() int32 {
	if m != nil {
		return m.StatusTypeId
	}
	return 0
}

func (m *Ledger) GetNextPmtDate() int32 {
	if m != nil {
		return m.NextPmtDate
	}
	return 0
}

func (m *Ledger) GetNextPmtAmt() int64 {
	if m != nil {
		return m.NextPmtAmt
	}
	return 0
}

func (m *Ledger) GetInterestRate() int32 {
	if m != nil {
		return m.InterestRate
	}
	return 0
}

func (m *Ledger) GetMaturityDate() int32 {
	if m != nil {
		return m.MaturityDate
	}
	return 0
}

func (m *Ledger) GetInterestDayCountConvention() DayCountConvention {
	if m != nil {
		return m.InterestDayCountConvention
	}
	return DayCountConvention_LEDGER_DAY_COUNT_UNSPECIFIED
}

func (m *Ledger) GetInterestAccrualMethod() InterestAccrualMethod {
	if m != nil {
		return m.InterestAccrualMethod
	}
	return InterestAccrualMethod_LEDGER_ACCRUAL_UNSPECIFIED
}

func (m *Ledger) GetPaymentFrequency() PaymentFrequency {
	if m != nil {
		return m.PaymentFrequency
	}
	return PaymentFrequency_LEDGER_PAYMENT_FREQUENCY_UNSPECIFIED
}

// LedgerClassBucketType represents a bucket type for a ledger class
type LedgerClassBucketType struct {
	// Unique ID for the bucket type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the bucket type (eg. "PRINCIPAL", "INTEREST", "FEE", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the bucket type (eg. "Principal", "Interest", "Fee", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassBucketType) Reset()         { *m = LedgerClassBucketType{} }
func (m *LedgerClassBucketType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassBucketType) ProtoMessage()    {}
func (*LedgerClassBucketType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{5}
}
func (m *LedgerClassBucketType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassBucketType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassBucketType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassBucketType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassBucketType.Merge(m, src)
}
func (m *LedgerClassBucketType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassBucketType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassBucketType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassBucketType proto.InternalMessageInfo

func (m *LedgerClassBucketType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassBucketType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassBucketType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerEntry
type LedgerEntry struct {
	// Correlation ID for tracking ledger entries with external systems (max 50 characters)
	CorrelationId string `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
	// If this entry reverses another entry, the correlation id of the entry it reverses
	ReversesCorrelationId string `protobuf:"bytes,2,opt,name=reverses_correlation_id,json=reversesCorrelationId,proto3" json:"reverses_correlation_id,omitempty"`
	// If true, this entry is a void and should not be included in the ledger balance calculations
	IsVoid bool `protobuf:"varint,3,opt,name=is_void,json=isVoid,proto3" json:"is_void,omitempty"`
	// The NFT address that this ledger entry pertains to
	// Sequence number of the ledger entry (less than 100)
	// This field is used to maintain the correct order of entries when multiple entries
	// share the same effective date. Entries are sorted first by effective date, then by sequence.
	Sequence uint32 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// The type of ledger entry specified by the LedgerClassEntryType.id
	EntryTypeId int32 `protobuf:"varint,5,opt,name=entry_type_id,json=entryTypeId,proto3" json:"entry_type_id,omitempty"`
	// Posted date days since epoch
	PostedDate int32 `protobuf:"varint,7,opt,name=posted_date,json=postedDate,proto3" json:"posted_date,omitempty"`
	// Effective date days since epoch
	EffectiveDate int32 `protobuf:"varint,8,opt,name=effective_date,json=effectiveDate,proto3" json:"effective_date,omitempty"`
	// Total amount of the ledger entry
	TotalAmt cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=total_amt,json=totalAmt,proto3,customtype=cosmossdk.io/math.Int" json:"total_amt"`
	// Applied amounts for each bucket
	AppliedAmounts []*LedgerBucketAmount `protobuf:"bytes,10,rep,name=applied_amounts,json=appliedAmounts,proto3" json:"applied_amounts,omitempty"`
	// Balances for each bucket
	BalanceAmounts []*BucketBalance `protobuf:"bytes,11,rep,name=balance_amounts,json=balanceAmounts,proto3" json:"balance_amounts,omitempty"`
}

func (m *LedgerEntry) Reset()         { *m = LedgerEntry{} }
func (m *LedgerEntry) String() string { return proto.CompactTextString(m) }
func (*LedgerEntry) ProtoMessage()    {}
func (*LedgerEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{6}
}
func (m *LedgerEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerEntry.Merge(m, src)
}
func (m *LedgerEntry) XXX_Size() int {
	return m.Size()
}
func (m *LedgerEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerEntry proto.InternalMessageInfo

func (m *LedgerEntry) GetCorrelationId() string {
	if m != nil {
		return m.CorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetReversesCorrelationId() string {
	if m != nil {
		return m.ReversesCorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetIsVoid() bool {
	if m != nil {
		return m.IsVoid
	}
	return false
}

func (m *LedgerEntry) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *LedgerEntry) GetEntryTypeId() int32 {
	if m != nil {
		return m.EntryTypeId
	}
	return 0
}

func (m *LedgerEntry) GetPostedDate() int32 {
	if m != nil {
		return m.PostedDate
	}
	return 0
}

func (m *LedgerEntry) GetEffectiveDate() int32 {
	if m != nil {
		return m.EffectiveDate
	}
	return 0
}

func (m *LedgerEntry) GetAppliedAmounts() []*LedgerBucketAmount {
	if m != nil {
		return m.AppliedAmounts
	}
	return nil
}

func (m *LedgerEntry) GetBalanceAmounts() []*BucketBalance {
	if m != nil {
		return m.BalanceAmounts
	}
	return nil
}

type LedgerBucketAmount struct {
	// The bucket type specified by the LedgerClassBucketType.id
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucket_type_id,omitempty"`
	// The amount applied to the bucket
	AppliedAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=applied_amt,json=appliedAmt,proto3,customtype=cosmossdk.io/math.Int" json:"applied_amt"`
}

func (m *LedgerBucketAmount) Reset()         { *m = LedgerBucketAmount{} }
func (m *LedgerBucketAmount) String() string { return proto.CompactTextString(m) }
func (*LedgerBucketAmount) ProtoMessage()    {}
func (*LedgerBucketAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{7}
}
func (m *LedgerBucketAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerBucketAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerBucketAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerBucketAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerBucketAmount.Merge(m, src)
}
func (m *LedgerBucketAmount) XXX_Size() int {
	return m.Size()
}
func (m *LedgerBucketAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerBucketAmount.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerBucketAmount proto.InternalMessageInfo

func (m *LedgerBucketAmount) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// Balances represents the current balances for principal, interest, and other amounts
type Balances struct {
	BucketBalances []*BucketBalance `protobuf:"bytes,1,rep,name=bucket_balances,json=bucketBalances,proto3" json:"bucket_balances,omitempty"`
}

func (m *Balances) Reset()         { *m = Balances{} }
func (m *Balances) String() string { return proto.CompactTextString(m) }
func (*Balances) ProtoMessage()    {}
func (*Balances) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{8}
}
func (m *Balances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Balances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Balances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Balances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Balances.Merge(m, src)
}
func (m *Balances) XXX_Size() int {
	return m.Size()
}
func (m *Balances) XXX_DiscardUnknown() {
	xxx_messageInfo_Balances.DiscardUnknown(m)
}

var xxx_messageInfo_Balances proto.InternalMessageInfo

func (m *Balances) GetBucketBalances() []*BucketBalance {
	if m != nil {
		return m.BucketBalances
	}
	return nil
}

type BucketBalance struct {
	// The bucket type specified by the LedgerClassBucketType.id
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucket_type_id,omitempty"`
	// The balance of the bucket
	BalanceAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=balance_amt,json=balanceAmt,proto3,customtype=cosmossdk.io/math.Int" json:"balance_amt"`
}

func (m *BucketBalance) Reset()         { *m = BucketBalance{} }
func (m *BucketBalance) String() string { return proto.CompactTextString(m) }
func (*BucketBalance) ProtoMessage()    {}
func (*BucketBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{9}
}
func (m *BucketBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketBalance.Merge(m, src)
}
func (m *BucketBalance) XXX_Size() int {
	return m.Size()
}
func (m *BucketBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BucketBalance proto.InternalMessageInfo

func (m *BucketBalance) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// Used for conversion....
type Ledgers struct {
	LedgerToEntries []*LedgerToEntries `protobuf:"bytes,1,rep,name=ledger_to_entries,json=ledgerToEntries,proto3" json:"ledger_to_entries,omitempty"`
}

func (m *Ledgers) Reset()         { *m = Ledgers{} }
func (m *Ledgers) String() string { return proto.CompactTextString(m) }
func (*Ledgers) ProtoMessage()    {}
func (*Ledgers) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{10}
}
func (m *Ledgers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ledgers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ledgers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ledgers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ledgers.Merge(m, src)
}
func (m *Ledgers) XXX_Size() int {
	return m.Size()
}
func (m *Ledgers) XXX_DiscardUnknown() {
	xxx_messageInfo_Ledgers.DiscardUnknown(m)
}

var xxx_messageInfo_Ledgers proto.InternalMessageInfo

func (m *Ledgers) GetLedgerToEntries() []*LedgerToEntries {
	if m != nil {
		return m.LedgerToEntries
	}
	return nil
}

type LedgerToEntries struct {
	LedgerKey *LedgerKey     `protobuf:"bytes,1,opt,name=ledger_key,json=ledgerKey,proto3" json:"ledger_key,omitempty"`
	Ledger    *Ledger        `protobuf:"bytes,2,opt,name=ledger,proto3" json:"ledger,omitempty"`
	Entries   []*LedgerEntry `protobuf:"bytes,3,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *LedgerToEntries) Reset()         { *m = LedgerToEntries{} }
func (m *LedgerToEntries) String() string { return proto.CompactTextString(m) }
func (*LedgerToEntries) ProtoMessage()    {}
func (*LedgerToEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{11}
}
func (m *LedgerToEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerToEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerToEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerToEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerToEntries.Merge(m, src)
}
func (m *LedgerToEntries) XXX_Size() int {
	return m.Size()
}
func (m *LedgerToEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerToEntries.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerToEntries proto.InternalMessageInfo

func (m *LedgerToEntries) GetLedgerKey() *LedgerKey {
	if m != nil {
		return m.LedgerKey
	}
	return nil
}

func (m *LedgerToEntries) GetLedger() *Ledger {
	if m != nil {
		return m.Ledger
	}
	return nil
}

func (m *LedgerToEntries) GetEntries() []*LedgerEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterEnum("provenance.ledger.v1.DayCountConvention", DayCountConvention_name, DayCountConvention_value)
	proto.RegisterEnum("provenance.ledger.v1.InterestAccrualMethod", InterestAccrualMethod_name, InterestAccrualMethod_value)
	proto.RegisterEnum("provenance.ledger.v1.PaymentFrequency", PaymentFrequency_name, PaymentFrequency_value)
	proto.RegisterType((*LedgerClass)(nil), "provenance.ledger.v1.LedgerClass")
	proto.RegisterType((*LedgerClassEntryType)(nil), "provenance.ledger.v1.LedgerClassEntryType")
	proto.RegisterType((*LedgerClassStatusType)(nil), "provenance.ledger.v1.LedgerClassStatusType")
	proto.RegisterType((*LedgerKey)(nil), "provenance.ledger.v1.LedgerKey")
	proto.RegisterType((*Ledger)(nil), "provenance.ledger.v1.Ledger")
	proto.RegisterType((*LedgerClassBucketType)(nil), "provenance.ledger.v1.LedgerClassBucketType")
	proto.RegisterType((*LedgerEntry)(nil), "provenance.ledger.v1.LedgerEntry")
	proto.RegisterType((*LedgerBucketAmount)(nil), "provenance.ledger.v1.LedgerBucketAmount")
	proto.RegisterType((*Balances)(nil), "provenance.ledger.v1.Balances")
	proto.RegisterType((*BucketBalance)(nil), "provenance.ledger.v1.BucketBalance")
	proto.RegisterType((*Ledgers)(nil), "provenance.ledger.v1.Ledgers")
	proto.RegisterType((*LedgerToEntries)(nil), "provenance.ledger.v1.LedgerToEntries")
}

func init() { proto.RegisterFile("provenance/ledger/v1/ledger.proto", fileDescriptor_dee508b012fc2213) }

var fileDescriptor_dee508b012fc2213 = []byte{
	// 1292 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x97, 0x4f, 0x6f, 0x1a, 0x47,
	0x14, 0xc0, 0xbd, 0x60, 0xb0, 0xfd, 0x30, 0x98, 0x8c, 0x6c, 0x99, 0xb8, 0x09, 0x26, 0x38, 0x8e,
	0xdc, 0xa4, 0xb1, 0xf3, 0xa7, 0xcd, 0xa5, 0x52, 0xa5, 0x35, 0x6c, 0xe2, 0x55, 0x30, 0xc6, 0x03,
	0xb4, 0xa5, 0x4a, 0xb5, 0x5a, 0xef, 0x8e, 0x9d, 0x95, 0xd9, 0x1d, 0xba, 0x33, 0xa0, 0x70, 0xee,
	0xa5, 0xc7, 0x7e, 0x98, 0x9c, 0x7a, 0xea, 0xa1, 0x87, 0x48, 0xbd, 0x44, 0x39, 0x55, 0x3d, 0x44,
	0x55, 0xf2, 0x25, 0xaa, 0xf6, 0x52, 0xed, 0xcc, 0xb2, 0x60, 0xc0, 0x56, 0x5c, 0xe5, 0xc4, 0xce,
	0x7b, 0xbf, 0xf7, 0x77, 0xde, 0xbe, 0x15, 0x70, 0xa3, 0xe3, 0xd3, 0x1e, 0xf1, 0x4c, 0xcf, 0x22,
	0x3b, 0x6d, 0x62, 0x9f, 0x10, 0x7f, 0xa7, 0x77, 0x3f, 0x7c, 0xda, 0xee, 0xf8, 0x94, 0x53, 0xb4,
	0x3c, 0x44, 0xb6, 0x43, 0x45, 0xef, 0xfe, 0xda, 0xf2, 0x09, 0x3d, 0xa1, 0x02, 0xd8, 0x09, 0x9e,
	0x24, 0xbb, 0x76, 0xd5, 0xa2, 0xcc, 0xa5, 0xcc, 0x90, 0x0a, 0x79, 0x90, 0xaa, 0xe2, 0x2f, 0x0a,
	0xa4, 0x2a, 0xc2, 0xbc, 0xd4, 0x36, 0x19, 0x43, 0xb7, 0x60, 0x49, 0x7a, 0x33, 0xac, 0xe0, 0x6c,
	0x38, 0x76, 0x4e, 0x29, 0x28, 0x5b, 0x0b, 0x38, 0xdd, 0x1e, 0x52, 0xba, 0x8d, 0x6e, 0x42, 0xc6,
	0x64, 0x8c, 0xf0, 0x21, 0x16, 0x13, 0xd8, 0xa2, 0x90, 0x0e, 0xa8, 0x65, 0x48, 0xd8, 0xc4, 0xa3,
	0x6e, 0x2e, 0x2e, 0x94, 0xf2, 0x80, 0x9e, 0x00, 0x72, 0x4d, 0xc7, 0xe3, 0xa6, 0xe3, 0x11, 0xdf,
	0x30, 0x6d, 0xdb, 0x27, 0x8c, 0xe5, 0x66, 0x03, 0x64, 0x37, 0xf7, 0xe6, 0xe5, 0xdd, 0xe5, 0x30,
	0x43, 0x55, 0x6a, 0xea, 0xdc, 0x77, 0xbc, 0x13, 0x7c, 0x65, 0x68, 0x13, 0x2a, 0x8a, 0xcf, 0x60,
	0x79, 0x24, 0x77, 0xcd, 0xe3, 0x7e, 0xbf, 0xd1, 0xef, 0x10, 0x94, 0x81, 0x58, 0x98, 0x77, 0x02,
	0xc7, 0x1c, 0x1b, 0x21, 0x98, 0xb5, 0xa8, 0x4d, 0xc2, 0x14, 0xc5, 0x33, 0x2a, 0x40, 0xca, 0x26,
	0xcc, 0xf2, 0x9d, 0x0e, 0x77, 0xa8, 0x17, 0x26, 0x38, 0x2a, 0x2a, 0x7e, 0x0f, 0x2b, 0x23, 0xde,
	0xeb, 0xdc, 0xe4, 0x5d, 0xf6, 0x11, 0xdd, 0xef, 0xc1, 0x82, 0x74, 0xff, 0x94, 0xf4, 0xd1, 0x0a,
	0x24, 0xbd, 0x63, 0x3e, 0xec, 0x76, 0xc2, 0x3b, 0xe6, 0x1f, 0xda, 0xe5, 0xe2, 0xaf, 0xb3, 0x90,
	0x94, 0xae, 0xd0, 0x7d, 0x88, 0x9f, 0x92, 0xbe, 0x70, 0x92, 0x7a, 0xb0, 0xbe, 0x3d, 0x6d, 0x46,
	0xb6, 0xa3, 0xa8, 0x38, 0x60, 0xa7, 0xdd, 0x78, 0xec, 0x9c, 0x1b, 0x67, 0xa2, 0x07, 0x06, 0xef,
	0x77, 0x48, 0x80, 0xc5, 0x45, 0x07, 0x16, 0x59, 0xd4, 0x19, 0xdd, 0x46, 0x45, 0x48, 0x7b, 0xe4,
	0x05, 0x37, 0x3a, 0x2e, 0x37, 0x6c, 0x93, 0x13, 0x71, 0xad, 0x09, 0x9c, 0x0a, 0x84, 0x35, 0x97,
	0x97, 0x4d, 0x1e, 0xf4, 0x66, 0x31, 0x62, 0x4c, 0x97, 0xe7, 0x12, 0x05, 0x65, 0x2b, 0x8e, 0x21,
	0x44, 0x54, 0x97, 0xa3, 0x0d, 0x48, 0x3b, 0x1e, 0x27, 0x3e, 0x61, 0xdc, 0xf0, 0x03, 0x2f, 0x49,
	0x19, 0x6a, 0x20, 0xc4, 0x81, 0x9b, 0x0d, 0x48, 0xbb, 0x26, 0xef, 0xfa, 0x0e, 0xef, 0xcb, 0x50,
	0x73, 0x12, 0x1a, 0x08, 0x45, 0xac, 0x53, 0xb8, 0x1e, 0x79, 0xb2, 0xcd, 0xbe, 0x61, 0xd1, 0xae,
	0xc7, 0x0d, 0x8b, 0x7a, 0x3d, 0xe2, 0x89, 0x9b, 0x99, 0x2f, 0x28, 0x5b, 0x99, 0x07, 0x5b, 0xd3,
	0x5b, 0x55, 0x36, 0xfb, 0xa5, 0xc0, 0xa0, 0x14, 0xf1, 0x78, 0x6d, 0xe0, 0x6e, 0x52, 0x87, 0x2c,
	0x58, 0x8d, 0x82, 0x99, 0x96, 0xe5, 0x77, 0xcd, 0xb6, 0xe1, 0x12, 0xfe, 0x9c, 0xda, 0xb9, 0x05,
	0x11, 0xe6, 0xce, 0xf4, 0x30, 0x7a, 0x68, 0xa4, 0x4a, 0x9b, 0x7d, 0x61, 0x82, 0x57, 0x9c, 0x69,
	0x62, 0x54, 0x87, 0x2b, 0x1d, 0xb3, 0xef, 0x12, 0x8f, 0x1b, 0xc7, 0x3e, 0xf9, 0xa1, 0x4b, 0x3c,
	0xab, 0x9f, 0x03, 0xe1, 0xfe, 0xd6, 0x74, 0xf7, 0x35, 0x89, 0x3f, 0x1e, 0xd0, 0x38, 0xdb, 0x19,
	0x93, 0x8c, 0xcd, 0xfa, 0x6e, 0xd7, 0x3a, 0x25, 0xfc, 0x23, 0xce, 0xfa, 0xdf, 0xf1, 0xc1, 0x96,
	0x11, 0x2f, 0x29, 0xda, 0x84, 0x8c, 0x45, 0x7d, 0x9f, 0xb4, 0xcd, 0x40, 0x3d, 0xb2, 0x64, 0x46,
	0xa4, 0xba, 0x8d, 0x1e, 0xc1, 0xaa, 0x4f, 0x7a, 0xc4, 0x67, 0x84, 0x19, 0x63, 0xbc, 0x8c, 0xbf,
	0x32, 0x50, 0x97, 0xce, 0xd8, 0xad, 0xc2, 0x9c, 0xc3, 0x8c, 0x1e, 0x0d, 0x67, 0x74, 0x1e, 0x27,
	0x1d, 0xf6, 0x35, 0x75, 0x6c, 0xb4, 0x06, 0xf3, 0x4c, 0x96, 0x2c, 0x07, 0x33, 0x8d, 0xa3, 0x73,
	0x30, 0xb9, 0x24, 0x48, 0x2e, 0x1a, 0xef, 0x84, 0x9c, 0x5c, 0x32, 0x58, 0x2b, 0xba, 0x8d, 0xd6,
	0x21, 0xd5, 0xa1, 0x8c, 0x13, 0x7b, 0x74, 0xe0, 0x40, 0x8a, 0xc4, 0xb8, 0x6d, 0x42, 0x86, 0x1c,
	0x1f, 0x13, 0x8b, 0x3b, 0x3d, 0x22, 0x99, 0x79, 0xc1, 0xa4, 0x23, 0xa9, 0xc0, 0xf6, 0x60, 0x81,
	0x53, 0x6e, 0xb6, 0xc5, 0xf8, 0x2f, 0x88, 0xc5, 0x77, 0xe7, 0xd5, 0xdb, 0xf5, 0x99, 0x3f, 0xdf,
	0xae, 0xaf, 0xc8, 0xe5, 0xc7, 0xec, 0xd3, 0x6d, 0x87, 0xee, 0xb8, 0x26, 0x7f, 0x1e, 0x8c, 0xc7,
	0x9b, 0x97, 0x77, 0x21, 0xdc, 0x8a, 0xba, 0xc7, 0xf1, 0xbc, 0xb0, 0x0e, 0xde, 0x94, 0x43, 0x58,
	0x32, 0x3b, 0x9d, 0xb6, 0x43, 0x6c, 0xc3, 0x74, 0x83, 0x71, 0x64, 0x39, 0x28, 0xc4, 0xb7, 0x52,
	0xe7, 0x4d, 0xb4, 0xbc, 0x05, 0x79, 0xc1, 0xaa, 0x30, 0xc0, 0x99, 0xd0, 0x81, 0x3c, 0x32, 0x54,
	0x81, 0xa5, 0x23, 0xb3, 0x1d, 0xd8, 0x45, 0x2e, 0x53, 0xc2, 0xe5, 0xc6, 0x74, 0x97, 0xd2, 0xd9,
	0xae, 0x34, 0xc1, 0x99, 0xd0, 0x36, 0xf4, 0x56, 0xfc, 0x49, 0x01, 0x34, 0x19, 0x34, 0xd8, 0x26,
	0x47, 0xe2, 0x1c, 0xb5, 0x5b, 0xce, 0xd8, 0xe2, 0x51, 0x34, 0x7b, 0xba, 0x8d, 0x2a, 0x90, 0x1a,
	0x56, 0xc7, 0xe5, 0xa5, 0x5f, 0xae, 0x53, 0x10, 0x15, 0xc7, 0x8b, 0xdf, 0xc2, 0x7c, 0x98, 0xa5,
	0x2c, 0x52, 0xc6, 0x0f, 0xf3, 0x65, 0x39, 0xe5, 0x32, 0x45, 0x8e, 0x1e, 0x59, 0xf1, 0x47, 0x05,
	0xd2, 0x67, 0x88, 0x0f, 0xaf, 0x6f, 0xd8, 0xea, 0xff, 0x57, 0x5f, 0xd4, 0x6e, 0x5e, 0x7c, 0x06,
	0x73, 0xb2, 0xd3, 0x0c, 0x1d, 0xc2, 0x95, 0x70, 0xa9, 0x73, 0x6a, 0x04, 0x13, 0xec, 0x44, 0x05,
	0x6e, 0x5e, 0x34, 0x18, 0x0d, 0xaa, 0x49, 0x18, 0x87, 0x1f, 0x85, 0x48, 0x50, 0xfc, 0x4d, 0x81,
	0xa5, 0x31, 0x08, 0x7d, 0x05, 0x10, 0x86, 0xb9, 0xc4, 0x57, 0x67, 0xa1, 0x1d, 0x7d, 0xf6, 0x3e,
	0x87, 0xa4, 0x3c, 0x88, 0xd2, 0x53, 0x0f, 0xae, 0x5d, 0x64, 0x8b, 0x43, 0x16, 0x7d, 0x09, 0x73,
	0x83, 0x92, 0xe2, 0xa2, 0xa4, 0x1b, 0x17, 0x99, 0x89, 0x8d, 0x83, 0x07, 0x16, 0xb7, 0xff, 0x55,
	0x00, 0x4d, 0x59, 0xdd, 0x05, 0xb8, 0x56, 0xd1, 0xca, 0x4f, 0x34, 0x6c, 0x94, 0xd5, 0x96, 0x51,
	0x3a, 0x68, 0x56, 0x1b, 0x46, 0xb3, 0x5a, 0xaf, 0x69, 0x25, 0xfd, 0xb1, 0xae, 0x95, 0xb3, 0x33,
	0x68, 0x1d, 0x3e, 0x99, 0x20, 0xd4, 0x52, 0xa3, 0xa9, 0x56, 0x8c, 0x87, 0x8f, 0xbe, 0xc8, 0x2a,
	0x17, 0x03, 0xf7, 0xb2, 0xb1, 0xa9, 0x40, 0x63, 0x4f, 0xc7, 0x8d, 0x96, 0x00, 0xe2, 0xa8, 0x08,
	0xf9, 0xf3, 0x3c, 0xc8, 0x9f, 0xec, 0x2c, 0xba, 0x0e, 0x57, 0x27, 0x98, 0xb2, 0xda, 0xaa, 0x8b,
	0x24, 0x12, 0x17, 0xa9, 0xef, 0x65, 0x93, 0xb7, 0x7f, 0x8f, 0xc1, 0xca, 0xd4, 0xaf, 0x0d, 0xca,
	0xc3, 0x5a, 0x68, 0xa8, 0x96, 0x4a, 0x38, 0x08, 0x79, 0xb6, 0xfc, 0x61, 0x6e, 0x03, 0x7d, 0x5d,
	0xdf, 0xaf, 0x55, 0x34, 0x43, 0xaf, 0x36, 0x34, 0xac, 0xd5, 0x1b, 0x59, 0x05, 0xdd, 0x84, 0xc2,
	0x18, 0x53, 0x3a, 0xd8, 0xaf, 0x1d, 0x34, 0xab, 0xe5, 0x21, 0x15, 0x9b, 0x42, 0x95, 0x55, 0xbd,
	0xd2, 0x8a, 0x58, 0xbd, 0xfa, 0x24, 0x1b, 0x47, 0xb7, 0xa0, 0x38, 0x46, 0xed, 0x1f, 0x54, 0x1b,
	0x7b, 0x63, 0xdc, 0x2c, 0xda, 0x82, 0x9b, 0x63, 0xdc, 0x61, 0x53, 0xc5, 0x0d, 0x0d, 0x8f, 0x91,
	0x09, 0xb4, 0x09, 0x37, 0xc6, 0x48, 0xb5, 0x5a, 0x1d, 0x4d, 0x32, 0xc0, 0x92, 0xe8, 0x53, 0xd8,
	0x9c, 0x28, 0xa2, 0xda, 0xd0, 0xab, 0xcd, 0x83, 0x66, 0xfd, 0x0c, 0x3a, 0x77, 0xfb, 0x1f, 0x05,
	0xb2, 0xe3, 0x1f, 0xd7, 0x91, 0x84, 0x6a, 0x6a, 0x6b, 0x5f, 0xab, 0x36, 0x8c, 0xc7, 0x58, 0x3b,
	0x6c, 0x6a, 0xd5, 0x52, 0xeb, 0xdc, 0x96, 0x4e, 0x92, 0xa2, 0x25, 0x59, 0x05, 0x6d, 0xc0, 0xfa,
	0xb9, 0xcc, 0x37, 0x9a, 0xf6, 0xb4, 0xd2, 0x3a, 0xd3, 0xd1, 0x49, 0x28, 0xec, 0xda, 0x99, 0x8e,
	0x4e, 0x52, 0x51, 0xcf, 0xb2, 0xb3, 0x23, 0x7d, 0x9a, 0xe4, 0x64, 0xc7, 0x2a, 0xad, 0x6c, 0x62,
	0xd7, 0x7c, 0xf5, 0x2e, 0xaf, 0xbc, 0x7e, 0x97, 0x57, 0xfe, 0x7a, 0x97, 0x57, 0x7e, 0x7e, 0x9f,
	0x9f, 0x79, 0xfd, 0x3e, 0x3f, 0xf3, 0xc7, 0xfb, 0xfc, 0x0c, 0xac, 0x3a, 0x74, 0xea, 0x0b, 0x59,
	0x53, 0xbe, 0xfb, 0xec, 0xc4, 0xe1, 0xcf, 0xbb, 0x47, 0xdb, 0x16, 0x75, 0x77, 0x86, 0xc8, 0x5d,
	0x87, 0x8e, 0x9c, 0x76, 0x5e, 0x84, 0xff, 0x74, 0x8e, 0x92, 0xe2, 0x3f, 0xca, 0xc3, 0xff, 0x02,
	0x00, 0x00, 0xff, 0xff, 0x08, 0xb1, 0x9c, 0xc1, 0x0f, 0x0d, 0x00, 0x00,
}

func (m *LedgerClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaintainerAddress) > 0 {
		i -= len(m.MaintainerAddress)
		copy(dAtA[i:], m.MaintainerAddress)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.MaintainerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassEntryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassEntryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassEntryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ledger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ledger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ledger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PaymentFrequency != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PaymentFrequency))
		i--
		dAtA[i] = 0x50
	}
	if m.InterestAccrualMethod != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestAccrualMethod))
		i--
		dAtA[i] = 0x48
	}
	if m.InterestDayCountConvention != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestDayCountConvention))
		i--
		dAtA[i] = 0x40
	}
	if m.MaturityDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.MaturityDate))
		i--
		dAtA[i] = 0x38
	}
	if m.InterestRate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestRate))
		i--
		dAtA[i] = 0x30
	}
	if m.NextPmtAmt != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtAmt))
		i--
		dAtA[i] = 0x28
	}
	if m.NextPmtDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtDate))
		i--
		dAtA[i] = 0x20
	}
	if m.StatusTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.StatusTypeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassBucketType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassBucketType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassBucketType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BalanceAmounts) > 0 {
		for iNdEx := len(m.BalanceAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BalanceAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.AppliedAmounts) > 0 {
		for iNdEx := len(m.AppliedAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppliedAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size := m.TotalAmt.Size()
		i -= size
		if _, err := m.TotalAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.EffectiveDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EffectiveDate))
		i--
		dAtA[i] = 0x40
	}
	if m.PostedDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PostedDate))
		i--
		dAtA[i] = 0x38
	}
	if m.EntryTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EntryTypeId))
		i--
		dAtA[i] = 0x28
	}
	if m.Sequence != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if m.IsVoid {
		i--
		if m.IsVoid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReversesCorrelationId) > 0 {
		i -= len(m.ReversesCorrelationId)
		copy(dAtA[i:], m.ReversesCorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.ReversesCorrelationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CorrelationId) > 0 {
		i -= len(m.CorrelationId)
		copy(dAtA[i:], m.CorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.CorrelationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerBucketAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerBucketAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerBucketAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AppliedAmt.Size()
		i -= size
		if _, err := m.AppliedAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Balances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Balances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Balances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BucketBalances) > 0 {
		for iNdEx := len(m.BucketBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BucketBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BucketBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BalanceAmt.Size()
		i -= size
		if _, err := m.BalanceAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ledgers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ledgers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ledgers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LedgerToEntries) > 0 {
		for iNdEx := len(m.LedgerToEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LedgerToEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LedgerToEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerToEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerToEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ledger != nil {
		{
			size, err := m.Ledger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LedgerKey != nil {
		{
			size, err := m.LedgerKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLedger(dAtA []byte, offset int, v uint64) int {
	offset -= sovLedger(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LedgerClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.MaintainerAddress)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassEntryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *Ledger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.StatusTypeId != 0 {
		n += 1 + sovLedger(uint64(m.StatusTypeId))
	}
	if m.NextPmtDate != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtDate))
	}
	if m.NextPmtAmt != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtAmt))
	}
	if m.InterestRate != 0 {
		n += 1 + sovLedger(uint64(m.InterestRate))
	}
	if m.MaturityDate != 0 {
		n += 1 + sovLedger(uint64(m.MaturityDate))
	}
	if m.InterestDayCountConvention != 0 {
		n += 1 + sovLedger(uint64(m.InterestDayCountConvention))
	}
	if m.InterestAccrualMethod != 0 {
		n += 1 + sovLedger(uint64(m.InterestAccrualMethod))
	}
	if m.PaymentFrequency != 0 {
		n += 1 + sovLedger(uint64(m.PaymentFrequency))
	}
	return n
}

func (m *LedgerClassBucketType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.ReversesCorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.IsVoid {
		n += 2
	}
	if m.Sequence != 0 {
		n += 1 + sovLedger(uint64(m.Sequence))
	}
	if m.EntryTypeId != 0 {
		n += 1 + sovLedger(uint64(m.EntryTypeId))
	}
	if m.PostedDate != 0 {
		n += 1 + sovLedger(uint64(m.PostedDate))
	}
	if m.EffectiveDate != 0 {
		n += 1 + sovLedger(uint64(m.EffectiveDate))
	}
	l = m.TotalAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	if len(m.AppliedAmounts) > 0 {
		for _, e := range m.AppliedAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.BalanceAmounts) > 0 {
		for _, e := range m.BalanceAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *LedgerBucketAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.AppliedAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *Balances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BucketBalances) > 0 {
		for _, e := range m.BucketBalances {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *BucketBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.BalanceAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *Ledgers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LedgerToEntries) > 0 {
		for _, e := range m.LedgerToEntries {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *LedgerToEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerKey != nil {
		l = m.LedgerKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Ledger != nil {
		l = m.Ledger.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func sovLedger(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLedger(x uint64) (n int) {
	return sovLedger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LedgerClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintainerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassEntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassEntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassEntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ledger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ledger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ledger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LedgerKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusTypeId", wireType)
			}
			m.StatusTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtDate", wireType)
			}
			m.NextPmtDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtAmt", wireType)
			}
			m.NextPmtAmt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtAmt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestRate", wireType)
			}
			m.InterestRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaturityDate", wireType)
			}
			m.MaturityDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaturityDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestDayCountConvention", wireType)
			}
			m.InterestDayCountConvention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestDayCountConvention |= DayCountConvention(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestAccrualMethod", wireType)
			}
			m.InterestAccrualMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestAccrualMethod |= InterestAccrualMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentFrequency", wireType)
			}
			m.PaymentFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentFrequency |= PaymentFrequency(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassBucketType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassBucketType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassBucketType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReversesCorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReversesCorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVoid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVoid = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryTypeId", wireType)
			}
			m.EntryTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostedDate", wireType)
			}
			m.PostedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostedDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveDate", wireType)
			}
			m.EffectiveDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppliedAmounts = append(m.AppliedAmounts, &LedgerBucketAmount{})
			if err := m.AppliedAmounts[len(m.AppliedAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceAmounts = append(m.BalanceAmounts, &BucketBalance{})
			if err := m.BalanceAmounts[len(m.BalanceAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerBucketAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerBucketAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerBucketAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Balances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketBalances = append(m.BucketBalances, &BucketBalance{})
			if err := m.BucketBalances[len(m.BucketBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BalanceAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ledgers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ledgers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ledgers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerToEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerToEntries = append(m.LedgerToEntries, &LedgerToEntries{})
			if err := m.LedgerToEntries[len(m.LedgerToEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerToEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerToEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerToEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerKey == nil {
				m.LedgerKey = &LedgerKey{}
			}
			if err := m.LedgerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ledger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ledger == nil {
				m.Ledger = &Ledger{}
			}
			if err := m.Ledger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &LedgerEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLedger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLedger
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLedger
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLedger
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLedger        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLedger          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLedger = fmt.Errorf("proto: unexpected end of group")
)
