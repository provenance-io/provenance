// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provenance/ledger/v1/ledger.proto

package ledger

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LedgerClass contains the configuration for a ledger related to a particular class of asset. The asset class
// is defined by the either a scope spec `x/metadata`, or nft class `x/nft`. Ultimately, the configuration will
// assist in verifying the types that are associated with particular ledger entries.
type LedgerClass struct {
	// Unique ID for the ledger class (eg. 1, 2, 3, etc.)
	// This is necessary since the nft class does not have an owner.
	LedgerClassId string `protobuf:"bytes,1,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledger_class_id,omitempty"`
	// Scope Specification ID or NFT Class ID
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
	// Denom that this class of asset will be ledgered in
	Denom string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *LedgerClass) Reset()         { *m = LedgerClass{} }
func (m *LedgerClass) String() string { return proto.CompactTextString(m) }
func (*LedgerClass) ProtoMessage()    {}
func (*LedgerClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{0}
}
func (m *LedgerClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClass.Merge(m, src)
}
func (m *LedgerClass) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClass) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClass.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClass proto.InternalMessageInfo

func (m *LedgerClass) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *LedgerClass) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

func (m *LedgerClass) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

// LedgerClassEntryType defines the types of possible ledger entries for a given asset class. These type codes allow
// for minimal data storage while providing a human readable description of the entry type.
type LedgerClassEntryType struct {
	// Unique ID for the entry type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the entry type (eg. "DISBURSEMENT", "SCHEDULED_PAYMENT", "UNSCHEDULED_PAYMENT", "FORECLOSURE_PAYMENT",
	// "FEE", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the entry type (eg. "Disbursement", "Scheduled Payment", "Unscheduled Payment", "Foreclosure
	// Payment", "Fee", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassEntryType) Reset()         { *m = LedgerClassEntryType{} }
func (m *LedgerClassEntryType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassEntryType) ProtoMessage()    {}
func (*LedgerClassEntryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{1}
}
func (m *LedgerClassEntryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassEntryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassEntryType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassEntryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassEntryType.Merge(m, src)
}
func (m *LedgerClassEntryType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassEntryType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassEntryType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassEntryType proto.InternalMessageInfo

func (m *LedgerClassEntryType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassEntryType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassEntryType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LedgerClassStatusType struct {
	// Unique ID for the status type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the status type (eg. "IN_REPAYMENT", "IN_FORECLOSURE", "FORBEARANCE", "DEFERMENT", "BANKRUPTCY""CLOSED",
	// "CANCELLED", "SUSPENDED", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the status type (eg. "In Repayment", "In Foreclosure", "Forbearance", "Deferment", "Bankruptcy",
	// "Closed", "Cancelled", "Suspended", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassStatusType) Reset()         { *m = LedgerClassStatusType{} }
func (m *LedgerClassStatusType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassStatusType) ProtoMessage()    {}
func (*LedgerClassStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{2}
}
func (m *LedgerClassStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassStatusType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassStatusType.Merge(m, src)
}
func (m *LedgerClassStatusType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassStatusType proto.InternalMessageInfo

func (m *LedgerClassStatusType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassStatusType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassStatusType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LedgerKey struct {
	// Identifier for the nft that this ledger is linked to.
	// This could be a `x/metadata` scope id or an `x/nft` nft id.
	// In order to create a ledger for an nft, the nft class must be registered in the ledger module as a LedgerClass.
	NftId string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	// Scope Specification ID or NFT Class ID
	AssetClassId string `protobuf:"bytes,2,opt,name=asset_class_id,json=assetClassId,proto3" json:"asset_class_id,omitempty"`
}

func (m *LedgerKey) Reset()         { *m = LedgerKey{} }
func (m *LedgerKey) String() string { return proto.CompactTextString(m) }
func (*LedgerKey) ProtoMessage()    {}
func (*LedgerKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{3}
}
func (m *LedgerKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerKey.Merge(m, src)
}
func (m *LedgerKey) XXX_Size() int {
	return m.Size()
}
func (m *LedgerKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerKey.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerKey proto.InternalMessageInfo

func (m *LedgerKey) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *LedgerKey) GetAssetClassId() string {
	if m != nil {
		return m.AssetClassId
	}
	return ""
}

// Ledger
type Ledger struct {
	Key *LedgerKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Ledger class id for the ledger
	LedgerClassId string `protobuf:"bytes,2,opt,name=ledger_class_id,json=ledgerClassId,proto3" json:"ledger_class_id,omitempty"`
	// Status of the ledger
	StatusTypeId int32 `protobuf:"varint,3,opt,name=status_type_id,json=statusTypeId,proto3" json:"status_type_id,omitempty"`
	// Next payment date days since epoch
	NextPmtDate int32 `protobuf:"varint,4,opt,name=next_pmt_date,json=nextPmtDate,proto3" json:"next_pmt_date,omitempty"`
	// Next payment amount
	NextPmtAmt int64 `protobuf:"varint,5,opt,name=next_pmt_amt,json=nextPmtAmt,proto3" json:"next_pmt_amt,omitempty"`
	// Interest rate
	InterestRate int32 `protobuf:"varint,6,opt,name=interest_rate,json=interestRate,proto3" json:"interest_rate,omitempty"`
	// Maturity date days since epoch
	MaturityDate int32 `protobuf:"varint,7,opt,name=maturity_date,json=maturityDate,proto3" json:"maturity_date,omitempty"`
}

func (m *Ledger) Reset()         { *m = Ledger{} }
func (m *Ledger) String() string { return proto.CompactTextString(m) }
func (*Ledger) ProtoMessage()    {}
func (*Ledger) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{4}
}
func (m *Ledger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ledger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ledger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ledger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ledger.Merge(m, src)
}
func (m *Ledger) XXX_Size() int {
	return m.Size()
}
func (m *Ledger) XXX_DiscardUnknown() {
	xxx_messageInfo_Ledger.DiscardUnknown(m)
}

var xxx_messageInfo_Ledger proto.InternalMessageInfo

func (m *Ledger) GetKey() *LedgerKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Ledger) GetLedgerClassId() string {
	if m != nil {
		return m.LedgerClassId
	}
	return ""
}

func (m *Ledger) GetStatusTypeId() int32 {
	if m != nil {
		return m.StatusTypeId
	}
	return 0
}

func (m *Ledger) GetNextPmtDate() int32 {
	if m != nil {
		return m.NextPmtDate
	}
	return 0
}

func (m *Ledger) GetNextPmtAmt() int64 {
	if m != nil {
		return m.NextPmtAmt
	}
	return 0
}

func (m *Ledger) GetInterestRate() int32 {
	if m != nil {
		return m.InterestRate
	}
	return 0
}

func (m *Ledger) GetMaturityDate() int32 {
	if m != nil {
		return m.MaturityDate
	}
	return 0
}

type LedgerClassBucketType struct {
	// Unique ID for the bucket type (eg. 1, 2, 3, etc.)
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Code for the bucket type (eg. "PRINCIPAL", "INTEREST", "OTHER")
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// Description of the bucket type (eg. "Principal", "Interest", "Other")
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LedgerClassBucketType) Reset()         { *m = LedgerClassBucketType{} }
func (m *LedgerClassBucketType) String() string { return proto.CompactTextString(m) }
func (*LedgerClassBucketType) ProtoMessage()    {}
func (*LedgerClassBucketType) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{5}
}
func (m *LedgerClassBucketType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerClassBucketType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerClassBucketType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerClassBucketType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerClassBucketType.Merge(m, src)
}
func (m *LedgerClassBucketType) XXX_Size() int {
	return m.Size()
}
func (m *LedgerClassBucketType) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerClassBucketType.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerClassBucketType proto.InternalMessageInfo

func (m *LedgerClassBucketType) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LedgerClassBucketType) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *LedgerClassBucketType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// LedgerEntry
type LedgerEntry struct {
	// Correlation ID for tracking ledger entries with external systems (max 50 characters)
	CorrelationId string `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
	// If this entry reverses another entry, the correlation id of the entry it reverses
	ReversesCorrelationId string `protobuf:"bytes,2,opt,name=reverses_correlation_id,json=reversesCorrelationId,proto3" json:"reverses_correlation_id,omitempty"`
	// If true, this entry is a void and should not be included in the ledger balance calculations
	IsVoid bool `protobuf:"varint,3,opt,name=is_void,json=isVoid,proto3" json:"is_void,omitempty"`
	// The NFT address that this ledger entry pertains to
	// Sequence number of the ledger entry (less than 100)
	// This field is used to maintain the correct order of entries when multiple entries
	// share the same effective date. Entries are sorted first by effective date, then by sequence.
	Sequence uint32 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// The type of ledger entry specified by the LedgerClassEntryType.id
	EntryTypeId int32 `protobuf:"varint,5,opt,name=entry_type_id,json=entryTypeId,proto3" json:"entry_type_id,omitempty"`
	// Posted date days since epoch
	PostedDate int32 `protobuf:"varint,7,opt,name=posted_date,json=postedDate,proto3" json:"posted_date,omitempty"`
	// Effective date days since epoch
	EffectiveDate int32                 `protobuf:"varint,8,opt,name=effective_date,json=effectiveDate,proto3" json:"effective_date,omitempty"`
	TotalAmt      cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=total_amt,json=totalAmt,proto3,customtype=cosmossdk.io/math.Int" json:"total_amt"`
	// Applied amounts for each bucket
	AppliedAmounts []*LedgerBucketAmount `protobuf:"bytes,10,rep,name=applied_amounts,json=appliedAmounts,proto3" json:"applied_amounts,omitempty"`
}

func (m *LedgerEntry) Reset()         { *m = LedgerEntry{} }
func (m *LedgerEntry) String() string { return proto.CompactTextString(m) }
func (*LedgerEntry) ProtoMessage()    {}
func (*LedgerEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{6}
}
func (m *LedgerEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerEntry.Merge(m, src)
}
func (m *LedgerEntry) XXX_Size() int {
	return m.Size()
}
func (m *LedgerEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerEntry proto.InternalMessageInfo

func (m *LedgerEntry) GetCorrelationId() string {
	if m != nil {
		return m.CorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetReversesCorrelationId() string {
	if m != nil {
		return m.ReversesCorrelationId
	}
	return ""
}

func (m *LedgerEntry) GetIsVoid() bool {
	if m != nil {
		return m.IsVoid
	}
	return false
}

func (m *LedgerEntry) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *LedgerEntry) GetEntryTypeId() int32 {
	if m != nil {
		return m.EntryTypeId
	}
	return 0
}

func (m *LedgerEntry) GetPostedDate() int32 {
	if m != nil {
		return m.PostedDate
	}
	return 0
}

func (m *LedgerEntry) GetEffectiveDate() int32 {
	if m != nil {
		return m.EffectiveDate
	}
	return 0
}

func (m *LedgerEntry) GetAppliedAmounts() []*LedgerBucketAmount {
	if m != nil {
		return m.AppliedAmounts
	}
	return nil
}

type LedgerBucketAmount struct {
	// The bucket type specified by the LedgerClassBucketType.id
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucket_type_id,omitempty"`
	// The amount applied to the bucket
	AppliedAmt cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=applied_amt,json=appliedAmt,proto3,customtype=cosmossdk.io/math.Int" json:"applied_amt"`
}

func (m *LedgerBucketAmount) Reset()         { *m = LedgerBucketAmount{} }
func (m *LedgerBucketAmount) String() string { return proto.CompactTextString(m) }
func (*LedgerBucketAmount) ProtoMessage()    {}
func (*LedgerBucketAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{7}
}
func (m *LedgerBucketAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerBucketAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerBucketAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerBucketAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerBucketAmount.Merge(m, src)
}
func (m *LedgerBucketAmount) XXX_Size() int {
	return m.Size()
}
func (m *LedgerBucketAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerBucketAmount.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerBucketAmount proto.InternalMessageInfo

func (m *LedgerBucketAmount) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

// Balances represents the current balances for principal, interest, and other amounts
type Balances struct {
	BucketBalances []*BucketBalance `protobuf:"bytes,1,rep,name=bucket_balances,json=bucketBalances,proto3" json:"bucket_balances,omitempty"`
}

func (m *Balances) Reset()         { *m = Balances{} }
func (m *Balances) String() string { return proto.CompactTextString(m) }
func (*Balances) ProtoMessage()    {}
func (*Balances) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{8}
}
func (m *Balances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Balances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Balances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Balances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Balances.Merge(m, src)
}
func (m *Balances) XXX_Size() int {
	return m.Size()
}
func (m *Balances) XXX_DiscardUnknown() {
	xxx_messageInfo_Balances.DiscardUnknown(m)
}

var xxx_messageInfo_Balances proto.InternalMessageInfo

func (m *Balances) GetBucketBalances() []*BucketBalance {
	if m != nil {
		return m.BucketBalances
	}
	return nil
}

type BucketBalance struct {
	// The bucket type specified by the LedgerClassBucketType.id
	BucketTypeId int32 `protobuf:"varint,1,opt,name=bucket_type_id,json=bucketTypeId,proto3" json:"bucket_type_id,omitempty"`
	// The balance of the bucket
	Balance cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=balance,proto3,customtype=cosmossdk.io/math.Int" json:"balance"`
}

func (m *BucketBalance) Reset()         { *m = BucketBalance{} }
func (m *BucketBalance) String() string { return proto.CompactTextString(m) }
func (*BucketBalance) ProtoMessage()    {}
func (*BucketBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_dee508b012fc2213, []int{9}
}
func (m *BucketBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketBalance.Merge(m, src)
}
func (m *BucketBalance) XXX_Size() int {
	return m.Size()
}
func (m *BucketBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BucketBalance proto.InternalMessageInfo

func (m *BucketBalance) GetBucketTypeId() int32 {
	if m != nil {
		return m.BucketTypeId
	}
	return 0
}

func init() {
	proto.RegisterType((*LedgerClass)(nil), "provenance.ledger.v1.LedgerClass")
	proto.RegisterType((*LedgerClassEntryType)(nil), "provenance.ledger.v1.LedgerClassEntryType")
	proto.RegisterType((*LedgerClassStatusType)(nil), "provenance.ledger.v1.LedgerClassStatusType")
	proto.RegisterType((*LedgerKey)(nil), "provenance.ledger.v1.LedgerKey")
	proto.RegisterType((*Ledger)(nil), "provenance.ledger.v1.Ledger")
	proto.RegisterType((*LedgerClassBucketType)(nil), "provenance.ledger.v1.LedgerClassBucketType")
	proto.RegisterType((*LedgerEntry)(nil), "provenance.ledger.v1.LedgerEntry")
	proto.RegisterType((*LedgerBucketAmount)(nil), "provenance.ledger.v1.LedgerBucketAmount")
	proto.RegisterType((*Balances)(nil), "provenance.ledger.v1.Balances")
	proto.RegisterType((*BucketBalance)(nil), "provenance.ledger.v1.BucketBalance")
}

func init() { proto.RegisterFile("provenance/ledger/v1/ledger.proto", fileDescriptor_dee508b012fc2213) }

var fileDescriptor_dee508b012fc2213 = []byte{
	// 755 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0x22, 0x47,
	0x10, 0x66, 0xc0, 0x60, 0x28, 0x7e, 0x2c, 0xb5, 0x40, 0x26, 0x3e, 0x00, 0x19, 0xc7, 0x11, 0x52,
	0x62, 0x90, 0x1d, 0x29, 0x77, 0xe3, 0x58, 0x32, 0x8a, 0x0f, 0xce, 0x24, 0x8a, 0xa2, 0x28, 0xd1,
	0x68, 0x98, 0x6e, 0xf0, 0xc8, 0xcc, 0xf4, 0x78, 0xba, 0x40, 0x46, 0xca, 0x03, 0xe4, 0x98, 0x6b,
	0x5e, 0x21, 0xe7, 0x3c, 0x84, 0x8f, 0xd6, 0x9e, 0x56, 0x7b, 0xb0, 0x56, 0xf6, 0x8b, 0xac, 0xba,
	0x7b, 0x66, 0xc0, 0x5e, 0x76, 0xe5, 0x5d, 0xf9, 0xd6, 0x55, 0xf5, 0xd5, 0x57, 0x3f, 0x5f, 0xc1,
	0xc0, 0x97, 0x61, 0xc4, 0xe7, 0x2c, 0x70, 0x02, 0x97, 0xf5, 0xa7, 0x8c, 0x4e, 0x58, 0xd4, 0x9f,
	0x1f, 0xc4, 0xaf, 0x5e, 0x18, 0x71, 0xe4, 0xa4, 0xbe, 0x84, 0xf4, 0xe2, 0xc0, 0xfc, 0x60, 0xa7,
	0x3e, 0xe1, 0x13, 0xae, 0x00, 0x7d, 0xf9, 0xd2, 0xd8, 0x9d, 0x2f, 0x5c, 0x2e, 0x7c, 0x2e, 0x6c,
	0x1d, 0xd0, 0x86, 0x0e, 0x99, 0x57, 0x50, 0x3e, 0x53, 0xd9, 0xc7, 0x53, 0x47, 0x08, 0xf2, 0x35,
	0x6c, 0x69, 0x32, 0xdb, 0x95, 0xb6, 0xed, 0xd1, 0xa6, 0xd1, 0x31, 0xba, 0x25, 0xab, 0x3a, 0x5d,
	0xa2, 0x86, 0x94, 0x7c, 0x05, 0x35, 0x47, 0x08, 0x86, 0x4b, 0x58, 0x56, 0xc1, 0x2a, 0xca, 0x9b,
	0xa0, 0xea, 0x90, 0xa7, 0x2c, 0xe0, 0x7e, 0x33, 0xa7, 0x82, 0xda, 0x30, 0xff, 0x80, 0xfa, 0x4a,
	0xc9, 0x93, 0x00, 0xa3, 0xc5, 0x2f, 0x8b, 0x90, 0x91, 0x1a, 0x64, 0xe3, 0x72, 0x79, 0x2b, 0xeb,
	0x51, 0x42, 0x60, 0xc3, 0xe5, 0x94, 0xc5, 0xcc, 0xea, 0x4d, 0x3a, 0x50, 0xa6, 0x4c, 0xb8, 0x91,
	0x17, 0xa2, 0xc7, 0x83, 0x98, 0x77, 0xd5, 0x65, 0xfe, 0x09, 0x8d, 0x15, 0xf6, 0x9f, 0xd1, 0xc1,
	0x99, 0x78, 0x41, 0xfa, 0x53, 0x28, 0x69, 0xfa, 0x1f, 0xd9, 0x82, 0x34, 0xa0, 0x10, 0x8c, 0x71,
	0xb9, 0xa4, 0x7c, 0x30, 0xc6, 0xe7, 0x2e, 0xc7, 0xfc, 0x37, 0x0b, 0x05, 0x4d, 0x45, 0x0e, 0x20,
	0x77, 0xc9, 0x16, 0x8a, 0xa4, 0x7c, 0xd8, 0xee, 0xad, 0x53, 0xb6, 0x97, 0x56, 0xb5, 0x24, 0x76,
	0x9d, 0x50, 0xd9, 0x0f, 0x08, 0x25, 0xd4, 0x0e, 0x6c, 0x5c, 0x84, 0x4c, 0xc2, 0x72, 0x6a, 0x03,
	0x15, 0x91, 0x6e, 0x66, 0x48, 0x89, 0x09, 0xd5, 0x80, 0x5d, 0xa3, 0x1d, 0xfa, 0x68, 0x53, 0x07,
	0x59, 0x73, 0x43, 0x81, 0xca, 0xd2, 0x79, 0xee, 0xe3, 0x0f, 0x0e, 0xca, 0xdd, 0x54, 0x52, 0x8c,
	0xe3, 0x63, 0x33, 0xdf, 0x31, 0xba, 0x39, 0x0b, 0x62, 0xc8, 0x91, 0x8f, 0x64, 0x17, 0xaa, 0x5e,
	0x80, 0x2c, 0x62, 0x02, 0xed, 0x48, 0xb2, 0x14, 0x74, 0xa9, 0xc4, 0x69, 0x49, 0x9a, 0x5d, 0xa8,
	0xfa, 0x0e, 0xce, 0x22, 0x0f, 0x17, 0xba, 0xd4, 0xa6, 0x06, 0x25, 0x4e, 0x59, 0xeb, 0x89, 0x88,
	0x83, 0x99, 0x7b, 0xc9, 0xf0, 0x05, 0x45, 0xfc, 0x2f, 0x97, 0x5c, 0xbd, 0xba, 0x3e, 0xb2, 0x07,
	0x35, 0x97, 0x47, 0x11, 0x9b, 0x3a, 0x32, 0xbc, 0x72, 0xf4, 0x2b, 0xde, 0x21, 0x25, 0xdf, 0xc3,
	0x76, 0xc4, 0xe6, 0x2c, 0x12, 0x4c, 0xd8, 0x4f, 0xf0, 0xba, 0x7e, 0x23, 0x09, 0x1f, 0x3f, 0xca,
	0xdb, 0x86, 0x4d, 0x4f, 0xd8, 0x73, 0x1e, 0x2f, 0xbf, 0x68, 0x15, 0x3c, 0xf1, 0x2b, 0xf7, 0x28,
	0xd9, 0x81, 0xa2, 0x60, 0x57, 0x33, 0x16, 0xb8, 0x7a, 0xe3, 0x55, 0x2b, 0xb5, 0xa5, 0x24, 0x4c,
	0x36, 0x97, 0xea, 0x96, 0xd7, 0x92, 0xb0, 0xe4, 0xf7, 0x32, 0xa4, 0xa4, 0x0d, 0xe5, 0x90, 0x0b,
	0x64, 0x74, 0x75, 0x93, 0xa0, 0x5d, 0x4a, 0xb3, 0x3d, 0xa8, 0xb1, 0xf1, 0x98, 0xb9, 0xe8, 0xcd,
	0x99, 0xc6, 0x14, 0x15, 0xa6, 0x9a, 0x7a, 0x15, 0xec, 0x14, 0x4a, 0xc8, 0xd1, 0x99, 0x2a, 0x5d,
	0x4b, 0x72, 0x94, 0xc1, 0x37, 0x37, 0x77, 0xed, 0xcc, 0x9b, 0xbb, 0x76, 0x43, 0xff, 0x5b, 0x08,
	0x7a, 0xd9, 0xf3, 0x78, 0xdf, 0x77, 0xf0, 0xa2, 0x37, 0x0c, 0xf0, 0xd5, 0xff, 0xfb, 0x10, 0xff,
	0x8d, 0x0c, 0x03, 0xb4, 0x8a, 0x2a, 0x5b, 0x9e, 0xc0, 0x4f, 0xb0, 0xe5, 0x84, 0xe1, 0xd4, 0x63,
	0xd4, 0x76, 0x7c, 0x3e, 0x0b, 0x50, 0x34, 0xa1, 0x93, 0xeb, 0x96, 0x0f, 0xbb, 0x1f, 0xbb, 0x6a,
	0x2d, 0xf0, 0x91, 0x4a, 0xb0, 0x6a, 0x31, 0x81, 0x36, 0x85, 0xf9, 0xb7, 0x01, 0xe4, 0x7d, 0x98,
	0x3c, 0xec, 0x91, 0xb2, 0xd3, 0x05, 0xe9, 0xab, 0xa8, 0x8c, 0xd2, 0x6b, 0x19, 0x52, 0x72, 0x06,
	0xe5, 0x65, 0x3f, 0xa8, 0x65, 0xfa, 0xb4, 0xd9, 0x20, 0x6d, 0x07, 0xcd, 0xdf, 0xa0, 0x38, 0x70,
	0xa6, 0x72, 0x04, 0x41, 0xce, 0x60, 0x2b, 0xae, 0x3f, 0x8a, 0x5d, 0x4d, 0x43, 0x4d, 0xba, 0xbb,
	0x7e, 0x52, 0xdd, 0x7c, 0x9c, 0x6e, 0xc5, 0xbd, 0x27, 0x6c, 0xe6, 0x5f, 0x50, 0x7d, 0x04, 0x78,
	0xe6, 0x78, 0x27, 0xb0, 0x19, 0x57, 0xff, 0x9c, 0xd1, 0x92, 0xdc, 0x81, 0x73, 0x73, 0xdf, 0x32,
	0x6e, 0xef, 0x5b, 0xc6, 0xdb, 0xfb, 0x96, 0xf1, 0xcf, 0x43, 0x2b, 0x73, 0xfb, 0xd0, 0xca, 0xbc,
	0x7e, 0x68, 0x65, 0x60, 0xdb, 0xe3, 0x6b, 0xc7, 0x39, 0x37, 0x7e, 0xff, 0x76, 0xe2, 0xe1, 0xc5,
	0x6c, 0xd4, 0x73, 0xb9, 0xdf, 0x5f, 0x42, 0xf6, 0x3d, 0xbe, 0x62, 0xf5, 0xaf, 0xe3, 0x8f, 0xd6,
	0xa8, 0xa0, 0x3e, 0x37, 0xdf, 0xbd, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x82, 0xa8, 0x18, 0xa6, 0xda,
	0x06, 0x00, 0x00,
}

func (m *LedgerClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassEntryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassEntryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassEntryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetClassId) > 0 {
		i -= len(m.AssetClassId)
		copy(dAtA[i:], m.AssetClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AssetClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ledger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ledger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ledger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaturityDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.MaturityDate))
		i--
		dAtA[i] = 0x38
	}
	if m.InterestRate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.InterestRate))
		i--
		dAtA[i] = 0x30
	}
	if m.NextPmtAmt != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtAmt))
		i--
		dAtA[i] = 0x28
	}
	if m.NextPmtDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.NextPmtDate))
		i--
		dAtA[i] = 0x20
	}
	if m.StatusTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.StatusTypeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LedgerClassId) > 0 {
		i -= len(m.LedgerClassId)
		copy(dAtA[i:], m.LedgerClassId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LedgerClassId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerClassBucketType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerClassBucketType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerClassBucketType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppliedAmounts) > 0 {
		for iNdEx := len(m.AppliedAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppliedAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size := m.TotalAmt.Size()
		i -= size
		if _, err := m.TotalAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.EffectiveDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EffectiveDate))
		i--
		dAtA[i] = 0x40
	}
	if m.PostedDate != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.PostedDate))
		i--
		dAtA[i] = 0x38
	}
	if m.EntryTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.EntryTypeId))
		i--
		dAtA[i] = 0x28
	}
	if m.Sequence != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if m.IsVoid {
		i--
		if m.IsVoid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReversesCorrelationId) > 0 {
		i -= len(m.ReversesCorrelationId)
		copy(dAtA[i:], m.ReversesCorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.ReversesCorrelationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CorrelationId) > 0 {
		i -= len(m.CorrelationId)
		copy(dAtA[i:], m.CorrelationId)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.CorrelationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerBucketAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerBucketAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerBucketAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AppliedAmt.Size()
		i -= size
		if _, err := m.AppliedAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Balances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Balances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Balances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BucketBalances) > 0 {
		for iNdEx := len(m.BucketBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BucketBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BucketBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Balance.Size()
		i -= size
		if _, err := m.Balance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLedger(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BucketTypeId != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BucketTypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLedger(dAtA []byte, offset int, v uint64) int {
	offset -= sovLedger(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LedgerClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassEntryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerClassStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.AssetClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *Ledger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.LedgerClassId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.StatusTypeId != 0 {
		n += 1 + sovLedger(uint64(m.StatusTypeId))
	}
	if m.NextPmtDate != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtDate))
	}
	if m.NextPmtAmt != 0 {
		n += 1 + sovLedger(uint64(m.NextPmtAmt))
	}
	if m.InterestRate != 0 {
		n += 1 + sovLedger(uint64(m.InterestRate))
	}
	if m.MaturityDate != 0 {
		n += 1 + sovLedger(uint64(m.MaturityDate))
	}
	return n
}

func (m *LedgerClassBucketType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLedger(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *LedgerEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.ReversesCorrelationId)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.IsVoid {
		n += 2
	}
	if m.Sequence != 0 {
		n += 1 + sovLedger(uint64(m.Sequence))
	}
	if m.EntryTypeId != 0 {
		n += 1 + sovLedger(uint64(m.EntryTypeId))
	}
	if m.PostedDate != 0 {
		n += 1 + sovLedger(uint64(m.PostedDate))
	}
	if m.EffectiveDate != 0 {
		n += 1 + sovLedger(uint64(m.EffectiveDate))
	}
	l = m.TotalAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	if len(m.AppliedAmounts) > 0 {
		for _, e := range m.AppliedAmounts {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *LedgerBucketAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.AppliedAmt.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func (m *Balances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BucketBalances) > 0 {
		for _, e := range m.BucketBalances {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *BucketBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketTypeId != 0 {
		n += 1 + sovLedger(uint64(m.BucketTypeId))
	}
	l = m.Balance.Size()
	n += 1 + l + sovLedger(uint64(l))
	return n
}

func sovLedger(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLedger(x uint64) (n int) {
	return sovLedger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LedgerClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassEntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassEntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassEntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ledger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ledger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ledger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LedgerKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LedgerClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusTypeId", wireType)
			}
			m.StatusTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtDate", wireType)
			}
			m.NextPmtDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPmtAmt", wireType)
			}
			m.NextPmtAmt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPmtAmt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestRate", wireType)
			}
			m.InterestRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterestRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaturityDate", wireType)
			}
			m.MaturityDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaturityDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerClassBucketType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerClassBucketType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerClassBucketType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReversesCorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReversesCorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVoid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVoid = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryTypeId", wireType)
			}
			m.EntryTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostedDate", wireType)
			}
			m.PostedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostedDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveDate", wireType)
			}
			m.EffectiveDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppliedAmounts = append(m.AppliedAmounts, &LedgerBucketAmount{})
			if err := m.AppliedAmounts[len(m.AppliedAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerBucketAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerBucketAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerBucketAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Balances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketBalances = append(m.BucketBalances, &BucketBalance{})
			if err := m.BucketBalances[len(m.BucketBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketTypeId", wireType)
			}
			m.BucketTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketTypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLedger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLedger
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLedger
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLedger
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLedger        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLedger          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLedger = fmt.Errorf("proto: unexpected end of group")
)
